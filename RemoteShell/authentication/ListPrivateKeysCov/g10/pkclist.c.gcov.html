<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - g10/pkclist.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">g10</a> - pkclist.c<span style="font-size: 80%;"> (source / <a href="pkclist.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">731</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 14:21:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* pkclist.c - create a list of public keys</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
<span class="lineNum">       3 </span>            :  *               2008, 2009, 2010 Free Software Foundation, Inc.
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * This file is part of GnuPG.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * GnuPG is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            :  * it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            :  * the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      10 </span>            :  * (at your option) any later version.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * GnuPG is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            :  * GNU General Public License for more details.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            :  * along with this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.
<span class="lineNum">      19 </span>            :  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;gpg.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;options.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;packet.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;../common/status.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;keydb.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;../common/util.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;main.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;trustdb.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;../common/ttyio.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;../common/status.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;photoid.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;../common/i18n.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;tofu.h&quot;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #define CONTROL_D ('D' - 'A' + 1)
<a name="42"><span class="lineNum">      42 </span>            : </a>
<span class="lineNum">      43 </span>            : static void
<span class="lineNum">      44 </span><span class="lineNoCov">          0 : send_status_inv_recp (int reason, const char *name)</span>
<span class="lineNum">      45 </span>            : {
<span class="lineNum">      46 </span>            :   char buf[40];
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineNoCov">          0 :   snprintf (buf, sizeof buf, &quot;%d &quot;, reason);</span>
<span class="lineNum">      49 </span><span class="lineNoCov">          0 :   write_status_text_and_buffer (STATUS_INV_RECP, buf,</span>
<span class="lineNum">      50 </span>            :                                 name, strlen (name),
<span class="lineNum">      51 </span>            :                                 -1);
<span class="lineNum">      52 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : /****************
<span class="lineNum">      56 </span>            :  * Show the revocation reason as it is stored with the given signature
<a name="57"><span class="lineNum">      57 </span>            :  */</a>
<span class="lineNum">      58 </span>            : static void
<span class="lineNum">      59 </span><span class="lineNoCov">          0 : do_show_revocation_reason( PKT_signature *sig )</span>
<span class="lineNum">      60 </span>            : {
<span class="lineNum">      61 </span>            :     size_t n, nn;
<span class="lineNum">      62 </span>            :     const byte *p, *pp;
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     int seq = 0;</span>
<span class="lineNum">      64 </span>            :     const char *text;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :     while( (p = enum_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_REVOC_REASON,</span>
<span class="lineNum">      67 </span>            :                                  &amp;n, &amp;seq, NULL )) ) {
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :         if( !n )</span>
<span class="lineNum">      69 </span><span class="lineNoCov">          0 :             continue; /* invalid - just skip it */</span>
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :         if( *p == 0 )</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :             text = _(&quot;No reason specified&quot;);</span>
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         else if( *p == 0x01 )</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :             text = _(&quot;Key is superseded&quot;);</span>
<span class="lineNum">      75 </span><span class="lineNoCov">          0 :         else if( *p == 0x02 )</span>
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :             text = _(&quot;Key has been compromised&quot;);</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :         else if( *p == 0x03 )</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :             text = _(&quot;Key is no longer used&quot;);</span>
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :         else if( *p == 0x20 )</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :             text = _(&quot;User ID is no longer valid&quot;);</span>
<span class="lineNum">      81 </span>            :         else
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :             text = NULL;</span>
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :         log_info ( _(&quot;reason for revocation: &quot;));</span>
<span class="lineNum">      85 </span><span class="lineNoCov">          0 :         if (text)</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :           log_printf (&quot;%s\n&quot;, text);</span>
<span class="lineNum">      87 </span>            :         else
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :           log_printf (&quot;code=%02x\n&quot;, *p );</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :         n--; p++;</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         pp = NULL;</span>
<span class="lineNum">      91 </span>            :         do {
<span class="lineNum">      92 </span>            :             /* We don't want any empty lines, so skip them */
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :             while( n &amp;&amp; *p == '\n' ) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :                 p++;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :                 n--;</span>
<span class="lineNum">      96 </span>            :             }
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :             if( n ) {</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                 pp = memchr( p, '\n', n );</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :                 nn = pp? pp - p : n;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :                 log_info ( _(&quot;revocation comment: &quot;) );</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :                 es_write_sanitized (log_get_stream(), p, nn, NULL, NULL);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :                 log_printf (&quot;\n&quot;);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 p += nn; n -= nn;</span>
<span class="lineNum">     104 </span>            :             }
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :         } while( pp );</span>
<span class="lineNum">     106 </span>            :     }
<span class="lineNum">     107 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : /* Mode 0: try and find the revocation based on the pk (i.e. check
<span class="lineNum">     110 </span>            :    subkeys, etc.)  Mode 1: use only the revocation on the main pk */
<a name="111"><span class="lineNum">     111 </span>            : </a>
<span class="lineNum">     112 </span>            : void
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : show_revocation_reason (ctrl_t ctrl, PKT_public_key *pk, int mode)</span>
<span class="lineNum">     114 </span>            : {
<span class="lineNum">     115 </span>            :     /* Hmmm, this is not so easy because we have to duplicate the code
<span class="lineNum">     116 </span>            :      * used in the trustbd to calculate the keyflags.  We need to find
<span class="lineNum">     117 </span>            :      * a clean way to check revocation certificates on keys and
<span class="lineNum">     118 </span>            :      * signatures.  And there should be no duplicate code.  Because we
<span class="lineNum">     119 </span>            :      * enter this function only when the trustdb told us that we have
<span class="lineNum">     120 </span>            :      * a revoked key, we could simply look for a revocation cert and
<span class="lineNum">     121 </span>            :      * display this one, when there is only one. Let's try to do this
<span class="lineNum">     122 </span>            :      * until we have a better solution.  */
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :     KBNODE node, keyblock = NULL;</span>
<span class="lineNum">     124 </span>            :     byte fingerprint[MAX_FINGERPRINT_LEN];
<span class="lineNum">     125 </span>            :     size_t fingerlen;
<span class="lineNum">     126 </span>            :     int rc;
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :     /* get the keyblock */
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     fingerprint_from_pk( pk, fingerprint, &amp;fingerlen );</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     rc = get_pubkey_byfprint (ctrl, NULL, &amp;keyblock, fingerprint, fingerlen);</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     if( rc ) { /* that should never happen */</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         log_debug( &quot;failed to get the keyblock\n&quot;);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     134 </span>            :     }
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :     for( node=keyblock; node; node = node-&gt;next ) {</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         if( (mode &amp;&amp; node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_KEY) ||</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :           ( ( node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_KEY</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :               || node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY )</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :             &amp;&amp; !cmp_public_keys( node-&gt;pkt-&gt;pkt.public_key, pk ) ) )</span>
<span class="lineNum">     141 </span>            :             break;
<span class="lineNum">     142 </span>            :     }
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :     if( !node ) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         log_debug(&quot;Oops, PK not in keyblock\n&quot;);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         release_kbnode( keyblock );</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     147 </span>            :     }
<span class="lineNum">     148 </span>            :     /* now find the revocation certificate */
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     for( node = node-&gt;next; node ; node = node-&gt;next ) {</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :         if( node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY )</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         if( node-&gt;pkt-&gt;pkttype == PKT_SIGNATURE</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             &amp;&amp; (node-&gt;pkt-&gt;pkt.signature-&gt;sig_class == 0x20</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                 || node-&gt;pkt-&gt;pkt.signature-&gt;sig_class == 0x28 ) ) {</span>
<span class="lineNum">     155 </span>            :                 /* FIXME: we should check the signature here */
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                 do_show_revocation_reason ( node-&gt;pkt-&gt;pkt.signature );</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     158 </span>            :         }
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :     /* We didn't find it, so check if the whole key is revoked */
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :     if(!node &amp;&amp; !mode)</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       show_revocation_reason (ctrl, pk, 1);</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     release_kbnode( keyblock );</span>
<span class="lineNum">     166 </span>            : }
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : /****************
<span class="lineNum">     170 </span>            :  * mode: 0 = standard
<span class="lineNum">     171 </span>            :  *       1 = Without key info and additional menu option 'm'
<span class="lineNum">     172 </span>            :  *           this does also add an option to set the key to ultimately trusted.
<span class="lineNum">     173 </span>            :  * Returns:
<span class="lineNum">     174 </span>            :  *      -2 = nothing changed - caller should show some additional info
<span class="lineNum">     175 </span>            :  *      -1 = quit operation
<span class="lineNum">     176 </span>            :  *       0 = nothing changed
<span class="lineNum">     177 </span>            :  *       1 = new ownertrust now in new_trust
<span class="lineNum">     178 </span>            :  */
<a name="179"><span class="lineNum">     179 </span>            : #ifndef NO_TRUST_MODELS</a>
<span class="lineNum">     180 </span>            : static int
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : do_edit_ownertrust (ctrl_t ctrl, PKT_public_key *pk, int mode,</span>
<span class="lineNum">     182 </span>            :                     unsigned *new_trust, int defer_help )
<span class="lineNum">     183 </span>            : {
<span class="lineNum">     184 </span>            :   char *p;
<span class="lineNum">     185 </span>            :   u32 keyid[2];
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   int changed=0;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   int quit=0;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   int show=0;</span>
<span class="lineNum">     189 </span>            :   int min_num;
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   int did_help=defer_help;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   unsigned int minimum = tdb_get_min_ownertrust (ctrl, pk, 0);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   switch(minimum)</span>
<span class="lineNum">     194 </span>            :     {
<span class="lineNum">     195 </span>            :     default:
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     case TRUST_UNDEFINED: min_num=1; break;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     case TRUST_NEVER:     min_num=2; break;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     case TRUST_MARGINAL:  min_num=3; break;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     case TRUST_FULLY:     min_num=4; break;</span>
<span class="lineNum">     200 </span>            :     }
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   keyid_from_pk (pk, keyid);</span>
<span class="lineNum">     203 </span>            :   for(;;) {
<span class="lineNum">     204 </span>            :     /* A string with valid answers.
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :        TRANSLATORS: These are the allowed answers in lower and
<span class="lineNum">     207 </span>            :        uppercase.  Below you will find the matching strings which
<span class="lineNum">     208 </span>            :        should be translated accordingly and the letter changed to
<span class="lineNum">     209 </span>            :        match the one in the answer string.
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :          i = please show me more information
<span class="lineNum">     212 </span>            :          m = back to the main menu
<span class="lineNum">     213 </span>            :          s = skip this key
<span class="lineNum">     214 </span>            :          q = quit
<span class="lineNum">     215 </span>            :     */
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :     const char *ans = _(&quot;iImMqQsS&quot;);</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :     if( !did_help )</span>
<span class="lineNum">     219 </span>            :       {
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :         if( !mode )</span>
<span class="lineNum">     221 </span>            :           {
<span class="lineNum">     222 </span>            :             KBNODE keyblock, un;
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :             tty_printf (_(&quot;No trust value assigned to:\n&quot;));</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :             print_key_line (ctrl, NULL, pk, 0);</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :             p = get_user_id_native (ctrl, keyid);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :             tty_printf (_(&quot;      \&quot;%s\&quot;\n&quot;),p);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :             xfree (p);</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :             keyblock = get_pubkeyblock (ctrl, keyid);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :             if (!keyblock)</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                 BUG ();</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :             for (un=keyblock; un; un = un-&gt;next)</span>
<span class="lineNum">     235 </span>            :               {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :                 if (un-&gt;pkt-&gt;pkttype != PKT_USER_ID )</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                 if (un-&gt;pkt-&gt;pkt.user_id-&gt;flags.revoked)</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 if (un-&gt;pkt-&gt;pkt.user_id-&gt;flags.expired)</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">     242 </span>            :                 /* Only skip textual primaries */
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                 if (un-&gt;pkt-&gt;pkt.user_id-&gt;flags.primary</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                     &amp;&amp; !un-&gt;pkt-&gt;pkt.user_id-&gt;attrib_data )</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :                 if((opt.verify_options&amp;VERIFY_SHOW_PHOTOS)</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                    &amp;&amp; un-&gt;pkt-&gt;pkt.user_id-&gt;attrib_data)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                   show_photos (ctrl,</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                                un-&gt;pkt-&gt;pkt.user_id-&gt;attribs,</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :                                un-&gt;pkt-&gt;pkt.user_id-&gt;numattribs, pk,</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                                un-&gt;pkt-&gt;pkt.user_id);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                 p=utf8_to_native(un-&gt;pkt-&gt;pkt.user_id-&gt;name,</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                                  un-&gt;pkt-&gt;pkt.user_id-&gt;len,0);</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :                 tty_printf(_(&quot;  aka \&quot;%s\&quot;\n&quot;),p);</span>
<span class="lineNum">     258 </span>            :               }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :             print_fingerprint (ctrl, NULL, pk, 2);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :             tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :             release_kbnode (keyblock);</span>
<span class="lineNum">     263 </span>            :           }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         if(opt.trust_model==TM_DIRECT)</span>
<span class="lineNum">     266 </span>            :           {
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;How much do you trust that this key actually &quot;</span>
<span class="lineNum">     268 </span>            :                          &quot;belongs to the named user?\n&quot;));
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :             tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     270 </span>            :           }
<span class="lineNum">     271 </span>            :         else
<span class="lineNum">     272 </span>            :           {
<span class="lineNum">     273 </span>            :             /* This string also used in keyedit.c:trustsig_prompt */
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;Please decide how far you trust this user to&quot;</span>
<span class="lineNum">     275 </span>            :                          &quot; correctly verify other users' keys\n&quot;
<span class="lineNum">     276 </span>            :                          &quot;(by looking at passports, checking fingerprints from&quot;
<span class="lineNum">     277 </span>            :                          &quot; different sources, etc.)\n&quot;));
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :             tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     279 </span>            :           }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         if(min_num&lt;=1)</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;  %d = I don't know or won't say\n&quot;), 1);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         if(min_num&lt;=2)</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;  %d = I do NOT trust\n&quot;), 2);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         if(min_num&lt;=3)</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;  %d = I trust marginally\n&quot;), 3);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         if(min_num&lt;=4)</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;  %d = I trust fully\n&quot;), 4);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         if (mode)</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;  %d = I trust ultimately\n&quot;), 5);</span>
<span class="lineNum">     291 </span>            : #if 0
<span class="lineNum">     292 </span>            :         /* not yet implemented */
<span class="lineNum">     293 </span>            :         tty_printf (&quot;  i = please show me more information\n&quot;);
<span class="lineNum">     294 </span>            : #endif
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         if( mode )</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :           tty_printf(_(&quot;  m = back to the main menu\n&quot;));</span>
<span class="lineNum">     297 </span>            :         else
<span class="lineNum">     298 </span>            :           {
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;  s = skip this key\n&quot;));</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;  q = quit\n&quot;));</span>
<span class="lineNum">     301 </span>            :           }
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :         tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         if(minimum)</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :           tty_printf(_(&quot;The minimum trust level for this key is: %s\n\n&quot;),</span>
<span class="lineNum">     305 </span>            :                      trust_value_to_string(minimum));
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         did_help = 1;</span>
<span class="lineNum">     307 </span>            :       }
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :     if( strlen(ans) != 8 )</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       BUG();</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     p = cpr_get(&quot;edit_ownertrust.value&quot;,_(&quot;Your decision? &quot;));</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     trim_spaces(p);</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     cpr_kill_prompt();</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     if( !*p )</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       did_help = 0;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     else if( *p &amp;&amp; p[1] )</span>
<span class="lineNum">     316 </span>            :       ;
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     else if( !p[1] &amp;&amp; ((*p &gt;= '0'+min_num) &amp;&amp; *p &lt;= (mode?'5':'4')) )</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">     319 </span>            :         unsigned int trust;
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :         switch( *p )</span>
<span class="lineNum">     321 </span>            :           {
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :           case '1': trust = TRUST_UNDEFINED; break;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :           case '2': trust = TRUST_NEVER    ; break;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           case '3': trust = TRUST_MARGINAL ; break;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :           case '4': trust = TRUST_FULLY    ; break;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :           case '5': trust = TRUST_ULTIMATE ; break;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :           default: BUG();</span>
<span class="lineNum">     328 </span>            :           }
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :         if (trust == TRUST_ULTIMATE</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :             &amp;&amp; !cpr_get_answer_is_yes (&quot;edit_ownertrust.set_ultimate.okay&quot;,</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :                                        _(&quot;Do you really want to set this key&quot;</span>
<span class="lineNum">     332 </span>            :                                          &quot; to ultimate trust? (y/N) &quot;)))
<span class="lineNum">     333 </span>            :           ; /* no */
<span class="lineNum">     334 </span>            :         else
<span class="lineNum">     335 </span>            :           {
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :             *new_trust = trust;</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :             changed = 1;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     339 </span>            :           }
<span class="lineNum">     340 </span>            :       }
<span class="lineNum">     341 </span>            : #if 0
<span class="lineNum">     342 </span>            :     /* not yet implemented */
<span class="lineNum">     343 </span>            :     else if( *p == ans[0] || *p == ans[1] )
<span class="lineNum">     344 </span>            :       {
<span class="lineNum">     345 </span>            :         tty_printf(_(&quot;Certificates leading to an ultimately trusted key:\n&quot;));
<span class="lineNum">     346 </span>            :         show = 1;
<span class="lineNum">     347 </span>            :         break;
<span class="lineNum">     348 </span>            :       }
<span class="lineNum">     349 </span>            : #endif
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     else if( mode &amp;&amp; (*p == ans[2] || *p == ans[3] || *p == CONTROL_D ) )</span>
<span class="lineNum">     351 </span>            :       {
<span class="lineNum">     352 </span>            :         break ; /* back to the menu */
<span class="lineNum">     353 </span>            :       }
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     else if( !mode &amp;&amp; (*p == ans[6] || *p == ans[7] ) )</span>
<span class="lineNum">     355 </span>            :       {
<span class="lineNum">     356 </span>            :         break; /* skip */
<span class="lineNum">     357 </span>            :       }
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     else if( !mode &amp;&amp; (*p == ans[4] || *p == ans[5] ) )</span>
<span class="lineNum">     359 </span>            :       {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         quit = 1;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         break ; /* back to the menu */</span>
<span class="lineNum">     362 </span>            :       }
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :     xfree(p); p = NULL;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   xfree(p);</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   return show? -2: quit? -1 : changed;</span>
<span class="lineNum">     367 </span>            : }
<span class="lineNum">     368 </span>            : #endif /*!NO_TRUST_MODELS*/
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : /*
<span class="lineNum">     372 </span>            :  * Display a menu to change the ownertrust of the key PK (which should
<span class="lineNum">     373 </span>            :  * be a primary key).
<span class="lineNum">     374 </span>            :  * For mode values see do_edit_ownertrust ()
<span class="lineNum">     375 </span>            :  */
<a name="376"><span class="lineNum">     376 </span>            : #ifndef NO_TRUST_MODELS</a>
<span class="lineNum">     377 </span>            : int
<span class="lineNum">     378 </span><span class="lineNoCov">          0 : edit_ownertrust (ctrl_t ctrl, PKT_public_key *pk, int mode )</span>
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   unsigned int trust = 0;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :   int no_help = 0;</span>
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   for(;;)
<span class="lineNum">     384 </span>            :     {
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       switch ( do_edit_ownertrust (ctrl, pk, mode, &amp;trust, no_help ) )</span>
<span class="lineNum">     386 </span>            :         {
<span class="lineNum">     387 </span>            :         case -1: /* quit */
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">     389 </span>            :         case -2: /* show info */
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :           no_help = 1;</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     392 </span>            :         case 1: /* trust value set */
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :           trust &amp;= ~TRUST_FLAG_DISABLED;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :           trust |= get_ownertrust (ctrl, pk) &amp; TRUST_FLAG_DISABLED;</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :           update_ownertrust (ctrl, pk, trust );</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :           return 1;</span>
<span class="lineNum">     397 </span>            :         default:
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">     399 </span>            :         }
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     401 </span>            : }
<span class="lineNum">     402 </span>            : #endif /*!NO_TRUST_MODELS*/
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : /****************
<span class="lineNum">     406 </span>            :  * Check whether we can trust this pk which has a trustlevel of TRUSTLEVEL
<span class="lineNum">     407 </span>            :  * Returns: true if we trust.
<a name="408"><span class="lineNum">     408 </span>            :  */</a>
<span class="lineNum">     409 </span>            : static int
<span class="lineNum">     410 </span><span class="lineNoCov">          0 : do_we_trust( PKT_public_key *pk, unsigned int trustlevel )</span>
<span class="lineNum">     411 </span>            : {
<span class="lineNum">     412 </span>            :   /* We should not be able to get here with a revoked or expired
<span class="lineNum">     413 </span>            :      key */
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   if(trustlevel &amp; TRUST_FLAG_REVOKED</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :      || trustlevel &amp; TRUST_FLAG_SUB_REVOKED</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :      || (trustlevel &amp; TRUST_MASK) == TRUST_EXPIRED)</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     BUG();</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   if( opt.trust_model==TM_ALWAYS )</span>
<span class="lineNum">     420 </span>            :     {
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :       if( opt.verbose )</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :         log_info(&quot;No trust check due to '--trust-model always' option\n&quot;);</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :       return 1;</span>
<span class="lineNum">     424 </span>            :     }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   switch(trustlevel &amp; TRUST_MASK)</span>
<span class="lineNum">     427 </span>            :     {
<span class="lineNum">     428 </span>            :     default:
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       log_error (&quot;invalid trustlevel %u returned from validation layer\n&quot;,</span>
<span class="lineNum">     430 </span>            :                  trustlevel);
<span class="lineNum">     431 </span>            :       /* fall through */
<span class="lineNum">     432 </span>            :     case TRUST_UNKNOWN:
<span class="lineNum">     433 </span>            :     case TRUST_UNDEFINED:
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       log_info(_(&quot;%s: There is no assurance this key belongs&quot;</span>
<span class="lineNum">     435 </span>            :                  &quot; to the named user\n&quot;),keystr_from_pk(pk));
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       return 0; /* no */</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :     case TRUST_MARGINAL:
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       log_info(_(&quot;%s: There is limited assurance this key belongs&quot;</span>
<span class="lineNum">     440 </span>            :                  &quot; to the named user\n&quot;),keystr_from_pk(pk));
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :       return 1; /* yes */</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :     case TRUST_FULLY:
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :       if( opt.verbose )</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :         log_info(_(&quot;This key probably belongs to the named user\n&quot;));</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       return 1; /* yes */</span>
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :     case TRUST_ULTIMATE:
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :       if( opt.verbose )</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         log_info(_(&quot;This key belongs to us\n&quot;));</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :       return 1; /* yes */</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :     case TRUST_NEVER:
<span class="lineNum">     454 </span>            :       /* This can be returned by TOFU, which can return negative
<span class="lineNum">     455 </span>            :          assertions.  */
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       log_info(_(&quot;%s: This key is bad!  It has been marked as untrusted!\n&quot;),</span>
<span class="lineNum">     457 </span>            :                keystr_from_pk(pk));
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       return 0; /* no */</span>
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :   return 1; /*NOTREACHED*/
<span class="lineNum">     462 </span>            : }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /****************
<span class="lineNum">     466 </span>            :  * wrapper around do_we_trust, so we can ask whether to use the
<span class="lineNum">     467 </span>            :  * key anyway.
<a name="468"><span class="lineNum">     468 </span>            :  */</a>
<span class="lineNum">     469 </span>            : static int
<span class="lineNum">     470 </span><span class="lineNoCov">          0 : do_we_trust_pre (ctrl_t ctrl, PKT_public_key *pk, unsigned int trustlevel )</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :   int rc;
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   rc = do_we_trust( pk, trustlevel );</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :   if( !opt.batch &amp;&amp; !rc )</span>
<span class="lineNum">     477 </span>            :     {
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :       print_pubkey_info (ctrl, NULL,pk);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :       print_fingerprint (ctrl, NULL, pk, 2);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       if ((trustlevel &amp; TRUST_MASK) == TRUST_NEVER)</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         tty_printf(</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :           _(&quot;This key is bad!  It has been marked as untrusted!  If you\n&quot;</span>
<span class="lineNum">     485 </span>            :             &quot;*really* know what you are doing, you may answer the next\n&quot;
<span class="lineNum">     486 </span>            :             &quot;question with yes.\n&quot;));
<span class="lineNum">     487 </span>            :       else
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         tty_printf(</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :           _(&quot;It is NOT certain that the key belongs to the person named\n&quot;</span>
<span class="lineNum">     490 </span>            :             &quot;in the user ID.  If you *really* know what you are doing,\n&quot;
<span class="lineNum">     491 </span>            :             &quot;you may answer the next question with yes.\n&quot;));
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :       if (is_status_enabled ())</span>
<span class="lineNum">     497 </span>            :         {
<span class="lineNum">     498 </span>            :           u32 kid[2];
<span class="lineNum">     499 </span>            :           char *hint_str;
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :           keyid_from_pk (pk, kid);</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :           hint_str = get_long_user_id_string (ctrl, kid);</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           write_status_text ( STATUS_USERID_HINT, hint_str );</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :           xfree (hint_str);</span>
<span class="lineNum">     505 </span>            :         }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :       if( cpr_get_answer_is_yes(&quot;untrusted_key.override&quot;,</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                                 _(&quot;Use this key anyway? (y/N) &quot;))  )</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :         rc = 1;</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :       /* Hmmm: Should we set a flag to tell the user about
<span class="lineNum">     512 </span>            :        *         his decision the next time he encrypts for this recipient?
<span class="lineNum">     513 </span>            :        */
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">     517 </span>            : }
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : 
<a name="520"><span class="lineNum">     520 </span>            : /* Write a TRUST_foo status line inclduing the validation model.  */</a>
<span class="lineNum">     521 </span>            : static void
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : write_trust_status (int statuscode, int trustlevel)</span>
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span>            : #ifdef NO_TRUST_MODELS
<span class="lineNum">     525 </span>            :   write_status (statuscode);
<span class="lineNum">     526 </span>            : #else /* NO_TRUST_MODELS */
<span class="lineNum">     527 </span>            :   int tm;
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   /* For the combined tofu+pgp method, we return the trust model which
<span class="lineNum">     530 </span>            :    * was responsible for the trustlevel.  */
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   if (opt.trust_model == TM_TOFU_PGP)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :     tm = (trustlevel &amp; TRUST_FLAG_TOFU_BASED)? TM_TOFU : TM_PGP;</span>
<span class="lineNum">     533 </span>            :   else
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     tm = opt.trust_model;</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :   write_status_strings (statuscode, &quot;0 &quot;, trust_model_string (tm), NULL);</span>
<span class="lineNum">     536 </span>            : #endif /* NO_TRUST_MODELS */
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : /****************
<span class="lineNum">     541 </span>            :  * Check whether we can trust this signature.
<span class="lineNum">     542 </span>            :  * Returns an error code if we should not trust this signature.
<a name="543"><span class="lineNum">     543 </span>            :  */</a>
<span class="lineNum">     544 </span>            : int
<span class="lineNum">     545 </span><span class="lineNoCov">          0 : check_signatures_trust (ctrl_t ctrl, PKT_signature *sig)</span>
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   PKT_public_key *pk = xmalloc_clear( sizeof *pk );</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   unsigned int trustlevel = TRUST_UNKNOWN;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   int rc=0;</span>
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   rc = get_pubkey (ctrl, pk, sig-&gt;keyid );</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">     553 </span>            :     { /* this should not happen */
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       log_error(&quot;Ooops; the key vanished  - can't check the trust\n&quot;);</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :       rc = GPG_ERR_NO_PUBKEY;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">     557 </span>            :     }
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   if ( opt.trust_model==TM_ALWAYS )</span>
<span class="lineNum">     560 </span>            :     {
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :       if( !opt.quiet )</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :         log_info(_(&quot;WARNING: Using untrusted key!\n&quot;));</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :       if (opt.with_fingerprint)</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :         print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   if(pk-&gt;flags.maybe_revoked &amp;&amp; !pk-&gt;flags.revoked)</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     log_info(_(&quot;WARNING: this key might be revoked (revocation key&quot;</span>
<span class="lineNum">     570 </span>            :                &quot; not present)\n&quot;));
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   trustlevel = get_validity (ctrl, NULL, pk, NULL, sig, 1);</span>
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :   if ( (trustlevel &amp; TRUST_FLAG_REVOKED) )</span>
<span class="lineNum">     575 </span>            :     {
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :       write_status( STATUS_KEYREVOKED );</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :       if(pk-&gt;flags.revoked == 2)</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         log_info(_(&quot;WARNING: This key has been revoked by its&quot;</span>
<span class="lineNum">     579 </span>            :                    &quot; designated revoker!\n&quot;));
<span class="lineNum">     580 </span>            :       else
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         log_info(_(&quot;WARNING: This key has been revoked by its owner!\n&quot;));</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :       log_info(_(&quot;         This could mean that the signature is forged.\n&quot;));</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :       show_revocation_reason (ctrl, pk, 0);</span>
<span class="lineNum">     584 </span>            :     }
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   else if ((trustlevel &amp; TRUST_FLAG_SUB_REVOKED) )</span>
<span class="lineNum">     586 </span>            :     {
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :       write_status( STATUS_KEYREVOKED );</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :       log_info(_(&quot;WARNING: This subkey has been revoked by its owner!\n&quot;));</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       show_revocation_reason (ctrl, pk, 0);</span>
<span class="lineNum">     590 </span>            :     }
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   if ((trustlevel &amp; TRUST_FLAG_DISABLED))</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     log_info (_(&quot;Note: This key has been disabled.\n&quot;));</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   /* If we have PKA information adjust the trustlevel. */
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   if (sig-&gt;pka_info &amp;&amp; sig-&gt;pka_info-&gt;valid)</span>
<span class="lineNum">     597 </span>            :     {
<span class="lineNum">     598 </span>            :       unsigned char fpr[MAX_FINGERPRINT_LEN];
<span class="lineNum">     599 </span>            :       PKT_public_key *primary_pk;
<span class="lineNum">     600 </span>            :       size_t fprlen;
<span class="lineNum">     601 </span>            :       int okay;
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :       primary_pk = xmalloc_clear (sizeof *primary_pk);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :       get_pubkey (ctrl, primary_pk, pk-&gt;main_keyid);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :       fingerprint_from_pk (primary_pk, fpr, &amp;fprlen);</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       free_public_key (primary_pk);</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :       if ( fprlen == 20 &amp;&amp; !memcmp (sig-&gt;pka_info-&gt;fpr, fpr, 20) )</span>
<span class="lineNum">     610 </span>            :         {
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :           okay = 1;</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :           write_status_text (STATUS_PKA_TRUST_GOOD, sig-&gt;pka_info-&gt;email);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :           log_info (_(&quot;Note: Verified signer's address is '%s'\n&quot;),</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                     sig-&gt;pka_info-&gt;email);</span>
<span class="lineNum">     615 </span>            :         }
<span class="lineNum">     616 </span>            :       else
<span class="lineNum">     617 </span>            :         {
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :           okay = 0;</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :           write_status_text (STATUS_PKA_TRUST_BAD, sig-&gt;pka_info-&gt;email);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :           log_info (_(&quot;Note: Signer's address '%s' &quot;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :                       &quot;does not match DNS entry\n&quot;), sig-&gt;pka_info-&gt;email);</span>
<span class="lineNum">     622 </span>            :         }
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       switch ( (trustlevel &amp; TRUST_MASK) )</span>
<span class="lineNum">     625 </span>            :         {
<span class="lineNum">     626 </span>            :         case TRUST_UNKNOWN:
<span class="lineNum">     627 </span>            :         case TRUST_UNDEFINED:
<span class="lineNum">     628 </span>            :         case TRUST_MARGINAL:
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :           if (okay &amp;&amp; opt.verify_options&amp;VERIFY_PKA_TRUST_INCREASE)</span>
<span class="lineNum">     630 </span>            :             {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :               trustlevel = ((trustlevel &amp; ~TRUST_MASK) | TRUST_FULLY);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :               log_info (_(&quot;trustlevel adjusted to FULL&quot;</span>
<span class="lineNum">     633 </span>            :                           &quot; due to valid PKA info\n&quot;));
<span class="lineNum">     634 </span>            :             }
<span class="lineNum">     635 </span>            :           /* fall through */
<span class="lineNum">     636 </span>            :         case TRUST_FULLY:
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :           if (!okay)</span>
<span class="lineNum">     638 </span>            :             {
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :               trustlevel = ((trustlevel &amp; ~TRUST_MASK) | TRUST_NEVER);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :               log_info (_(&quot;trustlevel adjusted to NEVER&quot;</span>
<span class="lineNum">     641 </span>            :                           &quot; due to bad PKA info\n&quot;));
<span class="lineNum">     642 </span>            :             }
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     644 </span>            :         }
<span class="lineNum">     645 </span>            :     }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            :   /* Now let the user know what up with the trustlevel. */
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :   switch ( (trustlevel &amp; TRUST_MASK) )</span>
<span class="lineNum">     649 </span>            :     {
<span class="lineNum">     650 </span>            :     case TRUST_EXPIRED:
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :       log_info(_(&quot;Note: This key has expired!\n&quot;));</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :       print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :     default:
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :       log_error (&quot;invalid trustlevel %u returned from validation layer\n&quot;,</span>
<span class="lineNum">     657 </span>            :                  trustlevel);
<span class="lineNum">     658 </span>            :       /* fall through */
<span class="lineNum">     659 </span>            :     case TRUST_UNKNOWN:
<span class="lineNum">     660 </span>            :     case TRUST_UNDEFINED:
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :       write_trust_status (STATUS_TRUST_UNDEFINED, trustlevel);</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :       log_info(_(&quot;WARNING: This key is not certified with&quot;</span>
<span class="lineNum">     663 </span>            :                  &quot; a trusted signature!\n&quot;));
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       log_info(_(&quot;         There is no indication that the &quot;</span>
<span class="lineNum">     665 </span>            :                  &quot;signature belongs to the owner.\n&quot; ));
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :       print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :     case TRUST_NEVER:
<span class="lineNum">     670 </span>            :       /* This level can be returned by TOFU, which supports negative
<span class="lineNum">     671 </span>            :        * assertions.  */
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       write_trust_status (STATUS_TRUST_NEVER, trustlevel);</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       log_info(_(&quot;WARNING: We do NOT trust this key!\n&quot;));</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       log_info(_(&quot;         The signature is probably a FORGERY.\n&quot;));</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :       if (opt.with_fingerprint)</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :         print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       rc = gpg_error (GPG_ERR_BAD_SIGNATURE);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            :     case TRUST_MARGINAL:
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       write_trust_status (STATUS_TRUST_MARGINAL, trustlevel);</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :       log_info(_(&quot;WARNING: This key is not certified with&quot;</span>
<span class="lineNum">     683 </span>            :                  &quot; sufficiently trusted signatures!\n&quot;));
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :       log_info(_(&quot;         It is not certain that the&quot;</span>
<span class="lineNum">     685 </span>            :                  &quot; signature belongs to the owner.\n&quot; ));
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :     case TRUST_FULLY:
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :       write_trust_status (STATUS_TRUST_FULLY, trustlevel);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :       if (opt.with_fingerprint)</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :         print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :     case TRUST_ULTIMATE:
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       write_trust_status (STATUS_TRUST_ULTIMATE, trustlevel);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       if (opt.with_fingerprint)</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :         print_fingerprint (ctrl, NULL, pk, 1);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     700 </span>            :     }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :  leave:
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   free_public_key( pk );</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">     705 </span>            : }
<span class="lineNum">     706 </span>            : 
<a name="707"><span class="lineNum">     707 </span>            : </a>
<span class="lineNum">     708 </span>            : void
<span class="lineNum">     709 </span><span class="lineNoCov">          0 : release_pk_list (pk_list_t pk_list)</span>
<span class="lineNum">     710 </span>            : {
<span class="lineNum">     711 </span>            :   PK_LIST pk_rover;
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   for ( ; pk_list; pk_list = pk_rover)</span>
<span class="lineNum">     714 </span>            :     {
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :       pk_rover = pk_list-&gt;next;</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       free_public_key ( pk_list-&gt;pk );</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       xfree ( pk_list );</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     720 </span>            : 
<a name="721"><span class="lineNum">     721 </span>            : </a>
<span class="lineNum">     722 </span>            : static int
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : key_present_in_pk_list(PK_LIST pk_list, PKT_public_key *pk)</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :     for( ; pk_list; pk_list = pk_list-&gt;next)</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :         if (cmp_public_keys(pk_list-&gt;pk, pk) == 0)</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">     730 </span>            : }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : /****************
<span class="lineNum">     734 </span>            :  * Return a malloced string with a default recipient if there is any
<a name="735"><span class="lineNum">     735 </span>            :  */</a>
<span class="lineNum">     736 </span>            : static char *
<span class="lineNum">     737 </span><span class="lineNoCov">          0 : default_recipient(ctrl_t ctrl)</span>
<span class="lineNum">     738 </span>            : {
<span class="lineNum">     739 </span>            :     PKT_public_key *pk;
<span class="lineNum">     740 </span>            :     byte fpr[MAX_FINGERPRINT_LEN+1];
<span class="lineNum">     741 </span>            :     size_t n;
<span class="lineNum">     742 </span>            :     char *p;
<span class="lineNum">     743 </span>            :     int i;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     if( opt.def_recipient )</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :         return xstrdup( opt.def_recipient );</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     if( !opt.def_recipient_self )</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     pk = xmalloc_clear( sizeof *pk );</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     i = get_seckey_default (ctrl, pk);</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     if( i ) {</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         free_public_key( pk );</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     754 </span>            :     }
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :     n = MAX_FINGERPRINT_LEN;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     fingerprint_from_pk( pk, fpr, &amp;n );</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :     free_public_key( pk );</span>
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     p = xmalloc( 2*n+3 );</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     *p++ = '0';</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     *p++ = 'x';</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     for(i=0; i &lt; n; i++ )</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :         sprintf( p+2*i, &quot;%02X&quot;, fpr[i] );</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     p -= 2;</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     return p;</span>
<span class="lineNum">     765 </span>            : }
<a name="766"><span class="lineNum">     766 </span>            : </a>
<span class="lineNum">     767 </span>            : static int
<span class="lineNum">     768 </span><span class="lineNoCov">          0 : expand_id(const char *id,strlist_t *into,unsigned int flags)</span>
<span class="lineNum">     769 </span>            : {
<span class="lineNum">     770 </span>            :   struct groupitem *groups;
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   int count=0;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   for(groups=opt.grouplist;groups;groups=groups-&gt;next)</span>
<span class="lineNum">     774 </span>            :     {
<span class="lineNum">     775 </span>            :       /* need strcasecmp() here, as this should be localized */
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       if(strcasecmp(groups-&gt;name,id)==0)</span>
<span class="lineNum">     777 </span>            :         {
<span class="lineNum">     778 </span>            :           strlist_t each,sl;
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :           /* this maintains the current utf8-ness */
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :           for(each=groups-&gt;values;each;each=each-&gt;next)</span>
<span class="lineNum">     782 </span>            :             {
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :               sl=add_to_strlist(into,each-&gt;d);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :               sl-&gt;flags=flags;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :               count++;</span>
<span class="lineNum">     786 </span>            :             }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     789 </span>            :         }
<span class="lineNum">     790 </span>            :     }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   return count;</span>
<span class="lineNum">     793 </span>            : }
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            : /* For simplicity, and to avoid potential loops, we only expand once -
<a name="796"><span class="lineNum">     796 </span>            :  * you can't make an alias that points to an alias.  */</a>
<span class="lineNum">     797 </span>            : static strlist_t
<span class="lineNum">     798 </span><span class="lineNoCov">          0 : expand_group (strlist_t input)</span>
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   strlist_t output = NULL;</span>
<span class="lineNum">     801 </span>            :   strlist_t sl, rover;
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :   for (rover = input; rover; rover = rover-&gt;next)</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     if (!(rover-&gt;flags &amp; PK_LIST_FROM_FILE)</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         &amp;&amp; !expand_id(rover-&gt;d,&amp;output,rover-&gt;flags))</span>
<span class="lineNum">     806 </span>            :       {
<span class="lineNum">     807 </span>            :         /* Didn't find any groups, so use the existing string */
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         sl=add_to_strlist(&amp;output,rover-&gt;d);</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         sl-&gt;flags=rover-&gt;flags;</span>
<span class="lineNum">     810 </span>            :       }
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   return output;</span>
<span class="lineNum">     813 </span>            : }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            : /* Helper for build_pk_list to find and check one key.  This helper is
<span class="lineNum">     817 </span>            :  * also used directly in server mode by the RECIPIENTS command.  On
<span class="lineNum">     818 </span>            :  * success the new key is added to PK_LIST_ADDR.  NAME is the user id
<span class="lineNum">     819 </span>            :  * of the key.  USE the requested usage and a set MARK_HIDDEN will
<span class="lineNum">     820 </span>            :  * mark the key in the updated list as a hidden recipient.  If
<span class="lineNum">     821 </span>            :  * FROM_FILE is true, NAME is not a user ID but the name of a file
<a name="822"><span class="lineNum">     822 </span>            :  * holding a key. */</a>
<span class="lineNum">     823 </span>            : gpg_error_t
<span class="lineNum">     824 </span><span class="lineNoCov">          0 : find_and_check_key (ctrl_t ctrl, const char *name, unsigned int use,</span>
<span class="lineNum">     825 </span>            :                     int mark_hidden, int from_file, pk_list_t *pk_list_addr)
<span class="lineNum">     826 </span>            : {
<span class="lineNum">     827 </span>            :   int rc;
<span class="lineNum">     828 </span>            :   PKT_public_key *pk;
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   if (!name || !*name)</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_INV_USER_ID);</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   pk = xtrycalloc (1, sizeof *pk);</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   if (!pk)</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     return gpg_error_from_syserror ();</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   pk-&gt;req_usage = use;</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   if (from_file)</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     rc = get_pubkey_fromfile (ctrl, pk, name);</span>
<span class="lineNum">     840 </span>            :   else
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :     rc = get_best_pubkey_byname (ctrl, NULL, pk, name, NULL, 0, 0);</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">     843 </span>            :     {
<span class="lineNum">     844 </span>            :       int code;
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :       /* Key not found or other error. */
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :       log_error (_(&quot;%s: skipped: %s\n&quot;), name, gpg_strerror (rc) );</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :       switch (gpg_err_code (rc))</span>
<span class="lineNum">     849 </span>            :         {
<span class="lineNum">     850 </span>            :         case GPG_ERR_NO_SECKEY:
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :         case GPG_ERR_NO_PUBKEY:   code =  1; break;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :         case GPG_ERR_INV_USER_ID: code = 14; break;</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :         default: code = 0; break;</span>
<span class="lineNum">     854 </span>            :         }
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :       send_status_inv_recp (code, name);</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :       return rc;</span>
<span class="lineNum">     858 </span>            :     }
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   rc = openpgp_pk_test_algo2 (pk-&gt;pubkey_algo, use);</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">     862 </span>            :     {
<span class="lineNum">     863 </span>            :       /* Key found but not usable for us (e.g. sign-only key). */
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       send_status_inv_recp (3, name); /* Wrong key usage */</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :       log_error (_(&quot;%s: skipped: %s\n&quot;), name, gpg_strerror (rc) );</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       return rc;</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :   /* Key found and usable.  Check validity. */
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :   if (!from_file)</span>
<span class="lineNum">     872 </span>            :     {
<span class="lineNum">     873 </span>            :       int trustlevel;
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :       trustlevel = get_validity (ctrl, NULL, pk, pk-&gt;user_id, NULL, 1);</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       if ( (trustlevel &amp; TRUST_FLAG_DISABLED) )</span>
<span class="lineNum">     877 </span>            :         {
<span class="lineNum">     878 </span>            :           /* Key has been disabled. */
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :           send_status_inv_recp (13, name);</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :           log_info (_(&quot;%s: skipped: public key is disabled\n&quot;), name);</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :           free_public_key (pk);</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :           return GPG_ERR_UNUSABLE_PUBKEY;</span>
<span class="lineNum">     883 </span>            :         }
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       if ( !do_we_trust_pre (ctrl, pk, trustlevel) )</span>
<span class="lineNum">     886 </span>            :         {
<span class="lineNum">     887 </span>            :           /* We don't trust this key.  */
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           send_status_inv_recp (10, name);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :           free_public_key (pk);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :           return GPG_ERR_UNUSABLE_PUBKEY;</span>
<span class="lineNum">     891 </span>            :         }
<span class="lineNum">     892 </span>            :     }
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            :   /* Skip the actual key if the key is already present in the
<span class="lineNum">     895 </span>            :      list.  */
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :   if (!key_present_in_pk_list (*pk_list_addr, pk))</span>
<span class="lineNum">     897 </span>            :     {
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :       if (!opt.quiet)</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :         log_info (_(&quot;%s: skipped: public key already present\n&quot;), name);</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">     901 </span>            :     }
<span class="lineNum">     902 </span>            :   else
<span class="lineNum">     903 </span>            :     {
<span class="lineNum">     904 </span>            :       pk_list_t r;
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       r = xtrymalloc (sizeof *r);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       if (!r)</span>
<span class="lineNum">     908 </span>            :         {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :           rc = gpg_error_from_syserror ();</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :           free_public_key (pk);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :           return rc;</span>
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       r-&gt;pk = pk;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :       r-&gt;next = *pk_list_addr;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :       r-&gt;flags = mark_hidden? 1:0;</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :       *pk_list_addr = r;</span>
<span class="lineNum">     917 </span>            :     }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     920 </span>            : }
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            : /* This is the central function to collect the keys for recipients.
<span class="lineNum">     925 </span>            :  * It is thus used to prepare a public key encryption. encrypt-to
<span class="lineNum">     926 </span>            :  * keys, default keys and the keys for the actual recipients are all
<span class="lineNum">     927 </span>            :  * collected here.  When not in batch mode and no recipient has been
<span class="lineNum">     928 </span>            :  * passed on the commandline, the function will also ask for
<span class="lineNum">     929 </span>            :  * recipients.
<span class="lineNum">     930 </span>            :  *
<span class="lineNum">     931 </span>            :  * RCPTS is a string list with the recipients; NULL is an allowed
<span class="lineNum">     932 </span>            :  * value but not very useful.  Group expansion is done on these names;
<span class="lineNum">     933 </span>            :  * they may be in any of the user Id formats we can handle.  The flags
<span class="lineNum">     934 </span>            :  * bits for each string in the string list are used for:
<span class="lineNum">     935 </span>            :  *
<span class="lineNum">     936 </span>            :  * - PK_LIST_ENCRYPT_TO :: This is an encrypt-to recipient.
<span class="lineNum">     937 </span>            :  * - PK_LIST_HIDDEN     :: This is a hidden recipient.
<span class="lineNum">     938 </span>            :  * - PK_LIST_FROM_FILE  :: The argument is a file with a key.
<span class="lineNum">     939 </span>            :  *
<span class="lineNum">     940 </span>            :  * On success a list of keys is stored at the address RET_PK_LIST; the
<span class="lineNum">     941 </span>            :  * caller must free this list.  On error the value at this address is
<span class="lineNum">     942 </span>            :  * not changed.
<a name="943"><span class="lineNum">     943 </span>            :  */</a>
<span class="lineNum">     944 </span>            : int
<span class="lineNum">     945 </span><span class="lineNoCov">          0 : build_pk_list (ctrl_t ctrl, strlist_t rcpts, PK_LIST *ret_pk_list)</span>
<span class="lineNum">     946 </span>            : {
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   PK_LIST pk_list = NULL;</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   PKT_public_key *pk=NULL;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   int rc=0;</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   int any_recipients=0;</span>
<span class="lineNum">     951 </span>            :   strlist_t rov,remusr;
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   char *def_rec = NULL;</span>
<span class="lineNum">     953 </span>            :   char pkstrbuf[PUBKEY_STRING_SIZE];
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :   /* Try to expand groups if any have been defined. */
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   if (opt.grouplist)</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :     remusr = expand_group (rcpts);</span>
<span class="lineNum">     958 </span>            :   else
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     remusr = rcpts;</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :   /* XXX: Change this function to use get_pubkeys instead of
<span class="lineNum">     962 </span>            :      get_pubkey_byname to detect ambiguous key specifications and warn
<span class="lineNum">     963 </span>            :      about duplicate keyblocks.  For ambiguous key specifications on
<span class="lineNum">     964 </span>            :      the command line or provided interactively, prompt the user to
<span class="lineNum">     965 </span>            :      select the best key.  If a key specification is ambiguous and we
<span class="lineNum">     966 </span>            :      are in batch mode, die.  */
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   if (opt.encrypt_to_default_key)</span>
<span class="lineNum">     969 </span>            :     {
<span class="lineNum">     970 </span>            :       static int warned;
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :       const char *default_key = parse_def_secret_key (ctrl);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :       if (default_key)</span>
<span class="lineNum">     974 </span>            :         {
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :           PK_LIST r = xmalloc_clear (sizeof *r);</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :           r-&gt;pk = xmalloc_clear (sizeof *r-&gt;pk);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :           r-&gt;pk-&gt;req_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :           rc = get_pubkey_byname (ctrl, NULL, r-&gt;pk, default_key,</span>
<span class="lineNum">     981 </span>            :                                    NULL, NULL, 0, 1);
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :           if (rc)</span>
<span class="lineNum">     983 </span>            :             {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :               xfree (r-&gt;pk);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :               xfree (r);</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :               log_error (_(&quot;can't encrypt to '%s'\n&quot;), default_key);</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :               if (!opt.quiet)</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :                 log_info (_(&quot;(check argument of option '%s')\n&quot;),</span>
<span class="lineNum">     990 </span>            :                           &quot;--default-key&quot;);
<span class="lineNum">     991 </span>            :             }
<span class="lineNum">     992 </span>            :           else
<span class="lineNum">     993 </span>            :             {
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :               r-&gt;next = pk_list;</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :               r-&gt;flags = 0;</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :               pk_list = r;</span>
<span class="lineNum">     997 </span>            :             }
<span class="lineNum">     998 </span>            :         }
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       else if (opt.def_secret_key)</span>
<span class="lineNum">    1000 </span>            :         {
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :           if (! warned)</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :             log_info (_(&quot;option '%s' given, but no valid default keys given\n&quot;),</span>
<span class="lineNum">    1003 </span>            :                       &quot;--encrypt-to-default-key&quot;);
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :           warned = 1;</span>
<span class="lineNum">    1005 </span>            :         }
<span class="lineNum">    1006 </span>            :       else
<span class="lineNum">    1007 </span>            :         {
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :           if (! warned)</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :             log_info (_(&quot;option '%s' given, but option '%s' not given\n&quot;),</span>
<span class="lineNum">    1010 </span>            :                       &quot;--encrypt-to-default-key&quot;, &quot;--default-key&quot;);
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :           warned = 1;</span>
<span class="lineNum">    1012 </span>            :         }
<span class="lineNum">    1013 </span>            :     }
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            :   /* Check whether there are any recipients in the list and build the
<span class="lineNum">    1016 </span>            :    * list of the encrypt-to ones (we always trust them). */
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   for ( rov = remusr; rov; rov = rov-&gt;next )</span>
<span class="lineNum">    1018 </span>            :     {
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :       if ( !(rov-&gt;flags &amp; PK_LIST_ENCRYPT_TO) )</span>
<span class="lineNum">    1020 </span>            :         {
<span class="lineNum">    1021 </span>            :           /* This is a regular recipient; i.e. not an encrypt-to
<span class="lineNum">    1022 </span>            :              one. */
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :           any_recipients = 1;</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :           /* Hidden recipients are not allowed while in PGP mode,
<span class="lineNum">    1026 </span>            :              issue a warning and switch into GnuPG mode. */
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :           if ((rov-&gt;flags &amp; PK_LIST_HIDDEN) &amp;&amp; (PGP6 || PGP7 || PGP8))</span>
<span class="lineNum">    1028 </span>            :             {
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :               log_info(_(&quot;you may not use %s while in %s mode\n&quot;),</span>
<span class="lineNum">    1030 </span>            :                        &quot;--hidden-recipient&quot;,
<span class="lineNum">    1031 </span>            :                        compliance_option_string());
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :               compliance_failure();</span>
<span class="lineNum">    1034 </span>            :             }
<span class="lineNum">    1035 </span>            :         }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :       else if (!opt.no_encrypt_to)</span>
<span class="lineNum">    1037 </span>            :         {
<span class="lineNum">    1038 </span>            :           /* --encrypt-to has not been disabled.  Check this
<span class="lineNum">    1039 </span>            :              encrypt-to key. */
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :           pk = xmalloc_clear( sizeof *pk );</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :           pk-&gt;req_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :           /* We explicitly allow encrypt-to to an disabled key; thus
<span class="lineNum">    1044 </span>            :              we pass 1 for the second last argument and 1 as the last
<span class="lineNum">    1045 </span>            :              argument to disable AKL. */
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :           if ( (rc = get_pubkey_byname (ctrl,</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                                         NULL, pk, rov-&gt;d, NULL, NULL, 1, 1)) )</span>
<span class="lineNum">    1048 </span>            :             {
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :               free_public_key ( pk ); pk = NULL;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :               log_error (_(&quot;%s: skipped: %s\n&quot;), rov-&gt;d, gpg_strerror (rc) );</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :               send_status_inv_recp (0, rov-&gt;d);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :               goto fail;</span>
<span class="lineNum">    1053 </span>            :             }
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :           else if ( !(rc=openpgp_pk_test_algo2 (pk-&gt;pubkey_algo,</span>
<span class="lineNum">    1055 </span>            :                                                 PUBKEY_USAGE_ENC)) )
<span class="lineNum">    1056 </span>            :             {
<span class="lineNum">    1057 </span>            :               /* Skip the actual key if the key is already present
<span class="lineNum">    1058 </span>            :                * in the list.  Add it to our list if not. */
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :               if (key_present_in_pk_list(pk_list, pk) == 0)</span>
<span class="lineNum">    1060 </span>            :                 {
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                   free_public_key (pk); pk = NULL;</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :                   if (!opt.quiet)</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :                     log_info (_(&quot;%s: skipped: public key already present\n&quot;),</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                               rov-&gt;d);</span>
<span class="lineNum">    1065 </span>            :                 }
<span class="lineNum">    1066 </span>            :               else
<span class="lineNum">    1067 </span>            :                 {
<span class="lineNum">    1068 </span>            :                   PK_LIST r;
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                   r = xmalloc( sizeof *r );</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                   r-&gt;pk = pk; pk = NULL;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                   r-&gt;next = pk_list;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                   r-&gt;flags = (rov-&gt;flags&amp;PK_LIST_HIDDEN)?1:0;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                   pk_list = r;</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :                   /* Hidden encrypt-to recipients are not allowed while
<span class="lineNum">    1076 </span>            :                      in PGP mode, issue a warning and switch into
<span class="lineNum">    1077 </span>            :                      GnuPG mode. */
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :                   if ((r-&gt;flags&amp;PK_LIST_ENCRYPT_TO) &amp;&amp; (PGP6 || PGP7 || PGP8))</span>
<span class="lineNum">    1079 </span>            :                     {
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :                       log_info(_(&quot;you may not use %s while in %s mode\n&quot;),</span>
<span class="lineNum">    1081 </span>            :                                &quot;--hidden-encrypt-to&quot;,
<span class="lineNum">    1082 </span>            :                                compliance_option_string());
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                       compliance_failure();</span>
<span class="lineNum">    1085 </span>            :                     }
<span class="lineNum">    1086 </span>            :                 }
<span class="lineNum">    1087 </span>            :             }
<span class="lineNum">    1088 </span>            :           else
<span class="lineNum">    1089 </span>            :             {
<span class="lineNum">    1090 </span>            :               /* The public key is not usable for encryption. */
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :               free_public_key( pk ); pk = NULL;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :               log_error(_(&quot;%s: skipped: %s\n&quot;), rov-&gt;d, gpg_strerror (rc) );</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :               send_status_inv_recp (3, rov-&gt;d); /* Wrong key usage */</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :               goto fail;</span>
<span class="lineNum">    1095 </span>            :             }
<span class="lineNum">    1096 </span>            :         }
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :   /* If we don't have any recipients yet and we are not in batch mode
<span class="lineNum">    1100 </span>            :      drop into interactive selection mode. */
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   if ( !any_recipients &amp;&amp; !opt.batch )</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1103 </span>            :       int have_def_rec;
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :       char *answer = NULL;</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :       strlist_t backlog = NULL;</span>
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :       if (pk_list)</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :         any_recipients = 1;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :       def_rec = default_recipient(ctrl);</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :       have_def_rec = !!def_rec;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :       if ( !have_def_rec )</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;You did not specify a user ID. (you may use \&quot;-r\&quot;)\n&quot;));</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :       for (;;)
<span class="lineNum">    1115 </span>            :         {
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :           rc = 0;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :           xfree(answer);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           if ( have_def_rec )</span>
<span class="lineNum">    1119 </span>            :             {
<span class="lineNum">    1120 </span>            :               /* A default recipient is taken as the first entry. */
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :               answer = def_rec;</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :               def_rec = NULL;</span>
<span class="lineNum">    1123 </span>            :             }
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :           else if (backlog)</span>
<span class="lineNum">    1125 </span>            :             {
<span class="lineNum">    1126 </span>            :               /* This is part of our trick to expand and display groups. */
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :               answer = strlist_pop (&amp;backlog);</span>
<span class="lineNum">    1128 </span>            :             }
<span class="lineNum">    1129 </span>            :           else
<span class="lineNum">    1130 </span>            :             {
<span class="lineNum">    1131 </span>            :               /* Show the list of already collected recipients and ask
<span class="lineNum">    1132 </span>            :                  for more. */
<span class="lineNum">    1133 </span>            :               PK_LIST iter;
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :               tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :               tty_printf(_(&quot;Current recipients:\n&quot;));</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :               for (iter=pk_list;iter;iter=iter-&gt;next)</span>
<span class="lineNum">    1138 </span>            :                 {
<span class="lineNum">    1139 </span>            :                   u32 keyid[2];
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                   keyid_from_pk(iter-&gt;pk,keyid);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                   tty_printf (&quot;%s/%s %s \&quot;&quot;,</span>
<span class="lineNum">    1143 </span>            :                               pubkey_string (iter-&gt;pk,
<span class="lineNum">    1144 </span>            :                                              pkstrbuf, sizeof pkstrbuf),
<span class="lineNum">    1145 </span>            :                               keystr(keyid),
<span class="lineNum">    1146 </span>            :                               datestr_from_pk (iter-&gt;pk));
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                   if (iter-&gt;pk-&gt;user_id)</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :                     tty_print_utf8_string(iter-&gt;pk-&gt;user_id-&gt;name,</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :                                           iter-&gt;pk-&gt;user_id-&gt;len);</span>
<span class="lineNum">    1151 </span>            :                   else
<span class="lineNum">    1152 </span>            :                     {
<span class="lineNum">    1153 </span>            :                       size_t n;
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                       char *p = get_user_id (ctrl, keyid, &amp;n );</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                       tty_print_utf8_string ( p, n );</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                       xfree(p);</span>
<span class="lineNum">    1157 </span>            :                     }
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :                   tty_printf(&quot;\&quot;\n&quot;);</span>
<span class="lineNum">    1159 </span>            :                 }
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :               answer = cpr_get_utf8(&quot;pklist.user_id.enter&quot;,</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :                                     _(&quot;\nEnter the user ID.  &quot;</span>
<span class="lineNum">    1163 </span>            :                                       &quot;End with an empty line: &quot;));
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :               trim_spaces(answer);</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :               cpr_kill_prompt();</span>
<span class="lineNum">    1166 </span>            :             }
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :           if ( !answer || !*answer )</span>
<span class="lineNum">    1169 </span>            :             {
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :               xfree(answer);</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :               break;  /* No more recipients entered - get out of loop. */</span>
<span class="lineNum">    1172 </span>            :             }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :           /* Do group expand here too.  The trick here is to continue
<span class="lineNum">    1175 </span>            :              the loop if any expansion occurred.  The code above will
<span class="lineNum">    1176 </span>            :              then list all expanded keys. */
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :           if (expand_id(answer,&amp;backlog,0))</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :           /* Get and check key for the current name. */
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :           free_public_key (pk);</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :           pk = xmalloc_clear( sizeof *pk );</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :           pk-&gt;req_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :           rc = get_pubkey_byname (ctrl, NULL, pk, answer, NULL, NULL, 0, 0 );</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :           if (rc)</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;No such user ID.\n&quot;));</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :           else if ( !(rc=openpgp_pk_test_algo2 (pk-&gt;pubkey_algo,</span>
<span class="lineNum">    1188 </span>            :                                                 PUBKEY_USAGE_ENC)) )
<span class="lineNum">    1189 </span>            :             {
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :               if ( have_def_rec )</span>
<span class="lineNum">    1191 </span>            :                 {
<span class="lineNum">    1192 </span>            :                   /* No validation for a default recipient. */
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :                   if (!key_present_in_pk_list(pk_list, pk))</span>
<span class="lineNum">    1194 </span>            :                     {
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                       free_public_key (pk);</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :                       pk = NULL;</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :                       log_info (_(&quot;skipped: public key &quot;</span>
<span class="lineNum">    1198 </span>            :                                   &quot;already set as default recipient\n&quot;) );
<span class="lineNum">    1199 </span>            :                     }
<span class="lineNum">    1200 </span>            :                   else
<span class="lineNum">    1201 </span>            :                     {
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :                       PK_LIST r = xmalloc (sizeof *r);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                       r-&gt;pk = pk; pk = NULL;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                       r-&gt;next = pk_list;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :                       r-&gt;flags = 0; /* No throwing default ids. */</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                       pk_list = r;</span>
<span class="lineNum">    1207 </span>            :                     }
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :                   any_recipients = 1;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">    1210 </span>            :                 }
<span class="lineNum">    1211 </span>            :               else
<span class="lineNum">    1212 </span>            :                 { /* Check validity of this key. */
<span class="lineNum">    1213 </span>            :                   int trustlevel;
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                   trustlevel =</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                     get_validity (ctrl, NULL, pk, pk-&gt;user_id, NULL, 1);</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                   if ( (trustlevel &amp; TRUST_FLAG_DISABLED) )</span>
<span class="lineNum">    1218 </span>            :                     {
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                       tty_printf (_(&quot;Public key is disabled.\n&quot;) );</span>
<span class="lineNum">    1220 </span>            :                     }
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :                   else if ( do_we_trust_pre (ctrl, pk, trustlevel) )</span>
<span class="lineNum">    1222 </span>            :                     {
<span class="lineNum">    1223 </span>            :                       /* Skip the actual key if the key is already
<span class="lineNum">    1224 </span>            :                        * present in the list */
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :                       if (!key_present_in_pk_list(pk_list, pk))</span>
<span class="lineNum">    1226 </span>            :                         {
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :                           free_public_key (pk);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                           pk = NULL;</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :                           log_info(_(&quot;skipped: public key already set\n&quot;) );</span>
<span class="lineNum">    1230 </span>            :                         }
<span class="lineNum">    1231 </span>            :                       else
<span class="lineNum">    1232 </span>            :                         {
<span class="lineNum">    1233 </span>            :                           PK_LIST r;
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                           r = xmalloc( sizeof *r );</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                           r-&gt;pk = pk; pk = NULL;</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                           r-&gt;next = pk_list;</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :                           r-&gt;flags = 0; /* No throwing interactive ids. */</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                           pk_list = r;</span>
<span class="lineNum">    1239 </span>            :                         }
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                       any_recipients = 1;</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                       continue;</span>
<span class="lineNum">    1242 </span>            :                     }
<span class="lineNum">    1243 </span>            :                 }
<span class="lineNum">    1244 </span>            :             }
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :           xfree(def_rec); def_rec = NULL;</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :           have_def_rec = 0;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       if ( pk )</span>
<span class="lineNum">    1249 </span>            :         {
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :           free_public_key( pk );</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :           pk = NULL;</span>
<span class="lineNum">    1252 </span>            :         }
<span class="lineNum">    1253 </span>            :     }
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   else if ( !any_recipients &amp;&amp; (def_rec = default_recipient(ctrl)) )</span>
<span class="lineNum">    1255 </span>            :     {
<span class="lineNum">    1256 </span>            :       /* We are in batch mode and have only a default recipient. */
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :       pk = xmalloc_clear( sizeof *pk );</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :       pk-&gt;req_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :       /* The default recipient is allowed to be disabled; thus pass 1
<span class="lineNum">    1261 </span>            :          as second last argument.  We also don't want an AKL. */
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :       rc = get_pubkey_byname (ctrl, NULL, pk, def_rec, NULL, NULL, 1, 1);</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :       if (rc)</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         log_error(_(&quot;unknown default recipient \&quot;%s\&quot;\n&quot;), def_rec );</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :       else if ( !(rc=openpgp_pk_test_algo2(pk-&gt;pubkey_algo,</span>
<span class="lineNum">    1266 </span>            :                                            PUBKEY_USAGE_ENC)) )
<span class="lineNum">    1267 </span>            :         {
<span class="lineNum">    1268 </span>            :           /* Mark any_recipients here since the default recipient
<span class="lineNum">    1269 </span>            :              would have been used if it wasn't already there.  It
<span class="lineNum">    1270 </span>            :              doesn't really matter if we got this key from the default
<span class="lineNum">    1271 </span>            :              recipient or an encrypt-to. */
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :           any_recipients = 1;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :           if (!key_present_in_pk_list(pk_list, pk))</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :             log_info (_(&quot;skipped: public key already set &quot;</span>
<span class="lineNum">    1275 </span>            :                         &quot;as default recipient\n&quot;));
<span class="lineNum">    1276 </span>            :           else
<span class="lineNum">    1277 </span>            :             {
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :               PK_LIST r = xmalloc( sizeof *r );</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :               r-&gt;pk = pk; pk = NULL;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :               r-&gt;next = pk_list;</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :               r-&gt;flags = 0; /* No throwing default ids. */</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :               pk_list = r;</span>
<span class="lineNum">    1283 </span>            :             }
<span class="lineNum">    1284 </span>            :         }
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :       if ( pk )</span>
<span class="lineNum">    1286 </span>            :         {
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :           free_public_key( pk );</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :           pk = NULL;</span>
<span class="lineNum">    1289 </span>            :         }
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :       xfree(def_rec); def_rec = NULL;</span>
<span class="lineNum">    1291 </span>            :     }
<span class="lineNum">    1292 </span>            :   else
<span class="lineNum">    1293 </span>            :     {
<span class="lineNum">    1294 </span>            :       /* General case: Check all keys. */
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :       any_recipients = 0;</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :       for (; remusr; remusr = remusr-&gt;next )</span>
<span class="lineNum">    1297 </span>            :         {
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :           if ( (remusr-&gt;flags &amp; PK_LIST_ENCRYPT_TO) )</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :             continue; /* encrypt-to keys are already handled. */</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :           rc = find_and_check_key (ctrl, remusr-&gt;d, PUBKEY_USAGE_ENC,</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :                                    !!(remusr-&gt;flags&amp;PK_LIST_HIDDEN),</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :                                    !!(remusr-&gt;flags&amp;PK_LIST_FROM_FILE),</span>
<span class="lineNum">    1304 </span>            :                                    &amp;pk_list);
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :           if (rc)</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :             goto fail;</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :           any_recipients = 1;</span>
<span class="lineNum">    1308 </span>            :         }
<span class="lineNum">    1309 </span>            :     }
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :   if ( !rc &amp;&amp; !any_recipients )</span>
<span class="lineNum">    1312 </span>            :     {
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       log_error(_(&quot;no valid addressees\n&quot;));</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :       write_status_text (STATUS_NO_RECP, &quot;0&quot;);</span>
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :       rc = GPG_ERR_NO_USER_ID;</span>
<span class="lineNum">    1316 </span>            :     }
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            : #ifdef USE_TOFU
<span class="lineNum">    1319 </span>            :   if (! rc &amp;&amp; (opt.trust_model == TM_TOFU_PGP || opt.trust_model == TM_TOFU))
<span class="lineNum">    1320 </span>            :     {
<span class="lineNum">    1321 </span>            :       PK_LIST iter;
<span class="lineNum">    1322 </span>            :       for (iter = pk_list; iter; iter = iter-&gt;next)
<span class="lineNum">    1323 </span>            :         {
<span class="lineNum">    1324 </span>            :           int rc2;
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            :           /* Note: we already resolved any conflict when looking up
<span class="lineNum">    1327 </span>            :              the key.  Don't annoy the user again if she selected
<span class="lineNum">    1328 </span>            :              accept once.  */
<span class="lineNum">    1329 </span>            :           rc2 = tofu_register_encryption (ctrl, iter-&gt;pk, NULL, 0);
<span class="lineNum">    1330 </span>            :           if (rc2)
<span class="lineNum">    1331 </span>            :             log_info (&quot;WARNING: Failed to register encryption to %s&quot;
<span class="lineNum">    1332 </span>            :                       &quot; with TOFU engine\n&quot;,
<span class="lineNum">    1333 </span>            :                       keystr (pk_main_keyid (iter-&gt;pk)));
<span class="lineNum">    1334 </span>            :           else if (DBG_TRUST)
<span class="lineNum">    1335 </span>            :             log_debug (&quot;Registered encryption to %s with TOFU DB.\n&quot;,
<span class="lineNum">    1336 </span>            :                       keystr (pk_main_keyid (iter-&gt;pk)));
<span class="lineNum">    1337 </span>            :         }
<span class="lineNum">    1338 </span>            :     }
<span class="lineNum">    1339 </span>            : #endif /*USE_TOFU*/
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            :  fail:
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :   if ( rc )</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :     release_pk_list( pk_list );</span>
<span class="lineNum">    1345 </span>            :   else
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :     *ret_pk_list = pk_list;</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   if (opt.grouplist)</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     free_strlist(remusr);</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">    1350 </span>            : }
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            : /* In pgp6 mode, disallow all ciphers except IDEA (1), 3DES (2), and
<span class="lineNum">    1354 </span>            :    CAST5 (3), all hashes except MD5 (1), SHA1 (2), and RIPEMD160 (3),
<span class="lineNum">    1355 </span>            :    and all compressions except none (0) and ZIP (1).  pgp7 and pgp8
<span class="lineNum">    1356 </span>            :    mode expands the cipher list to include AES128 (7), AES192 (8),
<span class="lineNum">    1357 </span>            :    AES256 (9), and TWOFISH (10).  pgp8 adds the SHA-256 hash (8).  For
<span class="lineNum">    1358 </span>            :    a true PGP key all of this is unneeded as they are the only items
<span class="lineNum">    1359 </span>            :    present in the preferences subpacket, but checking here covers the
<span class="lineNum">    1360 </span>            :    weird case of encrypting to a key that had preferences from a
<span class="lineNum">    1361 </span>            :    different implementation which was then used with PGP.  I am not
<span class="lineNum">    1362 </span>            :    completely comfortable with this as the right thing to do, as it
<span class="lineNum">    1363 </span>            :    slightly alters the list of what the user is supposedly requesting.
<span class="lineNum">    1364 </span>            :    It is not against the RFC however, as the preference chosen will
<span class="lineNum">    1365 </span>            :    never be one that the user didn't specify somewhere (&quot;The
<span class="lineNum">    1366 </span>            :    implementation may use any mechanism to pick an algorithm in the
<span class="lineNum">    1367 </span>            :    intersection&quot;), and PGP has no mechanism to fix such a broken
<span class="lineNum">    1368 </span>            :    preference list, so I'm including it. -dms */
<a name="1369"><span class="lineNum">    1369 </span>            : </a>
<span class="lineNum">    1370 </span>            : int
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 : algo_available( preftype_t preftype, int algo, const union pref_hint *hint)</span>
<span class="lineNum">    1372 </span>            : {
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   if( preftype == PREFTYPE_SYM )</span>
<span class="lineNum">    1374 </span>            :     {
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :       if(PGP6 &amp;&amp; (algo != CIPHER_ALGO_IDEA</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_3DES</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_CAST5))</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :       if(PGP7 &amp;&amp; (algo != CIPHER_ALGO_IDEA</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_3DES</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_CAST5</span>
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_AES</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_AES192</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_AES256</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != CIPHER_ALGO_TWOFISH))</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :       /* PGP8 supports all the ciphers we do.. */
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :       return algo &amp;&amp; !openpgp_cipher_test_algo ( algo );</span>
<span class="lineNum">    1392 </span>            :     }
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   else if( preftype == PREFTYPE_HASH )</span>
<span class="lineNum">    1394 </span>            :     {
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :       if (hint &amp;&amp; hint-&gt;digest_length)</span>
<span class="lineNum">    1396 </span>            :         {
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :           if (hint-&gt;digest_length!=20 || opt.flags.dsa2)</span>
<span class="lineNum">    1398 </span>            :             {
<span class="lineNum">    1399 </span>            :               /* If --enable-dsa2 is set or the hash isn't 160 bits
<span class="lineNum">    1400 </span>            :                  (which implies DSA2), then we'll accept a hash that
<span class="lineNum">    1401 </span>            :                  is larger than we need.  Otherwise we won't accept
<span class="lineNum">    1402 </span>            :                  any hash that isn't exactly the right size. */
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :               if (hint-&gt;digest_length &gt; gcry_md_get_algo_dlen (algo))</span>
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1405 </span>            :             }
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :           else if (hint-&gt;digest_length != gcry_md_get_algo_dlen (algo))</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1408 </span>            :         }
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :       if((PGP6 || PGP7) &amp;&amp; (algo != DIGEST_ALGO_MD5</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                             &amp;&amp; algo != DIGEST_ALGO_SHA1</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                             &amp;&amp; algo != DIGEST_ALGO_RMD160))</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :       if(PGP8 &amp;&amp; (algo != DIGEST_ALGO_MD5</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != DIGEST_ALGO_SHA1</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != DIGEST_ALGO_RMD160</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                   &amp;&amp; algo != DIGEST_ALGO_SHA256))</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :       return algo &amp;&amp; !openpgp_md_test_algo (algo);</span>
<span class="lineNum">    1423 </span>            :     }
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :   else if( preftype == PREFTYPE_ZIP )</span>
<span class="lineNum">    1425 </span>            :     {
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       if((PGP6 || PGP7) &amp;&amp; (algo != COMPRESS_ALGO_NONE</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :                             &amp;&amp; algo != COMPRESS_ALGO_ZIP))</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :       /* PGP8 supports all the compression algos we do */
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :       return !check_compress_algo( algo );</span>
<span class="lineNum">    1433 </span>            :     }
<span class="lineNum">    1434 </span>            :   else
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1436 </span>            : }
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            : /****************
<span class="lineNum">    1439 </span>            :  * Return -1 if we could not find an algorithm.
<a name="1440"><span class="lineNum">    1440 </span>            :  */</a>
<span class="lineNum">    1441 </span>            : int
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 : select_algo_from_prefs(PK_LIST pk_list, int preftype,</span>
<span class="lineNum">    1443 </span>            :                        int request, const union pref_hint *hint)
<span class="lineNum">    1444 </span>            : {
<span class="lineNum">    1445 </span>            :   PK_LIST pkr;
<span class="lineNum">    1446 </span>            :   u32 bits[8];
<span class="lineNum">    1447 </span>            :   const prefitem_t *prefs;
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :   int result=-1,i;</span>
<span class="lineNum">    1449 </span>            :   u16 scores[256];
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   if( !pk_list )</span>
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :   memset(bits,0xFF,sizeof(bits));</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   memset(scores,0,sizeof(scores));</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   for( pkr = pk_list; pkr; pkr = pkr-&gt;next )</span>
<span class="lineNum">    1458 </span>            :     {
<span class="lineNum">    1459 </span>            :       u32 mask[8];
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :       int rank=1,implicit=-1;</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :       memset(mask,0,sizeof(mask));</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       switch(preftype)</span>
<span class="lineNum">    1465 </span>            :         {
<span class="lineNum">    1466 </span>            :         case PREFTYPE_SYM:
<span class="lineNum">    1467 </span>            :           /* IDEA is implicitly there for v3 keys with v3 selfsigs if
<span class="lineNum">    1468 </span>            :              --pgp2 mode is on.  This was a 2440 thing that was
<span class="lineNum">    1469 </span>            :              dropped from 4880 but is still relevant to GPG's 1991
<span class="lineNum">    1470 </span>            :              support.  All this doesn't mean IDEA is actually
<span class="lineNum">    1471 </span>            :              available, of course. */
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :           implicit=CIPHER_ALGO_3DES;</span>
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :         case PREFTYPE_HASH:
<span class="lineNum">    1477 </span>            :           /* While I am including this code for completeness, note
<span class="lineNum">    1478 </span>            :              that currently --pgp2 mode locks the hash at MD5, so this
<span class="lineNum">    1479 </span>            :              code will never even be called.  Even if the hash wasn't
<span class="lineNum">    1480 </span>            :              locked at MD5, we don't support sign+encrypt in --pgp2
<span class="lineNum">    1481 </span>            :              mode, and that's the only time PREFTYPE_HASH is used
<span class="lineNum">    1482 </span>            :              anyway. -dms */
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :           implicit=DIGEST_ALGO_SHA1;</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            :         case PREFTYPE_ZIP:
<span class="lineNum">    1489 </span>            :           /* Uncompressed is always an option. */
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :           implicit=COMPRESS_ALGO_NONE;</span>
<span class="lineNum">    1491 </span>            :         }
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :       if (pkr-&gt;pk-&gt;user_id) /* selected by user ID */</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :         prefs = pkr-&gt;pk-&gt;user_id-&gt;prefs;</span>
<span class="lineNum">    1495 </span>            :       else
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :         prefs = pkr-&gt;pk-&gt;prefs;</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :       if( prefs )</span>
<span class="lineNum">    1499 </span>            :         {
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :           for (i=0; prefs[i].type; i++ )</span>
<span class="lineNum">    1501 </span>            :             {
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :               if( prefs[i].type == preftype )</span>
<span class="lineNum">    1503 </span>            :                 {
<span class="lineNum">    1504 </span>            :                   /* Make sure all scores don't add up past 0xFFFF
<span class="lineNum">    1505 </span>            :                      (and roll around) */
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :                   if(rank+scores[prefs[i].value]&lt;=0xFFFF)</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :                     scores[prefs[i].value]+=rank;</span>
<span class="lineNum">    1508 </span>            :                   else
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :                     scores[prefs[i].value]=0xFFFF;</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :                   mask[prefs[i].value/32] |= 1&lt;&lt;(prefs[i].value%32);</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :                   rank++;</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :                   /* We saw the implicit algorithm, so we don't need
<span class="lineNum">    1516 </span>            :                      tack it on the end ourselves. */
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :                   if(implicit==prefs[i].value)</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :                     implicit=-1;</span>
<span class="lineNum">    1519 </span>            :                 }
<span class="lineNum">    1520 </span>            :             }
<span class="lineNum">    1521 </span>            :         }
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :       if(rank==1 &amp;&amp; preftype==PREFTYPE_ZIP)</span>
<span class="lineNum">    1524 </span>            :         {
<span class="lineNum">    1525 </span>            :           /* If the compression preferences are not present, they are
<span class="lineNum">    1526 </span>            :              assumed to be ZIP, Uncompressed (RFC4880:13.3.1) */
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :           scores[1]=1; /* ZIP is first choice */</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :           scores[0]=2; /* Uncompressed is second choice */</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :           mask[0]|=3;</span>
<span class="lineNum">    1530 </span>            :         }
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :       /* If the key didn't have the implicit algorithm listed
<span class="lineNum">    1533 </span>            :          explicitly, add it here at the tail of the list. */
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :       if(implicit&gt;-1)</span>
<span class="lineNum">    1535 </span>            :         {
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :           scores[implicit]+=rank;</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :           mask[implicit/32] |= 1&lt;&lt;(implicit%32);</span>
<span class="lineNum">    1538 </span>            :         }
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;8;i++)</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :         bits[i]&amp;=mask[i];</span>
<span class="lineNum">    1542 </span>            :     }
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            :   /* We've now scored all of the algorithms, and the usable ones have
<span class="lineNum">    1545 </span>            :      bits set.  Let's pick the winner. */
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            :   /* The caller passed us a request.  Can we use it? */
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   if(request&gt;-1 &amp;&amp; (bits[request/32] &amp; (1&lt;&lt;(request%32))) &amp;&amp;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :      algo_available(preftype,request,hint))</span>
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :     result=request;</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :   if(result==-1)</span>
<span class="lineNum">    1553 </span>            :     {
<span class="lineNum">    1554 </span>            :       /* If we have personal prefs set, use them. */
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :       prefs=NULL;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :       if(preftype==PREFTYPE_SYM &amp;&amp; opt.personal_cipher_prefs)</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         prefs=opt.personal_cipher_prefs;</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :       else if(preftype==PREFTYPE_HASH &amp;&amp; opt.personal_digest_prefs)</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         prefs=opt.personal_digest_prefs;</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :       else if(preftype==PREFTYPE_ZIP &amp;&amp; opt.personal_compress_prefs)</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :         prefs=opt.personal_compress_prefs;</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :       if( prefs )</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :         for(i=0; prefs[i].type; i++ )</span>
<span class="lineNum">    1565 </span>            :           {
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :             if(bits[prefs[i].value/32] &amp; (1&lt;&lt;(prefs[i].value%32))</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :                &amp;&amp; algo_available( preftype, prefs[i].value, hint))</span>
<span class="lineNum">    1568 </span>            :               {
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :                 result = prefs[i].value;</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1571 </span>            :               }
<span class="lineNum">    1572 </span>            :           }
<span class="lineNum">    1573 </span>            :     }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   if(result==-1)</span>
<span class="lineNum">    1576 </span>            :     {
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :       unsigned int best=-1;</span>
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span>            :       /* At this point, we have not selected an algorithm due to a
<span class="lineNum">    1580 </span>            :          special request or via personal prefs.  Pick the highest
<span class="lineNum">    1581 </span>            :          ranked algorithm (i.e. the one with the lowest score). */
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :       if(preftype==PREFTYPE_HASH &amp;&amp; scores[DIGEST_ALGO_MD5])</span>
<span class="lineNum">    1584 </span>            :         {
<span class="lineNum">    1585 </span>            :           /* &quot;If you are building an authentication system, the recipient
<span class="lineNum">    1586 </span>            :              may specify a preferred signing algorithm. However, the
<span class="lineNum">    1587 </span>            :              signer would be foolish to use a weak algorithm simply
<span class="lineNum">    1588 </span>            :              because the recipient requests it.&quot; (RFC4880:14).  If any
<span class="lineNum">    1589 </span>            :              other hash algorithm is available, pretend that MD5 isn't.
<span class="lineNum">    1590 </span>            :              Note that if the user intentionally chose MD5 by putting it
<span class="lineNum">    1591 </span>            :              in their personal prefs, then we do what the user said (as we
<span class="lineNum">    1592 </span>            :              never reach this code). */
<span class="lineNum">    1593 </span>            : 
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :           for(i=DIGEST_ALGO_MD5+1;i&lt;256;i++)</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :             if(scores[i])</span>
<span class="lineNum">    1596 </span>            :               {
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                 scores[DIGEST_ALGO_MD5]=0;</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1599 </span>            :               }
<span class="lineNum">    1600 </span>            :         }
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;256;i++)</span>
<span class="lineNum">    1603 </span>            :         {
<span class="lineNum">    1604 </span>            :           /* Note the '&lt;' here.  This means in case of a tie, we will
<span class="lineNum">    1605 </span>            :              favor the lower algorithm number.  We have a choice
<span class="lineNum">    1606 </span>            :              between the lower number (probably an older algorithm
<span class="lineNum">    1607 </span>            :              with more time in use), or the higher number (probably a
<span class="lineNum">    1608 </span>            :              newer algorithm with less time in use).  Older is
<span class="lineNum">    1609 </span>            :              probably safer here, even though the newer algorithms
<span class="lineNum">    1610 </span>            :              tend to be &quot;stronger&quot;. */
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :           if(scores[i] &amp;&amp; scores[i]&lt;best</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :              &amp;&amp; (bits[i/32] &amp; (1&lt;&lt;(i%32)))</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :              &amp;&amp; algo_available(preftype,i,hint))</span>
<span class="lineNum">    1614 </span>            :             {
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :               best=scores[i];</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :               result=i;</span>
<span class="lineNum">    1617 </span>            :             }
<span class="lineNum">    1618 </span>            :         }
<span class="lineNum">    1619 </span>            :     }
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1622 </span>            : }
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            : /*
<span class="lineNum">    1625 </span>            :  * Select the MDC flag from the pk_list.  We can only use MDC if all
<span class="lineNum">    1626 </span>            :  * recipients support this feature.
<a name="1627"><span class="lineNum">    1627 </span>            :  */</a>
<span class="lineNum">    1628 </span>            : int
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 : select_mdc_from_pklist (PK_LIST pk_list)</span>
<span class="lineNum">    1630 </span>            : {
<span class="lineNum">    1631 </span>            :   PK_LIST pkr;
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   if ( !pk_list )</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   for (pkr = pk_list; pkr; pkr = pkr-&gt;next)</span>
<span class="lineNum">    1637 </span>            :     {
<span class="lineNum">    1638 </span>            :       int mdc;
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :       if (pkr-&gt;pk-&gt;user_id) /* selected by user ID */</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :         mdc = pkr-&gt;pk-&gt;user_id-&gt;flags.mdc;</span>
<span class="lineNum">    1642 </span>            :       else
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         mdc = pkr-&gt;pk-&gt;flags.mdc;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :       if (!mdc)</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :         return 0;  /* At least one recipient does not support it. */</span>
<span class="lineNum">    1646 </span>            :     }
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   return 1; /* Can be used. */</span>
<span class="lineNum">    1648 </span>            : }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : 
<a name="1651"><span class="lineNum">    1651 </span>            : /* Print a warning for all keys in PK_LIST missing the MDC feature. */</a>
<span class="lineNum">    1652 </span>            : void
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 : warn_missing_mdc_from_pklist (PK_LIST pk_list)</span>
<span class="lineNum">    1654 </span>            : {
<span class="lineNum">    1655 </span>            :   PK_LIST pkr;
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :   for (pkr = pk_list; pkr; pkr = pkr-&gt;next)</span>
<span class="lineNum">    1658 </span>            :     {
<span class="lineNum">    1659 </span>            :       int mdc;
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :       if (pkr-&gt;pk-&gt;user_id) /* selected by user ID */</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :         mdc = pkr-&gt;pk-&gt;user_id-&gt;flags.mdc;</span>
<span class="lineNum">    1663 </span>            :       else
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :         mdc = pkr-&gt;pk-&gt;flags.mdc;</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       if (!mdc)</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :         log_info (_(&quot;Note: key %s has no %s feature\n&quot;),</span>
<span class="lineNum">    1667 </span>            :                   keystr_from_pk (pkr-&gt;pk), &quot;MDC&quot;);
<span class="lineNum">    1668 </span>            :     }
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 : }</span>
<a name="1670"><span class="lineNum">    1670 </span>            : </a>
<span class="lineNum">    1671 </span>            : void
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 : warn_missing_aes_from_pklist (PK_LIST pk_list)</span>
<span class="lineNum">    1673 </span>            : {
<span class="lineNum">    1674 </span>            :   PK_LIST pkr;
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :   for (pkr = pk_list; pkr; pkr = pkr-&gt;next)</span>
<span class="lineNum">    1677 </span>            :     {
<span class="lineNum">    1678 </span>            :       const prefitem_t *prefs;
<span class="lineNum">    1679 </span>            :       int i;
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :       int gotit = 0;</span>
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :       prefs = pkr-&gt;pk-&gt;user_id? pkr-&gt;pk-&gt;user_id-&gt;prefs : pkr-&gt;pk-&gt;prefs;</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :       if (prefs)</span>
<span class="lineNum">    1684 </span>            :         {
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :           for (i=0; !gotit &amp;&amp; prefs[i].type; i++ )</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :             if (prefs[i].type == PREFTYPE_SYM</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                 &amp;&amp; prefs[i].value == CIPHER_ALGO_AES)</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :               gotit++;</span>
<span class="lineNum">    1689 </span>            :         }
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :       if (!gotit)</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :         log_info (_(&quot;Note: key %s has no preference for %s\n&quot;),</span>
<span class="lineNum">    1692 </span>            :                   keystr_from_pk (pkr-&gt;pk), &quot;AES&quot;);
<span class="lineNum">    1693 </span>            :     }
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
