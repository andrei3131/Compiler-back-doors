<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - g10/keygen.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">g10</a> - keygen.c<span style="font-size: 80%;"> (source / <a href="keygen.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2535</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 15:09:19</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">76</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* keygen.c - Generate a key pair</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 1998-2007, 2009-2011  Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :  * Copyright (C) 2014, 2015, 2016  Werner Koch
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * This file is part of GnuPG.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  * GnuPG is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            :  * it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            :  * the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      10 </span>            :  * (at your option) any later version.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * GnuPG is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            :  * GNU General Public License for more details.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            :  * along with this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.
<span class="lineNum">      19 </span>            :  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      26 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      27 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      28 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      29 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &quot;gpg.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;../common/util.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;main.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;packet.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;../common/ttyio.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;options.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;keydb.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;trustdb.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;../common/status.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;../common/i18n.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;keyserver-internal.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;call-agent.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;pkglue.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;../common/shareddefs.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;../common/host2net.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;../common/mbox-util.h&quot;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* The default algorithms.  If you change them remember to change them
<span class="lineNum">      50 </span>            :    also in gpg.c:gpgconf_list.  You should also check that the value
<span class="lineNum">      51 </span>            :    is inside the bounds enforced by ask_keysize and gen_xxx.  See also
<span class="lineNum">      52 </span>            :    get_keysize_range which encodes the allowed ranges.  */
<span class="lineNum">      53 </span>            : #define DEFAULT_STD_KEY_PARAM  &quot;rsa2048/cert,sign+rsa2048/encr&quot;
<span class="lineNum">      54 </span>            : #define FUTURE_STD_KEY_PARAM   &quot;ed25519/cert,sign+cv25519/encr&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /* When generating keys using the streamlined key generation dialog,
<span class="lineNum">      57 </span>            :    use this as a default expiration interval.  */
<span class="lineNum">      58 </span>            : const char *default_expiration_interval = &quot;2y&quot;;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : /* Flag bits used during key generation.  */
<span class="lineNum">      61 </span>            : #define KEYGEN_FLAG_NO_PROTECTION 1
<span class="lineNum">      62 </span>            : #define KEYGEN_FLAG_TRANSIENT_KEY 2
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : /* Maximum number of supported algorithm preferences.  */
<span class="lineNum">      65 </span>            : #define MAX_PREFS 30
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : enum para_name {
<span class="lineNum">      68 </span>            :   pKEYTYPE,
<span class="lineNum">      69 </span>            :   pKEYLENGTH,
<span class="lineNum">      70 </span>            :   pKEYCURVE,
<span class="lineNum">      71 </span>            :   pKEYUSAGE,
<span class="lineNum">      72 </span>            :   pSUBKEYTYPE,
<span class="lineNum">      73 </span>            :   pSUBKEYLENGTH,
<span class="lineNum">      74 </span>            :   pSUBKEYCURVE,
<span class="lineNum">      75 </span>            :   pSUBKEYUSAGE,
<span class="lineNum">      76 </span>            :   pAUTHKEYTYPE,
<span class="lineNum">      77 </span>            :   pNAMEREAL,
<span class="lineNum">      78 </span>            :   pNAMEEMAIL,
<span class="lineNum">      79 </span>            :   pNAMECOMMENT,
<span class="lineNum">      80 </span>            :   pPREFERENCES,
<span class="lineNum">      81 </span>            :   pREVOKER,
<span class="lineNum">      82 </span>            :   pUSERID,
<span class="lineNum">      83 </span>            :   pCREATIONDATE,
<span class="lineNum">      84 </span>            :   pKEYCREATIONDATE, /* Same in seconds since epoch.  */
<span class="lineNum">      85 </span>            :   pEXPIREDATE,
<span class="lineNum">      86 </span>            :   pKEYEXPIRE, /* in n seconds */
<span class="lineNum">      87 </span>            :   pSUBKEYEXPIRE, /* in n seconds */
<span class="lineNum">      88 </span>            :   pPASSPHRASE,
<span class="lineNum">      89 </span>            :   pSERIALNO,
<span class="lineNum">      90 </span>            :   pCARDBACKUPKEY,
<span class="lineNum">      91 </span>            :   pHANDLE,
<span class="lineNum">      92 </span>            :   pKEYSERVER,
<span class="lineNum">      93 </span>            :   pKEYGRIP
<span class="lineNum">      94 </span>            : };
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : struct para_data_s {
<span class="lineNum">      97 </span>            :     struct para_data_s *next;
<span class="lineNum">      98 </span>            :     int lnr;
<span class="lineNum">      99 </span>            :     enum para_name key;
<span class="lineNum">     100 </span>            :     union {
<span class="lineNum">     101 </span>            :         u32 expire;
<span class="lineNum">     102 </span>            :         u32 creation;
<span class="lineNum">     103 </span>            :         unsigned int usage;
<span class="lineNum">     104 </span>            :         struct revocation_key revkey;
<span class="lineNum">     105 </span>            :         char value[1];
<span class="lineNum">     106 </span>            :     } u;
<span class="lineNum">     107 </span>            : };
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : struct output_control_s
<span class="lineNum">     110 </span>            : {
<span class="lineNum">     111 </span>            :   int lnr;
<span class="lineNum">     112 </span>            :   int dryrun;
<span class="lineNum">     113 </span>            :   unsigned int keygen_flags;
<span class="lineNum">     114 </span>            :   int use_files;
<span class="lineNum">     115 </span>            :   struct {
<span class="lineNum">     116 </span>            :     char  *fname;
<span class="lineNum">     117 </span>            :     char  *newfname;
<span class="lineNum">     118 </span>            :     IOBUF stream;
<span class="lineNum">     119 </span>            :     armor_filter_context_t *afx;
<span class="lineNum">     120 </span>            :   } pub;
<span class="lineNum">     121 </span>            : };
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : struct opaque_data_usage_and_pk {
<span class="lineNum">     125 </span>            :     unsigned int usage;
<span class="lineNum">     126 </span>            :     PKT_public_key *pk;
<span class="lineNum">     127 </span>            : };
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : static int prefs_initialized = 0;
<span class="lineNum">     131 </span>            : static byte sym_prefs[MAX_PREFS];
<span class="lineNum">     132 </span>            : static int nsym_prefs;
<span class="lineNum">     133 </span>            : static byte hash_prefs[MAX_PREFS];
<span class="lineNum">     134 </span>            : static int nhash_prefs;
<span class="lineNum">     135 </span>            : static byte zip_prefs[MAX_PREFS];
<span class="lineNum">     136 </span>            : static int nzip_prefs;
<span class="lineNum">     137 </span>            : static int mdc_available,ks_modify;
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : static gpg_error_t parse_algo_usage_expire (ctrl_t ctrl, int for_subkey,
<span class="lineNum">     140 </span>            :                                      const char *algostr, const char *usagestr,
<span class="lineNum">     141 </span>            :                                      const char *expirestr,
<span class="lineNum">     142 </span>            :                                      int *r_algo, unsigned int *r_usage,
<span class="lineNum">     143 </span>            :                                      u32 *r_expire,
<span class="lineNum">     144 </span>            :                                      unsigned int *r_nbits, char **r_curve);
<span class="lineNum">     145 </span>            : static void do_generate_keypair (ctrl_t ctrl, struct para_data_s *para,
<span class="lineNum">     146 </span>            :                                  struct output_control_s *outctrl, int card );
<span class="lineNum">     147 </span>            : static int write_keyblock (iobuf_t out, kbnode_t node);
<span class="lineNum">     148 </span>            : static gpg_error_t gen_card_key (int keyno, int algo, int is_primary,
<span class="lineNum">     149 </span>            :                                  kbnode_t pub_root, u32 *timestamp,
<span class="lineNum">     150 </span>            :                                  u32 expireval);
<span class="lineNum">     151 </span>            : static unsigned int get_keysize_range (int algo,
<span class="lineNum">     152 </span>            :                                        unsigned int *min, unsigned int *max);
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : 
<a name="156"><span class="lineNum">     156 </span>            : /* Return the algo string for a default new key.  */</a>
<span class="lineNum">     157 </span>            : const char *
<span class="lineNum">     158 </span><span class="lineNoCov">          0 : get_default_pubkey_algo (void)</span>
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   if (opt.def_new_key_algo)</span>
<span class="lineNum">     161 </span>            :     {
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       if (*opt.def_new_key_algo &amp;&amp; !strchr (opt.def_new_key_algo, ':'))</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :         return opt.def_new_key_algo;</span>
<span class="lineNum">     164 </span>            :       /* To avoid checking that option every time we delay that until
<span class="lineNum">     165 </span>            :        * here.  The only thing we really need to make sure is that
<span class="lineNum">     166 </span>            :        * there is no colon in the string so that the --gpgconf-list
<span class="lineNum">     167 </span>            :        * command won't mess up its output.  */
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       log_info (_(&quot;invalid value for option '%s'\n&quot;), &quot;--default-new-key-algo&quot;);</span>
<span class="lineNum">     169 </span>            :     }
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   return DEFAULT_STD_KEY_PARAM;</span>
<span class="lineNum">     171 </span>            : }
<span class="lineNum">     172 </span>            : 
<a name="173"><span class="lineNum">     173 </span>            : </a>
<span class="lineNum">     174 </span>            : static void
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : print_status_key_created (int letter, PKT_public_key *pk, const char *handle)</span>
<span class="lineNum">     176 </span>            : {
<span class="lineNum">     177 </span>            :   byte array[MAX_FINGERPRINT_LEN], *s;
<span class="lineNum">     178 </span>            :   char *buf, *p;
<span class="lineNum">     179 </span>            :   size_t i, n;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   if (!handle)</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :     handle = &quot;&quot;;</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :   buf = xmalloc (MAX_FINGERPRINT_LEN*2+31 + strlen (handle) + 1);</span>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   p = buf;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   if (letter || pk)</span>
<span class="lineNum">     188 </span>            :     {
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :       *p++ = letter;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       if (pk)</span>
<span class="lineNum">     191 </span>            :         {
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :           *p++ = ' ';</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :           fingerprint_from_pk (pk, array, &amp;n);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :           s = array;</span>
<span class="lineNum">     195 </span>            :           /* Fixme: Use bin2hex */
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :           for (i=0; i &lt; n ; i++, s++, p += 2)</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :             snprintf (p, 3, &quot;%02X&quot;, *s);</span>
<span class="lineNum">     198 </span>            :         }
<span class="lineNum">     199 </span>            :     }
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if (*handle)</span>
<span class="lineNum">     201 </span>            :     {
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :       *p++ = ' ';</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :       for (i=0; handle[i] &amp;&amp; i &lt; 100; i++)</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         *p++ = isspace ((unsigned int)handle[i])? '_':handle[i];</span>
<span class="lineNum">     205 </span>            :     }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   *p = 0;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   write_status_text ((letter || pk)?STATUS_KEY_CREATED:STATUS_KEY_NOT_CREATED,</span>
<span class="lineNum">     208 </span>            :                      buf);
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   xfree (buf);</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : }</span>
<a name="211"><span class="lineNum">     211 </span>            : </a>
<span class="lineNum">     212 </span>            : static void
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : print_status_key_not_created (const char *handle)</span>
<span class="lineNum">     214 </span>            : {
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   print_status_key_created (0, NULL, handle);</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : 
<a name="219"><span class="lineNum">     219 </span>            : </a>
<span class="lineNum">     220 </span>            : static void
<span class="lineNum">     221 </span><span class="lineNoCov">          0 : write_uid( KBNODE root, const char *s )</span>
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     PACKET *pkt = xmalloc_clear(sizeof *pkt );</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :     size_t n = strlen(s);</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :     pkt-&gt;pkttype = PKT_USER_ID;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     pkt-&gt;pkt.user_id = xmalloc_clear (sizeof *pkt-&gt;pkt.user_id + n);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     pkt-&gt;pkt.user_id-&gt;len = n;</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     pkt-&gt;pkt.user_id-&gt;ref = 1;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     strcpy(pkt-&gt;pkt.user_id-&gt;name, s);</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :     add_kbnode( root, new_kbnode( pkt ) );</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 : }</span>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<span class="lineNum">     234 </span>            : static void
<span class="lineNum">     235 </span><span class="lineNoCov">          0 : do_add_key_flags (PKT_signature *sig, unsigned int use)</span>
<span class="lineNum">     236 </span>            : {
<span class="lineNum">     237 </span>            :     byte buf[1];
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :     buf[0] = 0;</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :     /* The spec says that all primary keys MUST be able to certify. */
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :     if(sig-&gt;sig_class!=0x18)</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :       buf[0] |= 0x01;</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     if (use &amp; PUBKEY_USAGE_SIG)</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :       buf[0] |= 0x02;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :     if (use &amp; PUBKEY_USAGE_ENC)</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         buf[0] |= 0x04 | 0x08;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     if (use &amp; PUBKEY_USAGE_AUTH)</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         buf[0] |= 0x20;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     build_sig_subpkt (sig, SIGSUBPKT_KEY_FLAGS, buf, 1);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     254 </span>            : 
<a name="255"><span class="lineNum">     255 </span>            : </a>
<span class="lineNum">     256 </span>            : int
<span class="lineNum">     257 </span><span class="lineNoCov">          0 : keygen_add_key_expire (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   PKT_public_key *pk = opaque;</span>
<span class="lineNum">     260 </span>            :   byte buf[8];
<span class="lineNum">     261 </span>            :   u32  u;
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   if (pk-&gt;expiredate)</span>
<span class="lineNum">     264 </span>            :     {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :       if (pk-&gt;expiredate &gt; pk-&gt;timestamp)</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         u = pk-&gt;expiredate - pk-&gt;timestamp;</span>
<span class="lineNum">     267 </span>            :       else
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         u = 1;</span>
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       buf[0] = (u &gt;&gt; 24) &amp; 0xff;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :       buf[1] = (u &gt;&gt; 16) &amp; 0xff;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :       buf[2] = (u &gt;&gt;  8) &amp; 0xff;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       buf[3] = u &amp; 0xff;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       build_sig_subpkt (sig, SIGSUBPKT_KEY_EXPIRE, buf, 4);</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span>            :   else
<span class="lineNum">     277 </span>            :     {
<span class="lineNum">     278 </span>            :       /* Make sure we don't leave a key expiration subpacket lying
<span class="lineNum">     279 </span>            :          around */
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_KEY_EXPIRE);</span>
<span class="lineNum">     281 </span>            :     }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     284 </span>            : }
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : /* Add the key usage (i.e. key flags) in SIG from the public keys
<a name="288"><span class="lineNum">     288 </span>            :  * pubkey_usage field.  OPAQUE has the public key.  */</a>
<span class="lineNum">     289 </span>            : int
<span class="lineNum">     290 </span><span class="lineNoCov">          0 : keygen_add_key_flags (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     291 </span>            : {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :   PKT_public_key *pk = opaque;</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   do_add_key_flags (sig, pk-&gt;pubkey_usage);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     296 </span>            : }
<span class="lineNum">     297 </span>            : 
<a name="298"><span class="lineNum">     298 </span>            : </a>
<span class="lineNum">     299 </span>            : static int
<span class="lineNum">     300 </span><span class="lineNoCov">          0 : keygen_add_key_flags_and_expire (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     301 </span>            : {
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   struct opaque_data_usage_and_pk *oduap = opaque;</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   do_add_key_flags (sig, oduap-&gt;usage);</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :   return keygen_add_key_expire (sig, oduap-&gt;pk);</span>
<span class="lineNum">     306 </span>            : }
<span class="lineNum">     307 </span>            : 
<a name="308"><span class="lineNum">     308 </span>            : </a>
<span class="lineNum">     309 </span>            : static int
<span class="lineNum">     310 </span><span class="lineNoCov">          0 : set_one_pref (int val, int type, const char *item, byte *buf, int *nbuf)</span>
<span class="lineNum">     311 </span>            : {
<span class="lineNum">     312 </span>            :     int i;
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     for (i=0; i &lt; *nbuf; i++ )</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       if (buf[i] == val)</span>
<span class="lineNum">     316 </span>            :         {
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :           log_info (_(&quot;preference '%s' duplicated\n&quot;), item);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">     319 </span>            :         }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     if (*nbuf &gt;= MAX_PREFS)</span>
<span class="lineNum">     322 </span>            :       {
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         if(type==1)</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :           log_info(_(&quot;too many cipher preferences\n&quot;));</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         else if(type==2)</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :           log_info(_(&quot;too many digest preferences\n&quot;));</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         else if(type==3)</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :           log_info(_(&quot;too many compression preferences\n&quot;));</span>
<span class="lineNum">     329 </span>            :         else
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :           BUG();</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     333 </span>            :       }
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     buf[(*nbuf)++] = val;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     337 </span>            : }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : /*
<span class="lineNum">     340 </span>            :  * Parse the supplied string and use it to set the standard
<span class="lineNum">     341 </span>            :  * preferences.  The string may be in a form like the one printed by
<span class="lineNum">     342 </span>            :  * &quot;pref&quot; (something like: &quot;S10 S3 H3 H2 Z2 Z1&quot;) or the actual
<span class="lineNum">     343 </span>            :  * cipher/hash/compress names.  Use NULL to set the default
<span class="lineNum">     344 </span>            :  * preferences.  Returns: 0 = okay
<a name="345"><span class="lineNum">     345 </span>            :  */</a>
<span class="lineNum">     346 </span>            : int
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : keygen_set_std_prefs (const char *string,int personal)</span>
<span class="lineNum">     348 </span>            : {
<span class="lineNum">     349 </span>            :     byte sym[MAX_PREFS], hash[MAX_PREFS], zip[MAX_PREFS];
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :     int nsym=0, nhash=0, nzip=0, val, rc=0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     int mdc=1, modify=0; /* mdc defaults on, modify defaults off. */</span>
<span class="lineNum">     352 </span>            :     char dummy_string[20*4+1]; /* Enough for 20 items. */
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     if (!string || !ascii_strcasecmp (string, &quot;default&quot;))</span>
<span class="lineNum">     355 </span>            :       {
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         if (opt.def_preference_list)</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :           string=opt.def_preference_list;</span>
<span class="lineNum">     358 </span>            :         else
<span class="lineNum">     359 </span>            :           {
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :             int any_compress = 0;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             dummy_string[0]='\0';</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :             /* The rationale why we use the order AES256,192,128 is
<span class="lineNum">     364 </span>            :                for compatibility reasons with PGP.  If gpg would
<span class="lineNum">     365 </span>            :                define AES128 first, we would get the somewhat
<span class="lineNum">     366 </span>            :                confusing situation:
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :                  gpg -r pgpkey -r gpgkey  ---gives--&gt; AES256
<span class="lineNum">     369 </span>            :                  gpg -r gpgkey -r pgpkey  ---gives--&gt; AES
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :                Note that by using --personal-cipher-preferences it is
<span class="lineNum">     372 </span>            :                possible to prefer AES128.
<span class="lineNum">     373 </span>            :             */
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :             /* Make sure we do not add more than 15 items here, as we
<span class="lineNum">     376 </span>            :                could overflow the size of dummy_string.  We currently
<span class="lineNum">     377 </span>            :                have at most 12. */
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             if ( !openpgp_cipher_test_algo (CIPHER_ALGO_AES256) )</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :               strcat(dummy_string,&quot;S9 &quot;);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             if ( !openpgp_cipher_test_algo (CIPHER_ALGO_AES192) )</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :               strcat(dummy_string,&quot;S8 &quot;);</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             if ( !openpgp_cipher_test_algo (CIPHER_ALGO_AES) )</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :               strcat(dummy_string,&quot;S7 &quot;);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             strcat(dummy_string,&quot;S2 &quot;); /* 3DES */</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :             /* The default hash algo order is:
<span class="lineNum">     387 </span>            :                  SHA-256, SHA-384, SHA-512, SHA-224, SHA-1.
<span class="lineNum">     388 </span>            :              */
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             if (!openpgp_md_test_algo (DIGEST_ALGO_SHA256))</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :               strcat (dummy_string, &quot;H8 &quot;);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :             if (!openpgp_md_test_algo (DIGEST_ALGO_SHA384))</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :               strcat (dummy_string, &quot;H9 &quot;);</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :             if (!openpgp_md_test_algo (DIGEST_ALGO_SHA512))</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :               strcat (dummy_string, &quot;H10 &quot;);</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :             if (!openpgp_md_test_algo (DIGEST_ALGO_SHA224))</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :               strcat (dummy_string, &quot;H11 &quot;);</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :             strcat (dummy_string, &quot;H2 &quot;); /* SHA-1 */</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             if(!check_compress_algo(COMPRESS_ALGO_ZLIB))</span>
<span class="lineNum">     404 </span>            :               {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                 strcat(dummy_string,&quot;Z2 &quot;);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                 any_compress = 1;</span>
<span class="lineNum">     407 </span>            :               }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :             if(!check_compress_algo(COMPRESS_ALGO_BZIP2))</span>
<span class="lineNum">     410 </span>            :               {
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                 strcat(dummy_string,&quot;Z3 &quot;);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :                 any_compress = 1;</span>
<span class="lineNum">     413 </span>            :               }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :             if(!check_compress_algo(COMPRESS_ALGO_ZIP))</span>
<span class="lineNum">     416 </span>            :               {
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                 strcat(dummy_string,&quot;Z1 &quot;);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 any_compress = 1;</span>
<span class="lineNum">     419 </span>            :               }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :             /* In case we have no compress algo at all, declare that
<span class="lineNum">     422 </span>            :                we prefer no compresssion.  */
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :             if (!any_compress)</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :               strcat(dummy_string,&quot;Z0 &quot;);</span>
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            :             /* Remove the trailing space.  */
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :             if (*dummy_string &amp;&amp; dummy_string[strlen (dummy_string)-1] == ' ')</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :               dummy_string[strlen (dummy_string)-1] = 0;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :             string=dummy_string;</span>
<span class="lineNum">     431 </span>            :           }
<span class="lineNum">     432 </span>            :       }
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     else if (!ascii_strcasecmp (string, &quot;none&quot;))</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         string = &quot;&quot;;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     if(strlen(string))</span>
<span class="lineNum">     437 </span>            :       {
<span class="lineNum">     438 </span>            :         char *prefstringbuf;
<span class="lineNum">     439 </span>            :         char *tok, *prefstring;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :         /* We need a writable string. */
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :         prefstring = prefstringbuf = xstrdup (string);</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :         while((tok=strsep(&amp;prefstring,&quot; ,&quot;)))</span>
<span class="lineNum">     445 </span>            :           {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :             if((val=string_to_cipher_algo (tok)))</span>
<span class="lineNum">     447 </span>            :               {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                 if(set_one_pref(val,1,tok,sym,&amp;nsym))</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :                   rc=-1;</span>
<span class="lineNum">     450 </span>            :               }
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :             else if((val=string_to_digest_algo (tok)))</span>
<span class="lineNum">     452 </span>            :               {
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 if(set_one_pref(val,2,tok,hash,&amp;nhash))</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :                   rc=-1;</span>
<span class="lineNum">     455 </span>            :               }
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :             else if((val=string_to_compress_algo(tok))&gt;-1)</span>
<span class="lineNum">     457 </span>            :               {
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                 if(set_one_pref(val,3,tok,zip,&amp;nzip))</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                   rc=-1;</span>
<span class="lineNum">     460 </span>            :               }
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :             else if (ascii_strcasecmp(tok,&quot;mdc&quot;)==0)</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :               mdc=1;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             else if (ascii_strcasecmp(tok,&quot;no-mdc&quot;)==0)</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :               mdc=0;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             else if (ascii_strcasecmp(tok,&quot;ks-modify&quot;)==0)</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :               modify=1;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :             else if (ascii_strcasecmp(tok,&quot;no-ks-modify&quot;)==0)</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :               modify=0;</span>
<span class="lineNum">     469 </span>            :             else
<span class="lineNum">     470 </span>            :               {
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                 log_info (_(&quot;invalid item '%s' in preference string\n&quot;),tok);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 rc=-1;</span>
<span class="lineNum">     473 </span>            :               }
<span class="lineNum">     474 </span>            :           }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         xfree (prefstringbuf);</span>
<span class="lineNum">     477 </span>            :       }
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     if(!rc)</span>
<span class="lineNum">     480 </span>            :       {
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         if(personal)</span>
<span class="lineNum">     482 </span>            :           {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :             if(personal==PREFTYPE_SYM)</span>
<span class="lineNum">     484 </span>            :               {
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                 xfree(opt.personal_cipher_prefs);</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 if(nsym==0)</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                   opt.personal_cipher_prefs=NULL;</span>
<span class="lineNum">     489 </span>            :                 else
<span class="lineNum">     490 </span>            :                   {
<span class="lineNum">     491 </span>            :                     int i;
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                     opt.personal_cipher_prefs=</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :                       xmalloc(sizeof(prefitem_t *)*(nsym+1));</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                     for (i=0; i&lt;nsym; i++)</span>
<span class="lineNum">     497 </span>            :                       {
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :                         opt.personal_cipher_prefs[i].type = PREFTYPE_SYM;</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                         opt.personal_cipher_prefs[i].value = sym[i];</span>
<span class="lineNum">     500 </span>            :                       }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                     opt.personal_cipher_prefs[i].type = PREFTYPE_NONE;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :                     opt.personal_cipher_prefs[i].value = 0;</span>
<span class="lineNum">     504 </span>            :                   }
<span class="lineNum">     505 </span>            :               }
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             else if(personal==PREFTYPE_HASH)</span>
<span class="lineNum">     507 </span>            :               {
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                 xfree(opt.personal_digest_prefs);</span>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                 if(nhash==0)</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :                   opt.personal_digest_prefs=NULL;</span>
<span class="lineNum">     512 </span>            :                 else
<span class="lineNum">     513 </span>            :                   {
<span class="lineNum">     514 </span>            :                     int i;
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :                     opt.personal_digest_prefs=</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                       xmalloc(sizeof(prefitem_t *)*(nhash+1));</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                     for (i=0; i&lt;nhash; i++)</span>
<span class="lineNum">     520 </span>            :                       {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                         opt.personal_digest_prefs[i].type = PREFTYPE_HASH;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :                         opt.personal_digest_prefs[i].value = hash[i];</span>
<span class="lineNum">     523 </span>            :                       }
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                     opt.personal_digest_prefs[i].type = PREFTYPE_NONE;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                     opt.personal_digest_prefs[i].value = 0;</span>
<span class="lineNum">     527 </span>            :                   }
<span class="lineNum">     528 </span>            :               }
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :             else if(personal==PREFTYPE_ZIP)</span>
<span class="lineNum">     530 </span>            :               {
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :                 xfree(opt.personal_compress_prefs);</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :                 if(nzip==0)</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :                   opt.personal_compress_prefs=NULL;</span>
<span class="lineNum">     535 </span>            :                 else
<span class="lineNum">     536 </span>            :                   {
<span class="lineNum">     537 </span>            :                     int i;
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :                     opt.personal_compress_prefs=</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                       xmalloc(sizeof(prefitem_t *)*(nzip+1));</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                     for (i=0; i&lt;nzip; i++)</span>
<span class="lineNum">     543 </span>            :                       {
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :                         opt.personal_compress_prefs[i].type = PREFTYPE_ZIP;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                         opt.personal_compress_prefs[i].value = zip[i];</span>
<span class="lineNum">     546 </span>            :                       }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :                     opt.personal_compress_prefs[i].type = PREFTYPE_NONE;</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                     opt.personal_compress_prefs[i].value = 0;</span>
<span class="lineNum">     550 </span>            :                   }
<span class="lineNum">     551 </span>            :               }
<span class="lineNum">     552 </span>            :           }
<span class="lineNum">     553 </span>            :         else
<span class="lineNum">     554 </span>            :           {
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :             memcpy (sym_prefs,  sym,  (nsym_prefs=nsym));</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :             memcpy (hash_prefs, hash, (nhash_prefs=nhash));</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :             memcpy (zip_prefs,  zip,  (nzip_prefs=nzip));</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :             mdc_available = mdc;</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :             ks_modify = modify;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :             prefs_initialized = 1;</span>
<span class="lineNum">     561 </span>            :           }
<span class="lineNum">     562 </span>            :       }
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     565 </span>            : }
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            : /* Return a fake user ID containing the preferences.  Caller must
<a name="568"><span class="lineNum">     568 </span>            :    free. */</a>
<span class="lineNum">     569 </span>            : PKT_user_id *
<span class="lineNum">     570 </span><span class="lineNoCov">          0 : keygen_get_std_prefs(void)</span>
<span class="lineNum">     571 </span>            : {
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   int i,j=0;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :   PKT_user_id *uid=xmalloc_clear(sizeof(PKT_user_id));</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   if(!prefs_initialized)</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :     keygen_set_std_prefs(NULL,0);</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :   uid-&gt;ref=1;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :   uid-&gt;prefs=xmalloc((sizeof(prefitem_t *)*</span>
<span class="lineNum">     581 </span>            :                       (nsym_prefs+nhash_prefs+nzip_prefs+1)));
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;nsym_prefs;i++,j++)</span>
<span class="lineNum">     584 </span>            :     {
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].type=PREFTYPE_SYM;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].value=sym_prefs[i];</span>
<span class="lineNum">     587 </span>            :     }
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;nhash_prefs;i++,j++)</span>
<span class="lineNum">     590 </span>            :     {
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].type=PREFTYPE_HASH;</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].value=hash_prefs[i];</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;nzip_prefs;i++,j++)</span>
<span class="lineNum">     596 </span>            :     {
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].type=PREFTYPE_ZIP;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :       uid-&gt;prefs[j].value=zip_prefs[i];</span>
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :   uid-&gt;prefs[j].type=PREFTYPE_NONE;</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   uid-&gt;prefs[j].value=0;</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :   uid-&gt;flags.mdc=mdc_available;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :   uid-&gt;flags.ks_modify=ks_modify;</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   return uid;</span>
<span class="lineNum">     608 </span>            : }
<a name="609"><span class="lineNum">     609 </span>            : </a>
<span class="lineNum">     610 </span>            : static void
<span class="lineNum">     611 </span><span class="lineNoCov">          0 : add_feature_mdc (PKT_signature *sig,int enabled)</span>
<span class="lineNum">     612 </span>            : {
<span class="lineNum">     613 </span>            :     const byte *s;
<span class="lineNum">     614 </span>            :     size_t n;
<span class="lineNum">     615 </span>            :     int i;
<span class="lineNum">     616 </span>            :     char *buf;
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     s = parse_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_FEATURES, &amp;n );</span>
<span class="lineNum">     619 </span>            :     /* Already set or cleared */
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     if (s &amp;&amp; n &amp;&amp;</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :         ((enabled &amp;&amp; (s[0] &amp; 0x01)) || (!enabled &amp;&amp; !(s[0] &amp; 0x01))))</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     if (!s || !n) { /* create a new one */</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :         n = 1;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         buf = xmalloc_clear (n);</span>
<span class="lineNum">     627 </span>            :     }
<span class="lineNum">     628 </span>            :     else {
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         buf = xmalloc (n);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         memcpy (buf, s, n);</span>
<span class="lineNum">     631 </span>            :     }
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     if(enabled)</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :       buf[0] |= 0x01; /* MDC feature */</span>
<span class="lineNum">     635 </span>            :     else
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       buf[0] &amp;= ~0x01;</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :     /* Are there any bits set? */
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :     for(i=0;i&lt;n;i++)</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       if(buf[i]!=0)</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     if(i==n)</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_FEATURES);</span>
<span class="lineNum">     645 </span>            :     else
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :       build_sig_subpkt (sig, SIGSUBPKT_FEATURES, buf, n);</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :     xfree (buf);</span>
<span class="lineNum">     649 </span>            : }
<a name="650"><span class="lineNum">     650 </span>            : </a>
<span class="lineNum">     651 </span>            : static void
<span class="lineNum">     652 </span><span class="lineNoCov">          0 : add_keyserver_modify (PKT_signature *sig,int enabled)</span>
<span class="lineNum">     653 </span>            : {
<span class="lineNum">     654 </span>            :   const byte *s;
<span class="lineNum">     655 </span>            :   size_t n;
<span class="lineNum">     656 </span>            :   int i;
<span class="lineNum">     657 </span>            :   char *buf;
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   /* The keyserver modify flag is a negative flag (i.e. no-modify) */
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   enabled=!enabled;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   s = parse_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_KS_FLAGS, &amp;n );</span>
<span class="lineNum">     663 </span>            :   /* Already set or cleared */
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   if (s &amp;&amp; n &amp;&amp;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       ((enabled &amp;&amp; (s[0] &amp; 0x80)) || (!enabled &amp;&amp; !(s[0] &amp; 0x80))))</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :   if (!s || !n) { /* create a new one */</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :     n = 1;</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :     buf = xmalloc_clear (n);</span>
<span class="lineNum">     671 </span>            :   }
<span class="lineNum">     672 </span>            :   else {
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     buf = xmalloc (n);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     memcpy (buf, s, n);</span>
<span class="lineNum">     675 </span>            :   }
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :   if(enabled)</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     buf[0] |= 0x80; /* no-modify flag */</span>
<span class="lineNum">     679 </span>            :   else
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     buf[0] &amp;= ~0x80;</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :   /* Are there any bits set? */
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;n;i++)</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     if(buf[i]!=0)</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   if(i==n)</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_KS_FLAGS);</span>
<span class="lineNum">     689 </span>            :   else
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     build_sig_subpkt (sig, SIGSUBPKT_KS_FLAGS, buf, n);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   xfree (buf);</span>
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : 
<a name="695"><span class="lineNum">     695 </span>            : </a>
<span class="lineNum">     696 </span>            : int
<span class="lineNum">     697 </span><span class="lineNoCov">          0 : keygen_upd_std_prefs (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     698 </span>            : {
<span class="lineNum">     699 </span>            :   (void)opaque;
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :   if (!prefs_initialized)</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     keygen_set_std_prefs (NULL, 0);</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :   if (nsym_prefs)</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     build_sig_subpkt (sig, SIGSUBPKT_PREF_SYM, sym_prefs, nsym_prefs);</span>
<span class="lineNum">     706 </span>            :   else
<span class="lineNum">     707 </span>            :     {
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_PREF_SYM);</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;unhashed, SIGSUBPKT_PREF_SYM);</span>
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   if (nhash_prefs)</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     build_sig_subpkt (sig, SIGSUBPKT_PREF_HASH, hash_prefs, nhash_prefs);</span>
<span class="lineNum">     714 </span>            :   else
<span class="lineNum">     715 </span>            :     {
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_PREF_HASH);</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;unhashed, SIGSUBPKT_PREF_HASH);</span>
<span class="lineNum">     718 </span>            :     }
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :   if (nzip_prefs)</span>
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :     build_sig_subpkt (sig, SIGSUBPKT_PREF_COMPR, zip_prefs, nzip_prefs);</span>
<span class="lineNum">     722 </span>            :   else
<span class="lineNum">     723 </span>            :     {
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;hashed, SIGSUBPKT_PREF_COMPR);</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       delete_sig_subpkt (sig-&gt;unhashed, SIGSUBPKT_PREF_COMPR);</span>
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   /* Make sure that the MDC feature flag is set if needed.  */
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :   add_feature_mdc (sig,mdc_available);</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :   add_keyserver_modify (sig,ks_modify);</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :   keygen_add_keyserver_url(sig,NULL);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     734 </span>            : }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            : /****************
<span class="lineNum">     738 </span>            :  * Add preference to the self signature packet.
<span class="lineNum">     739 </span>            :  * This is only called for packets with version &gt; 3.
<a name="740"><span class="lineNum">     740 </span>            :  */</a>
<span class="lineNum">     741 </span>            : int
<span class="lineNum">     742 </span><span class="lineNoCov">          0 : keygen_add_std_prefs (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     743 </span>            : {
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :   PKT_public_key *pk = opaque;</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :   do_add_key_flags (sig, pk-&gt;pubkey_usage);</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   keygen_add_key_expire (sig, opaque );</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   keygen_upd_std_prefs (sig, opaque);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   keygen_add_keyserver_url (sig,NULL);</span>
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     752 </span>            : }
<a name="753"><span class="lineNum">     753 </span>            : </a>
<span class="lineNum">     754 </span>            : int
<span class="lineNum">     755 </span><span class="lineNoCov">          0 : keygen_add_keyserver_url(PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span><span class="lineNoCov">          0 :   const char *url=opaque;</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   if(!url)</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :     url=opt.def_keyserver_url;</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   if(url)</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :     build_sig_subpkt(sig,SIGSUBPKT_PREF_KS,url,strlen(url));</span>
<span class="lineNum">     764 </span>            :   else
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :     delete_sig_subpkt (sig-&gt;hashed,SIGSUBPKT_PREF_KS);</span>
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     768 </span>            : }
<a name="769"><span class="lineNum">     769 </span>            : </a>
<span class="lineNum">     770 </span>            : int
<span class="lineNum">     771 </span><span class="lineNoCov">          0 : keygen_add_notations(PKT_signature *sig,void *opaque)</span>
<span class="lineNum">     772 </span>            : {
<span class="lineNum">     773 </span>            :   struct notation *notation;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :   /* We always start clean */
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   delete_sig_subpkt(sig-&gt;hashed,SIGSUBPKT_NOTATION);</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   delete_sig_subpkt(sig-&gt;unhashed,SIGSUBPKT_NOTATION);</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :   sig-&gt;flags.notation=0;</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   for(notation=opaque;notation;notation=notation-&gt;next)</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     if(!notation-&gt;flags.ignore)</span>
<span class="lineNum">     782 </span>            :       {
<span class="lineNum">     783 </span>            :         unsigned char *buf;
<span class="lineNum">     784 </span>            :         unsigned int n1,n2;
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :         n1=strlen(notation-&gt;name);</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :         if(notation-&gt;altvalue)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :           n2=strlen(notation-&gt;altvalue);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         else if(notation-&gt;bdat)</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           n2=notation-&gt;blen;</span>
<span class="lineNum">     791 </span>            :         else
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :           n2=strlen(notation-&gt;value);</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         buf = xmalloc( 8 + n1 + n2 );</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :         /* human readable or not */
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         buf[0] = notation-&gt;bdat?0:0x80;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         buf[1] = buf[2] = buf[3] = 0;</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         buf[4] = n1 &gt;&gt; 8;</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :         buf[5] = n1;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         buf[6] = n2 &gt;&gt; 8;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         buf[7] = n2;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         memcpy(buf+8, notation-&gt;name, n1 );</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         if(notation-&gt;altvalue)</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           memcpy(buf+8+n1, notation-&gt;altvalue, n2 );</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         else if(notation-&gt;bdat)</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :           memcpy(buf+8+n1, notation-&gt;bdat, n2 );</span>
<span class="lineNum">     808 </span>            :         else
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :           memcpy(buf+8+n1, notation-&gt;value, n2 );</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         build_sig_subpkt( sig, SIGSUBPKT_NOTATION |</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :                           (notation-&gt;flags.critical?SIGSUBPKT_FLAG_CRITICAL:0),</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :                           buf, 8+n1+n2 );</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         xfree(buf);</span>
<span class="lineNum">     814 </span>            :       }
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     817 </span>            : }
<a name="818"><span class="lineNum">     818 </span>            : </a>
<span class="lineNum">     819 </span>            : int
<span class="lineNum">     820 </span><span class="lineNoCov">          0 : keygen_add_revkey (PKT_signature *sig, void *opaque)</span>
<span class="lineNum">     821 </span>            : {
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   struct revocation_key *revkey = opaque;</span>
<span class="lineNum">     823 </span>            :   byte buf[2+MAX_FINGERPRINT_LEN];
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   buf[0] = revkey-&gt;class;</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   buf[1] = revkey-&gt;algid;</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   memcpy (&amp;buf[2], revkey-&gt;fpr, MAX_FINGERPRINT_LEN);</span>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   build_sig_subpkt (sig, SIGSUBPKT_REV_KEY, buf, 2+MAX_FINGERPRINT_LEN);</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :   /* All sigs with revocation keys set are nonrevocable.  */
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   sig-&gt;flags.revocable = 0;</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   buf[0] = 0;</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   build_sig_subpkt (sig, SIGSUBPKT_REVOCABLE, buf, 1);</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :   parse_revkeys (sig);</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">     839 </span>            : }
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : /* Create a back-signature.  If TIMESTAMP is not NULL, use it for the
<a name="844"><span class="lineNum">     844 </span>            :    signature creation time.  */</a>
<span class="lineNum">     845 </span>            : gpg_error_t
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : make_backsig (ctrl_t ctrl, PKT_signature *sig, PKT_public_key *pk,</span>
<span class="lineNum">     847 </span>            :               PKT_public_key *sub_pk, PKT_public_key *sub_psk,
<span class="lineNum">     848 </span>            :               u32 timestamp, const char *cache_nonce)
<span class="lineNum">     849 </span>            : {
<span class="lineNum">     850 </span>            :   gpg_error_t err;
<span class="lineNum">     851 </span>            :   PKT_signature *backsig;
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :   cache_public_key (sub_pk);</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   err = make_keysig_packet (ctrl, &amp;backsig, pk, NULL, sub_pk, sub_psk, 0x19,</span>
<span class="lineNum">     856 </span>            :                             0, timestamp, 0, NULL, NULL, cache_nonce);
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     log_error (&quot;make_keysig_packet failed for backsig: %s\n&quot;,</span>
<span class="lineNum">     859 </span>            :                gpg_strerror (err));
<span class="lineNum">     860 </span>            :   else
<span class="lineNum">     861 </span>            :     {
<span class="lineNum">     862 </span>            :       /* Get it into a binary packed form. */
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :       IOBUF backsig_out = iobuf_temp();</span>
<span class="lineNum">     864 </span>            :       PACKET backsig_pkt;
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       init_packet (&amp;backsig_pkt);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       backsig_pkt.pkttype = PKT_SIGNATURE;</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       backsig_pkt.pkt.signature = backsig;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :       err = build_packet (backsig_out, &amp;backsig_pkt);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :       free_packet (&amp;backsig_pkt, NULL);</span>
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :         log_error (&quot;build_packet failed for backsig: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">     873 </span>            :       else
<span class="lineNum">     874 </span>            :         {
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :           size_t pktlen = 0;</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :           byte *buf = iobuf_get_temp_buffer (backsig_out);</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :           /* Remove the packet header. */
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :           if(buf[0]&amp;0x40)</span>
<span class="lineNum">     880 </span>            :             {
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :               if (buf[1] &lt; 192)</span>
<span class="lineNum">     882 </span>            :                 {
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :                   pktlen = buf[1];</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :                   buf += 2;</span>
<span class="lineNum">     885 </span>            :                 }
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :               else if(buf[1] &lt; 224)</span>
<span class="lineNum">     887 </span>            :                 {
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :                   pktlen = (buf[1]-192)*256;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :                   pktlen += buf[2]+192;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :                   buf += 3;</span>
<span class="lineNum">     891 </span>            :                 }
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :               else if (buf[1] == 255)</span>
<span class="lineNum">     893 </span>            :                 {
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :                   pktlen = buf32_to_size_t (buf+2);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :                   buf += 6;</span>
<span class="lineNum">     896 </span>            :                 }
<span class="lineNum">     897 </span>            :               else
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                 BUG ();</span>
<span class="lineNum">     899 </span>            :             }
<span class="lineNum">     900 </span>            :           else
<span class="lineNum">     901 </span>            :             {
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :               int mark = 1;</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :               switch (buf[0]&amp;3)</span>
<span class="lineNum">     905 </span>            :                 {
<span class="lineNum">     906 </span>            :                 case 3:
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                   BUG ();</span>
<span class="lineNum">     908 </span>            :                   break;
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :                 case 2:
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                   pktlen  = (size_t)buf[mark++] &lt;&lt; 24;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                   pktlen |= buf[mark++] &lt;&lt; 16;</span>
<span class="lineNum">     913 </span>            :                   /* fall through */
<span class="lineNum">     914 </span>            :                 case 1:
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                   pktlen |= buf[mark++] &lt;&lt; 8;</span>
<span class="lineNum">     916 </span>            :                   /* fall through */
<span class="lineNum">     917 </span>            :                 case 0:
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                   pktlen |= buf[mark++];</span>
<span class="lineNum">     919 </span>            :                 }
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :               buf += mark;</span>
<span class="lineNum">     922 </span>            :             }
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :           /* Now make the binary blob into a subpacket.  */
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :           build_sig_subpkt (sig, SIGSUBPKT_SIGNATURE, buf, pktlen);</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :           iobuf_close (backsig_out);</span>
<span class="lineNum">     928 </span>            :         }
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : /* Write a direct key signature to the first key in ROOT using the key
<span class="lineNum">     936 </span>            :    PSK.  REVKEY is describes the direct key signature and TIMESTAMP is
<a name="937"><span class="lineNum">     937 </span>            :    the timestamp to set on the signature.  */</a>
<span class="lineNum">     938 </span>            : static gpg_error_t
<span class="lineNum">     939 </span><span class="lineNoCov">          0 : write_direct_sig (ctrl_t ctrl, kbnode_t root, PKT_public_key *psk,</span>
<span class="lineNum">     940 </span>            :                   struct revocation_key *revkey, u32 timestamp,
<span class="lineNum">     941 </span>            :                   const char *cache_nonce)
<span class="lineNum">     942 </span>            : {
<span class="lineNum">     943 </span>            :   gpg_error_t err;
<span class="lineNum">     944 </span>            :   PACKET *pkt;
<span class="lineNum">     945 </span>            :   PKT_signature *sig;
<span class="lineNum">     946 </span>            :   KBNODE node;
<span class="lineNum">     947 </span>            :   PKT_public_key *pk;
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   if (opt.verbose)</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     log_info (_(&quot;writing direct signature\n&quot;));</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :   /* Get the pk packet from the pub_tree. */
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   node = find_kbnode (root, PKT_PUBLIC_KEY);</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     BUG ();</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :   /* We have to cache the key, so that the verification of the
<span class="lineNum">     959 </span>            :      signature creation is able to retrieve the public key.  */
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   cache_public_key (pk);</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   /* Make the signature.  */
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   err = make_keysig_packet (ctrl, &amp;sig, pk, NULL,NULL, psk, 0x1F,</span>
<span class="lineNum">     964 </span>            :                             0, timestamp, 0,
<span class="lineNum">     965 </span>            :                             keygen_add_revkey, revkey, cache_nonce);
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">     967 </span>            :     {
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       log_error (&quot;make_keysig_packet failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">     970 </span>            :     }
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   pkt = xmalloc_clear (sizeof *pkt);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = PKT_SIGNATURE;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.signature = sig;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   add_kbnode (root, new_kbnode (pkt));</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">     977 </span>            : }
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span>            : /* Write a self-signature to the first user id in ROOT using the key
<span class="lineNum">     982 </span>            :    PSK.  USE and TIMESTAMP give the extra data we need for the
<a name="983"><span class="lineNum">     983 </span>            :    signature.  */</a>
<span class="lineNum">     984 </span>            : static gpg_error_t
<span class="lineNum">     985 </span><span class="lineNoCov">          0 : write_selfsigs (ctrl_t ctrl, kbnode_t root, PKT_public_key *psk,</span>
<span class="lineNum">     986 </span>            :                 unsigned int use, u32 timestamp, const char *cache_nonce)
<span class="lineNum">     987 </span>            : {
<span class="lineNum">     988 </span>            :   gpg_error_t err;
<span class="lineNum">     989 </span>            :   PACKET *pkt;
<span class="lineNum">     990 </span>            :   PKT_signature *sig;
<span class="lineNum">     991 </span>            :   PKT_user_id *uid;
<span class="lineNum">     992 </span>            :   KBNODE node;
<span class="lineNum">     993 </span>            :   PKT_public_key *pk;
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   if (opt.verbose)</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     log_info (_(&quot;writing self signature\n&quot;));</span>
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :   /* Get the uid packet from the list. */
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   node = find_kbnode (root, PKT_USER_ID);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :     BUG(); /* No user id packet in tree.  */</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   uid = node-&gt;pkt-&gt;pkt.user_id;</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :   /* Get the pk packet from the pub_tree. */
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   node = find_kbnode (root, PKT_PUBLIC_KEY);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :     BUG();</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :   /* The usage has not yet been set - do it now. */
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   pk-&gt;pubkey_usage = use;</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :   /* We have to cache the key, so that the verification of the
<span class="lineNum">    1014 </span>            :      signature creation is able to retrieve the public key.  */
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   cache_public_key (pk);</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            :   /* Make the signature.  */
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   err = make_keysig_packet (ctrl, &amp;sig, pk, uid, NULL, psk, 0x13,</span>
<span class="lineNum">    1019 </span>            :                             0, timestamp, 0,
<span class="lineNum">    1020 </span>            :                             keygen_add_std_prefs, pk, cache_nonce);
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1022 </span>            :     {
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :       log_error (&quot;make_keysig_packet failed: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   pkt = xmalloc_clear (sizeof *pkt);</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = PKT_SIGNATURE;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.signature = sig;</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   add_kbnode (root, new_kbnode (pkt));</span>
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1033 </span>            : }
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            : /* Write the key binding signature.  If TIMESTAMP is not NULL use the
<span class="lineNum">    1037 </span>            :    signature creation time.  PRI_PSK is the key use for signing.
<span class="lineNum">    1038 </span>            :    SUB_PSK is a key used to create a back-signature; that one is only
<a name="1039"><span class="lineNum">    1039 </span>            :    used if USE has the PUBKEY_USAGE_SIG capability.  */</a>
<span class="lineNum">    1040 </span>            : static int
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 : write_keybinding (ctrl_t ctrl, kbnode_t root,</span>
<span class="lineNum">    1042 </span>            :                   PKT_public_key *pri_psk, PKT_public_key *sub_psk,
<span class="lineNum">    1043 </span>            :                   unsigned int use, u32 timestamp, const char *cache_nonce)
<span class="lineNum">    1044 </span>            : {
<span class="lineNum">    1045 </span>            :   gpg_error_t err;
<span class="lineNum">    1046 </span>            :   PACKET *pkt;
<span class="lineNum">    1047 </span>            :   PKT_signature *sig;
<span class="lineNum">    1048 </span>            :   KBNODE node;
<span class="lineNum">    1049 </span>            :   PKT_public_key *pri_pk, *sub_pk;
<span class="lineNum">    1050 </span>            :   struct opaque_data_usage_and_pk oduap;
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   if (opt.verbose)</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :     log_info(_(&quot;writing key binding signature\n&quot;));</span>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span>            :   /* Get the primary pk packet from the tree.  */
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   node = find_kbnode (root, PKT_PUBLIC_KEY);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :     BUG();</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   pri_pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :   /* We have to cache the key, so that the verification of the
<span class="lineNum">    1062 </span>            :    * signature creation is able to retrieve the public key.  */
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   cache_public_key (pri_pk);</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            :   /* Find the last subkey. */
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   sub_pk = NULL;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :   for (node = root; node; node = node-&gt;next )</span>
<span class="lineNum">    1068 </span>            :     {
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       if (node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :         sub_pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    1071 </span>            :     }
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   if (!sub_pk)</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     BUG();</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :   /* Make the signature.  */
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   oduap.usage = use;</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   oduap.pk = sub_pk;</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   err = make_keysig_packet (ctrl, &amp;sig, pri_pk, NULL, sub_pk, pri_psk, 0x18,</span>
<span class="lineNum">    1079 </span>            :                             0, timestamp, 0,
<span class="lineNum">    1080 </span>            :                             keygen_add_key_flags_and_expire, &amp;oduap,
<span class="lineNum">    1081 </span>            :                             cache_nonce);
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1083 </span>            :     {
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       log_error (&quot;make_keysig_packeto failed: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1086 </span>            :     }
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :   /* Make a backsig.  */
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   if (use &amp; PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    1090 </span>            :     {
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :       err = make_backsig (ctrl,</span>
<span class="lineNum">    1092 </span>            :                           sig, pri_pk, sub_pk, sub_psk, timestamp, cache_nonce);
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         return err;</span>
<span class="lineNum">    1095 </span>            :     }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   pkt = xmalloc_clear ( sizeof *pkt );</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = PKT_SIGNATURE;</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.signature = sig;</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   add_kbnode (root, new_kbnode (pkt) );</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1102 </span>            : }
<span class="lineNum">    1103 </span>            : 
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<span class="lineNum">    1105 </span>            : static gpg_error_t
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 : ecckey_from_sexp (gcry_mpi_t *array, gcry_sexp_t sexp, int algo)</span>
<span class="lineNum">    1107 </span>            : {
<span class="lineNum">    1108 </span>            :   gpg_error_t err;
<span class="lineNum">    1109 </span>            :   gcry_sexp_t list, l2;
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   char *curve = NULL;</span>
<span class="lineNum">    1111 </span>            :   int i;
<span class="lineNum">    1112 </span>            :   const char *oidstr;
<span class="lineNum">    1113 </span>            :   unsigned int nbits;
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :   array[0] = NULL;</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :   array[1] = NULL;</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :   array[2] = NULL;</span>
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   list = gcry_sexp_find_token (sexp, &quot;public-key&quot;, 0);</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :   if (!list)</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_INV_OBJ);</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :   l2 = gcry_sexp_cadr (list);</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   gcry_sexp_release (list);</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :   list = l2;</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :   if (!list)</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_NO_OBJ);</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   l2 = gcry_sexp_find_token (list, &quot;curve&quot;, 0);</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :   if (!l2)</span>
<span class="lineNum">    1130 </span>            :     {
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_NO_OBJ);</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    1133 </span>            :     }
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   curve = gcry_sexp_nth_string (l2, 1);</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   if (!curve)</span>
<span class="lineNum">    1136 </span>            :     {
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_NO_OBJ);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    1139 </span>            :     }
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :   gcry_sexp_release (l2);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :   oidstr = openpgp_curve_to_oid (curve, &amp;nbits);</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   if (!oidstr)</span>
<span class="lineNum">    1143 </span>            :     {
<span class="lineNum">    1144 </span>            :       /* That can't happen because we used one of the curves
<span class="lineNum">    1145 </span>            :          gpg_curve_to_oid knows about.  */
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_INV_OBJ);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    1148 </span>            :     }
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   err = openpgp_oid_from_str (oidstr, &amp;array[0]);</span>
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :     goto leave;</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   l2 = gcry_sexp_find_token (list, &quot;q&quot;, 0);</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   if (!l2)</span>
<span class="lineNum">    1155 </span>            :     {
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_NO_OBJ);</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :   array[1] = gcry_sexp_nth_mpi (l2, 1, GCRYMPI_FMT_USG);</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :   gcry_sexp_release (l2);</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   if (!array[1])</span>
<span class="lineNum">    1162 </span>            :     {
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_INV_OBJ);</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    1165 </span>            :     }
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   gcry_sexp_release (list);</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    1169 </span>            :     {
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :       array[2] = pk_ecdh_default_params (nbits);</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :       if (!array[2])</span>
<span class="lineNum">    1172 </span>            :         {
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :           err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    1175 </span>            :         }
<span class="lineNum">    1176 </span>            :     }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :  leave:
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   xfree (curve);</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1181 </span>            :     {
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       for (i=0; i &lt; 3; i++)</span>
<span class="lineNum">    1183 </span>            :         {
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :           gcry_mpi_release (array[i]);</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :           array[i] = NULL;</span>
<span class="lineNum">    1186 </span>            :         }
<span class="lineNum">    1187 </span>            :     }
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1189 </span>            : }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            : /* Extract key parameters from SEXP and store them in ARRAY.  ELEMS is
<span class="lineNum">    1193 </span>            :    a string where each character denotes a parameter name.  TOPNAME is
<a name="1194"><span class="lineNum">    1194 </span>            :    the name of the top element above the elements.  */</a>
<span class="lineNum">    1195 </span>            : static int
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 : key_from_sexp (gcry_mpi_t *array, gcry_sexp_t sexp,</span>
<span class="lineNum">    1197 </span>            :                const char *topname, const char *elems)
<span class="lineNum">    1198 </span>            : {
<span class="lineNum">    1199 </span>            :   gcry_sexp_t list, l2;
<span class="lineNum">    1200 </span>            :   const char *s;
<span class="lineNum">    1201 </span>            :   int i, idx;
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :   int rc = 0;</span>
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :   list = gcry_sexp_find_token (sexp, topname, 0);</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :   if (!list)</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_INV_OBJ);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   l2 = gcry_sexp_cadr (list);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   gcry_sexp_release (list);</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :   list = l2;</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   if (!list)</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_NO_OBJ);</span>
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   for (idx=0,s=elems; *s; s++, idx++)</span>
<span class="lineNum">    1214 </span>            :     {
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :       l2 = gcry_sexp_find_token (list, s, 1);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :       if (!l2)</span>
<span class="lineNum">    1217 </span>            :         {
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :           rc = gpg_error (GPG_ERR_NO_OBJ); /* required parameter not found */</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    1220 </span>            :         }
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :       array[idx] = gcry_sexp_nth_mpi (l2, 1, GCRYMPI_FMT_USG);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :       gcry_sexp_release (l2);</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :       if (!array[idx])</span>
<span class="lineNum">    1224 </span>            :         {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :           rc = gpg_error (GPG_ERR_INV_OBJ); /* required parameter invalid */</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    1227 </span>            :         }
<span class="lineNum">    1228 </span>            :     }
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :   gcry_sexp_release (list);</span>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            :  leave:
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    1233 </span>            :     {
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :       for (i=0; i&lt;idx; i++)</span>
<span class="lineNum">    1235 </span>            :         {
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :           gcry_mpi_release (array[i]);</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :           array[i] = NULL;</span>
<span class="lineNum">    1238 </span>            :         }
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :       gcry_sexp_release (list);</span>
<span class="lineNum">    1240 </span>            :     }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">    1242 </span>            : }
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : /* Create a keyblock using the given KEYGRIP.  ALGO is the OpenPGP
<a name="1246"><span class="lineNum">    1246 </span>            :    algorithm of that keygrip.  */</a>
<span class="lineNum">    1247 </span>            : static int
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 : do_create_from_keygrip (ctrl_t ctrl, int algo, const char *hexkeygrip,</span>
<span class="lineNum">    1249 </span>            :                         kbnode_t pub_root, u32 timestamp, u32 expireval,
<span class="lineNum">    1250 </span>            :                         int is_subkey)
<span class="lineNum">    1251 </span>            : {
<span class="lineNum">    1252 </span>            :   int err;
<span class="lineNum">    1253 </span>            :   PACKET *pkt;
<span class="lineNum">    1254 </span>            :   PKT_public_key *pk;
<span class="lineNum">    1255 </span>            :   gcry_sexp_t s_key;
<span class="lineNum">    1256 </span>            :   const char *algoelem;
<span class="lineNum">    1257 </span>            : 
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :   if (hexkeygrip[0] == '&amp;')</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     hexkeygrip++;</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :   switch (algo)</span>
<span class="lineNum">    1262 </span>            :     {
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :     case PUBKEY_ALGO_RSA:       algoelem = &quot;ne&quot;; break;</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :     case PUBKEY_ALGO_DSA:       algoelem = &quot;pqgy&quot;; break;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     case PUBKEY_ALGO_ELGAMAL_E: algoelem = &quot;pgy&quot;; break;</span>
<span class="lineNum">    1266 </span>            :     case PUBKEY_ALGO_ECDH:
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     case PUBKEY_ALGO_ECDSA:     algoelem = &quot;&quot;; break;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     case PUBKEY_ALGO_EDDSA:     algoelem = &quot;&quot;; break;</span>
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     default: return gpg_error (GPG_ERR_INTERNAL);</span>
<span class="lineNum">    1270 </span>            :     }
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            :   /* Ask the agent for the public key matching HEXKEYGRIP.  */
<span class="lineNum">    1274 </span>            :   {
<span class="lineNum">    1275 </span>            :     unsigned char *public;
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :     err = agent_readkey (ctrl, 0, hexkeygrip, &amp;public);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     if (err)</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :     err = gcry_sexp_sscan (&amp;s_key, NULL,</span>
<span class="lineNum">    1281 </span>            :                            public, gcry_sexp_canon_len (public, 0, NULL, NULL));
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :     xfree (public);</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     if (err)</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1285 </span>            :   }
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span>            :   /* Build a public key packet.  */
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   pk = xtrycalloc (1, sizeof *pk);</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :   if (!pk)</span>
<span class="lineNum">    1290 </span>            :     {
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :       gcry_sexp_release (s_key);</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1294 </span>            :     }
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   pk-&gt;timestamp = timestamp;</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   pk-&gt;version = 4;</span>
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   if (expireval)</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :     pk-&gt;expiredate = pk-&gt;timestamp + expireval;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :   pk-&gt;pubkey_algo = algo;</span>
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :       || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :       || algo == PUBKEY_ALGO_ECDH )</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     err = ecckey_from_sexp (pk-&gt;pkey, s_key, algo);</span>
<span class="lineNum">    1306 </span>            :   else
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     err = key_from_sexp (pk-&gt;pkey, s_key, &quot;public-key&quot;, algoelem);</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1309 </span>            :     {
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :       log_error (&quot;key_from_sexp failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :       gcry_sexp_release (s_key);</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1314 </span>            :     }
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :   gcry_sexp_release (s_key);</span>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   pkt = xtrycalloc (1, sizeof *pkt);</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   if (!pkt)</span>
<span class="lineNum">    1319 </span>            :     {
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1323 </span>            :     }
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = is_subkey ? PKT_PUBLIC_SUBKEY : PKT_PUBLIC_KEY;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.public_key = pk;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   add_kbnode (pub_root, new_kbnode (pkt));</span>
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1330 </span>            : }
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : 
<a name="1333"><span class="lineNum">    1333 </span>            : /* Common code for the key generation function gen_xxx.  */</a>
<span class="lineNum">    1334 </span>            : static int
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 : common_gen (const char *keyparms, int algo, const char *algoelem,</span>
<span class="lineNum">    1336 </span>            :             kbnode_t pub_root, u32 timestamp, u32 expireval, int is_subkey,
<span class="lineNum">    1337 </span>            :             int keygen_flags, const char *passphrase,
<span class="lineNum">    1338 </span>            :             char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    1339 </span>            : {
<span class="lineNum">    1340 </span>            :   int err;
<span class="lineNum">    1341 </span>            :   PACKET *pkt;
<span class="lineNum">    1342 </span>            :   PKT_public_key *pk;
<span class="lineNum">    1343 </span>            :   gcry_sexp_t s_key;
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   err = agent_genkey (NULL, cache_nonce_addr, passwd_nonce_addr, keyparms,</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :                       !!(keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION),</span>
<span class="lineNum">    1347 </span>            :                       passphrase,
<span class="lineNum">    1348 </span>            :                       &amp;s_key);
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1350 </span>            :     {
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       log_error (&quot;agent_genkey failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1353 </span>            :     }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :   pk = xtrycalloc (1, sizeof *pk);</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :   if (!pk)</span>
<span class="lineNum">    1357 </span>            :     {
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :       gcry_sexp_release (s_key);</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1361 </span>            :     }
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :   pk-&gt;timestamp = timestamp;</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :   pk-&gt;version = 4;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :   if (expireval)</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :     pk-&gt;expiredate = pk-&gt;timestamp + expireval;</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :   pk-&gt;pubkey_algo = algo;</span>
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :       || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :       || algo == PUBKEY_ALGO_ECDH )</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     err = ecckey_from_sexp (pk-&gt;pkey, s_key, algo);</span>
<span class="lineNum">    1373 </span>            :   else
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     err = key_from_sexp (pk-&gt;pkey, s_key, &quot;public-key&quot;, algoelem);</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1376 </span>            :     {
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       log_error (&quot;key_from_sexp failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :       gcry_sexp_release (s_key);</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1381 </span>            :     }
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   gcry_sexp_release (s_key);</span>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   pkt = xtrycalloc (1, sizeof *pkt);</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   if (!pkt)</span>
<span class="lineNum">    1386 </span>            :     {
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    1390 </span>            :     }
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = is_subkey ? PKT_PUBLIC_SUBKEY : PKT_PUBLIC_KEY;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.public_key = pk;</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :   add_kbnode (pub_root, new_kbnode (pkt));</span>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1397 </span>            : }
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            : /*
<span class="lineNum">    1401 </span>            :  * Generate an Elgamal key.
<a name="1402"><span class="lineNum">    1402 </span>            :  */</a>
<span class="lineNum">    1403 </span>            : static int
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : gen_elg (int algo, unsigned int nbits, KBNODE pub_root,</span>
<span class="lineNum">    1405 </span>            :          u32 timestamp, u32 expireval, int is_subkey,
<span class="lineNum">    1406 </span>            :          int keygen_flags, const char *passphrase,
<span class="lineNum">    1407 </span>            :          char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    1408 </span>            : {
<span class="lineNum">    1409 </span>            :   int err;
<span class="lineNum">    1410 </span>            :   char *keyparms;
<span class="lineNum">    1411 </span>            :   char nbitsstr[35];
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :   log_assert (is_ELGAMAL (algo));</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :   if (nbits &lt; 1024)</span>
<span class="lineNum">    1416 </span>            :     {
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       nbits = 2048;</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1419 </span>            :     }
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :   else if (nbits &gt; 4096)</span>
<span class="lineNum">    1421 </span>            :     {
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :       nbits = 4096;</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1424 </span>            :     }
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :   if ((nbits % 32))</span>
<span class="lineNum">    1427 </span>            :     {
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 31) / 32) * 32;</span>
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize rounded up to %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1430 </span>            :     }
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            :   /* Note that we use transient-key only if no-protection has also
<span class="lineNum">    1433 </span>            :      been enabled.  */
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   snprintf (nbitsstr, sizeof nbitsstr, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :   keyparms = xtryasprintf (&quot;(genkey(%s(nbits %zu:%s)%s))&quot;,</span>
<span class="lineNum">    1436 </span>            :                            algo == GCRY_PK_ELG_E ? &quot;openpgp-elg&quot; :
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :                            algo == GCRY_PK_ELG   ? &quot;elg&quot; : &quot;x-oops&quot; ,</span>
<span class="lineNum">    1438 </span>            :                            strlen (nbitsstr), nbitsstr,
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :                            ((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                             &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1441 </span>            :                            &quot;(transient-key)&quot; : &quot;&quot; );
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :   if (!keyparms)</span>
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1444 </span>            :   else
<span class="lineNum">    1445 </span>            :     {
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :       err = common_gen (keyparms, algo, &quot;pgy&quot;,</span>
<span class="lineNum">    1447 </span>            :                         pub_root, timestamp, expireval, is_subkey,
<span class="lineNum">    1448 </span>            :                         keygen_flags, passphrase,
<span class="lineNum">    1449 </span>            :                         cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :       xfree (keyparms);</span>
<span class="lineNum">    1451 </span>            :     }
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1454 </span>            : }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : /*
<span class="lineNum">    1458 </span>            :  * Generate an DSA key
<a name="1459"><span class="lineNum">    1459 </span>            :  */</a>
<span class="lineNum">    1460 </span>            : static gpg_error_t
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 : gen_dsa (unsigned int nbits, KBNODE pub_root,</span>
<span class="lineNum">    1462 </span>            :          u32 timestamp, u32 expireval, int is_subkey,
<span class="lineNum">    1463 </span>            :          int keygen_flags, const char *passphrase,
<span class="lineNum">    1464 </span>            :          char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    1465 </span>            : {
<span class="lineNum">    1466 </span>            :   int err;
<span class="lineNum">    1467 </span>            :   unsigned int qbits;
<span class="lineNum">    1468 </span>            :   char *keyparms;
<span class="lineNum">    1469 </span>            :   char nbitsstr[35];
<span class="lineNum">    1470 </span>            :   char qbitsstr[35];
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :   if (nbits &lt; 768)</span>
<span class="lineNum">    1473 </span>            :     {
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :       nbits = 2048;</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :       log_info(_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1476 </span>            :     }
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :   else if ( nbits &gt; 3072 )</span>
<span class="lineNum">    1478 </span>            :     {
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :       nbits = 3072;</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :       log_info(_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1481 </span>            :     }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :   if( (nbits % 64) )</span>
<span class="lineNum">    1484 </span>            :     {
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 63) / 64) * 64;</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :       log_info(_(&quot;keysize rounded up to %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1487 </span>            :     }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            :   /* To comply with FIPS rules we round up to the next value unless in
<span class="lineNum">    1490 </span>            :      expert mode.  */
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :   if (!opt.expert &amp;&amp; nbits &gt; 1024 &amp;&amp; (nbits % 1024))</span>
<span class="lineNum">    1492 </span>            :     {
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 1023) / 1024) * 1024;</span>
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :       log_info(_(&quot;keysize rounded up to %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1495 </span>            :     }
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :   /*
<span class="lineNum">    1498 </span>            :     Figure out a q size based on the key size.  FIPS 180-3 says:
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :     L = 1024, N = 160
<span class="lineNum">    1501 </span>            :     L = 2048, N = 224
<span class="lineNum">    1502 </span>            :     L = 2048, N = 256
<span class="lineNum">    1503 </span>            :     L = 3072, N = 256
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span>            :     2048/256 is an odd pair since there is also a 2048/224 and
<span class="lineNum">    1506 </span>            :     3072/256.  Matching sizes is not a very exact science.
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            :     We'll do 256 qbits for nbits over 2047, 224 for nbits over 1024
<span class="lineNum">    1509 </span>            :     but less than 2048, and 160 for 1024 (DSA1).
<span class="lineNum">    1510 </span>            :   */
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   if (nbits &gt; 2047)</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     qbits = 256;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :   else if ( nbits &gt; 1024)</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     qbits = 224;</span>
<span class="lineNum">    1516 </span>            :   else
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :     qbits = 160;</span>
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :   if (qbits != 160 )</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :     log_info (_(&quot;WARNING: some OpenPGP programs can't&quot;</span>
<span class="lineNum">    1521 </span>            :                 &quot; handle a DSA key with this digest size\n&quot;));
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :   snprintf (nbitsstr, sizeof nbitsstr, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :   snprintf (qbitsstr, sizeof qbitsstr, &quot;%u&quot;, qbits);</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   keyparms = xtryasprintf (&quot;(genkey(dsa(nbits %zu:%s)(qbits %zu:%s)%s))&quot;,</span>
<span class="lineNum">    1526 </span>            :                            strlen (nbitsstr), nbitsstr,
<span class="lineNum">    1527 </span>            :                            strlen (qbitsstr), qbitsstr,
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :                            ((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :                             &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1530 </span>            :                            &quot;(transient-key)&quot; : &quot;&quot; );
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   if (!keyparms)</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :     err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1533 </span>            :   else
<span class="lineNum">    1534 </span>            :     {
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :       err = common_gen (keyparms, PUBKEY_ALGO_DSA, &quot;pqgy&quot;,</span>
<span class="lineNum">    1536 </span>            :                         pub_root, timestamp, expireval, is_subkey,
<span class="lineNum">    1537 </span>            :                         keygen_flags, passphrase,
<span class="lineNum">    1538 </span>            :                         cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :       xfree (keyparms);</span>
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1543 </span>            : }
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            : /*
<span class="lineNum">    1548 </span>            :  * Generate an ECC key
<a name="1549"><span class="lineNum">    1549 </span>            :  */</a>
<span class="lineNum">    1550 </span>            : static gpg_error_t
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 : gen_ecc (int algo, const char *curve, kbnode_t pub_root,</span>
<span class="lineNum">    1552 </span>            :          u32 timestamp, u32 expireval, int is_subkey,
<span class="lineNum">    1553 </span>            :          int keygen_flags, const char *passphrase,
<span class="lineNum">    1554 </span>            :          char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    1555 </span>            : {
<span class="lineNum">    1556 </span>            :   gpg_error_t err;
<span class="lineNum">    1557 </span>            :   char *keyparms;
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :   log_assert (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    1560 </span>            :               || algo == PUBKEY_ALGO_EDDSA
<span class="lineNum">    1561 </span>            :               || algo == PUBKEY_ALGO_ECDH);
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   if (!curve || !*curve)</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_UNKNOWN_CURVE);</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :   /* Note that we use the &quot;comp&quot; flag with EdDSA to request the use of
<span class="lineNum">    1567 </span>            :      a 0x40 compression prefix octet.  */
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_EDDSA)</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     keyparms = xtryasprintf</span>
<span class="lineNum">    1570 </span>            :       (&quot;(genkey(ecc(curve %zu:%s)(flags eddsa comp%s)))&quot;,
<span class="lineNum">    1571 </span>            :        strlen (curve), curve,
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :        (((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :          &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1574 </span>            :         &quot; transient-key&quot; : &quot;&quot;));
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDH &amp;&amp; !strcmp (curve, &quot;Curve25519&quot;))</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     keyparms = xtryasprintf</span>
<span class="lineNum">    1577 </span>            :       (&quot;(genkey(ecc(curve %zu:%s)(flags djb-tweak comp%s)))&quot;,
<span class="lineNum">    1578 </span>            :        strlen (curve), curve,
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :        (((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :          &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1581 </span>            :         &quot; transient-key&quot; : &quot;&quot;));
<span class="lineNum">    1582 </span>            :   else
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     keyparms = xtryasprintf</span>
<span class="lineNum">    1584 </span>            :       (&quot;(genkey(ecc(curve %zu:%s)(flags nocomp%s)))&quot;,
<span class="lineNum">    1585 </span>            :        strlen (curve), curve,
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :        (((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :          &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1588 </span>            :         &quot; transient-key&quot; : &quot;&quot;));
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   if (!keyparms)</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :     err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1592 </span>            :   else
<span class="lineNum">    1593 </span>            :     {
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :       err = common_gen (keyparms, algo, &quot;&quot;,</span>
<span class="lineNum">    1595 </span>            :                         pub_root, timestamp, expireval, is_subkey,
<span class="lineNum">    1596 </span>            :                         keygen_flags, passphrase,
<span class="lineNum">    1597 </span>            :                         cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       xfree (keyparms);</span>
<span class="lineNum">    1599 </span>            :     }
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1602 </span>            : }
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            : /*
<span class="lineNum">    1606 </span>            :  * Generate an RSA key.
<a name="1607"><span class="lineNum">    1607 </span>            :  */</a>
<span class="lineNum">    1608 </span>            : static int
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 : gen_rsa (int algo, unsigned int nbits, KBNODE pub_root,</span>
<span class="lineNum">    1610 </span>            :          u32 timestamp, u32 expireval, int is_subkey,
<span class="lineNum">    1611 </span>            :          int keygen_flags, const char *passphrase,
<span class="lineNum">    1612 </span>            :          char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    1613 </span>            : {
<span class="lineNum">    1614 </span>            :   int err;
<span class="lineNum">    1615 </span>            :   char *keyparms;
<span class="lineNum">    1616 </span>            :   char nbitsstr[35];
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :   const unsigned maxsize = (opt.flags.large_rsa ? 8192 : 4096);</span>
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   log_assert (is_RSA(algo));</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :   if (!nbits)</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     nbits = get_keysize_range (algo, NULL, NULL);</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :   if (nbits &lt; 1024)</span>
<span class="lineNum">    1625 </span>            :     {
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :       nbits = 2048;</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1628 </span>            :     }
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :   else if (nbits &gt; maxsize)</span>
<span class="lineNum">    1630 </span>            :     {
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :       nbits = maxsize;</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize invalid; using %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1633 </span>            :     }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :   if ((nbits % 32))</span>
<span class="lineNum">    1636 </span>            :     {
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 31) / 32) * 32;</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :       log_info (_(&quot;keysize rounded up to %u bits\n&quot;), nbits );</span>
<span class="lineNum">    1639 </span>            :     }
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :   snprintf (nbitsstr, sizeof nbitsstr, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   keyparms = xtryasprintf (&quot;(genkey(rsa(nbits %zu:%s)%s))&quot;,</span>
<span class="lineNum">    1643 </span>            :                            strlen (nbitsstr), nbitsstr,
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :                            ((keygen_flags &amp; KEYGEN_FLAG_TRANSIENT_KEY)</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :                             &amp;&amp; (keygen_flags &amp; KEYGEN_FLAG_NO_PROTECTION))?</span>
<span class="lineNum">    1646 </span>            :                            &quot;(transient-key)&quot; : &quot;&quot; );
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   if (!keyparms)</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     err = gpg_error_from_syserror ();</span>
<span class="lineNum">    1649 </span>            :   else
<span class="lineNum">    1650 </span>            :     {
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :       err = common_gen (keyparms, algo, &quot;ne&quot;,</span>
<span class="lineNum">    1652 </span>            :                         pub_root, timestamp, expireval, is_subkey,
<span class="lineNum">    1653 </span>            :                         keygen_flags, passphrase,
<span class="lineNum">    1654 </span>            :                         cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :       xfree (keyparms);</span>
<span class="lineNum">    1656 </span>            :     }
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    1659 </span>            : }
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span>            : /****************
<span class="lineNum">    1663 </span>            :  * check valid days:
<span class="lineNum">    1664 </span>            :  * return 0 on error or the multiplier
<a name="1665"><span class="lineNum">    1665 </span>            :  */</a>
<span class="lineNum">    1666 </span>            : static int
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 : check_valid_days( const char *s )</span>
<span class="lineNum">    1668 </span>            : {
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     if( !digitp(s) )</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     for( s++; *s; s++)</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :         if( !digitp(s) )</span>
<span class="lineNum">    1673 </span>            :             break;
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :     if( !*s )</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :     if( s[1] )</span>
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :         return 0; /* e.g. &quot;2323wc&quot; */</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :     if( *s == 'd' || *s == 'D' )</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     if( *s == 'w' || *s == 'W' )</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :         return 7;</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     if( *s == 'm' || *s == 'M' )</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :         return 30;</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :     if( *s == 'y' || *s == 'Y' )</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :         return 365;</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1687 </span>            : }
<span class="lineNum">    1688 </span>            : 
<a name="1689"><span class="lineNum">    1689 </span>            : </a>
<span class="lineNum">    1690 </span>            : static void
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 : print_key_flags(int flags)</span>
<span class="lineNum">    1692 </span>            : {
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   if(flags&amp;PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     tty_printf(&quot;%s &quot;,_(&quot;Sign&quot;));</span>
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :   if(flags&amp;PUBKEY_USAGE_CERT)</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :     tty_printf(&quot;%s &quot;,_(&quot;Certify&quot;));</span>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :   if(flags&amp;PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     tty_printf(&quot;%s &quot;,_(&quot;Encrypt&quot;));</span>
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :   if(flags&amp;PUBKEY_USAGE_AUTH)</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     tty_printf(&quot;%s &quot;,_(&quot;Authenticate&quot;));</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            : 
<span class="lineNum">    1707 </span>            : /* Ask for the key flags and return them.  CURRENT gives the current
<a name="1708"><span class="lineNum">    1708 </span>            :  * usage which should normally be given as 0. */</a>
<span class="lineNum">    1709 </span>            : unsigned int
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 : ask_key_flags (int algo, int subkey, unsigned int current)</span>
<span class="lineNum">    1711 </span>            : {
<span class="lineNum">    1712 </span>            :   /* TRANSLATORS: Please use only plain ASCII characters for the
<span class="lineNum">    1713 </span>            :      translation.  If this is not possible use single digits.  The
<span class="lineNum">    1714 </span>            :      string needs to 8 bytes long. Here is a description of the
<span class="lineNum">    1715 </span>            :      functions:
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span>            :        s = Toggle signing capability
<span class="lineNum">    1718 </span>            :        e = Toggle encryption capability
<span class="lineNum">    1719 </span>            :        a = Toggle authentication capability
<span class="lineNum">    1720 </span>            :        q = Finish
<span class="lineNum">    1721 </span>            :   */
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :   const char *togglers = _(&quot;SsEeAaQq&quot;);</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :   char *answer = NULL;</span>
<span class="lineNum">    1724 </span>            :   const char *s;
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :   unsigned int possible = openpgp_pk_algo_usage(algo);</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   if ( strlen(togglers) != 8 )</span>
<span class="lineNum">    1728 </span>            :     {
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :       tty_printf (&quot;NOTE: Bad translation at %s:%d. &quot;</span>
<span class="lineNum">    1730 </span>            :                   &quot;Please report.\n&quot;, __FILE__, __LINE__);
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :       togglers = &quot;11223300&quot;;</span>
<span class="lineNum">    1732 </span>            :     }
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :   /* Only primary keys may certify. */
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :   if(subkey)</span>
<span class="lineNum">    1736 </span><span class="lineNoCov">          0 :     possible&amp;=~PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            :   /* Preload the current set with the possible set, minus
<span class="lineNum">    1739 </span>            :      authentication if CURRENT has been given as 0.  If CURRENT has
<span class="lineNum">    1740 </span>            :      been has non-zero we mask with all possible usages. */
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :   if (current)</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     current &amp;= possible;</span>
<span class="lineNum">    1743 </span>            :   else
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     current = (possible&amp;~PUBKEY_USAGE_AUTH);</span>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :   for(;;)
<span class="lineNum">    1747 </span>            :     {
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :       tty_printf(_(&quot;Possible actions for a %s key: &quot;),</span>
<span class="lineNum">    1750 </span>            :                  (algo == PUBKEY_ALGO_ECDSA
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_EDDSA)</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                  ? &quot;ECDSA/EdDSA&quot; : openpgp_pk_algo_name (algo));</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :       print_key_flags(possible);</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :       tty_printf(_(&quot;Current allowed actions: &quot;));</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :       print_key_flags(current);</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n\n&quot;);</span>
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :       if(possible&amp;PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;   (%c) Toggle the sign capability\n&quot;),</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :                    togglers[0]);</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :       if(possible&amp;PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;   (%c) Toggle the encrypt capability\n&quot;),</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :                    togglers[2]);</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :       if(possible&amp;PUBKEY_USAGE_AUTH)</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;   (%c) Toggle the authenticate capability\n&quot;),</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :                    togglers[4]);</span>
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :       tty_printf(_(&quot;   (%c) Finished\n&quot;),togglers[6]);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :       tty_printf(&quot;\n&quot;);</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :       xfree(answer);</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :       answer = cpr_get(&quot;keygen.flags&quot;,_(&quot;Your selection? &quot;));</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :       cpr_kill_prompt();</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :       if (*answer == '=')</span>
<span class="lineNum">    1777 </span>            :         {
<span class="lineNum">    1778 </span>            :           /* Hack to allow direct entry of the capabilities.  */
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :           current = 0;</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :           for (s=answer+1; *s; s++)</span>
<span class="lineNum">    1781 </span>            :             {
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :               if ((*s == 's' || *s == 'S') &amp;&amp; (possible&amp;PUBKEY_USAGE_SIG))</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :                 current |= PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :               else if ((*s == 'e' || *s == 'E') &amp;&amp; (possible&amp;PUBKEY_USAGE_ENC))</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :                 current |= PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :               else if ((*s == 'a' || *s == 'A') &amp;&amp; (possible&amp;PUBKEY_USAGE_AUTH))</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                 current |= PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :               else if (!subkey &amp;&amp; *s == 'c')</span>
<span class="lineNum">    1789 </span>            :                 {
<span class="lineNum">    1790 </span>            :                   /* Accept 'c' for the primary key because USAGE_CERT
<span class="lineNum">    1791 </span>            :                      will be set anyway.  This is for folks who
<span class="lineNum">    1792 </span>            :                      want to experiment with a cert-only primary key.  */
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                   current |= PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    1794 </span>            :                 }
<span class="lineNum">    1795 </span>            :             }
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1797 </span>            :         }
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :       else if (strlen(answer)&gt;1)</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;Invalid selection.\n&quot;));</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :       else if(*answer=='\0' || *answer==togglers[6] || *answer==togglers[7])</span>
<span class="lineNum">    1801 </span>            :         break;
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :       else if((*answer==togglers[0] || *answer==togglers[1])</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :               &amp;&amp; possible&amp;PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    1804 </span>            :         {
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :           if(current&amp;PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :             current&amp;=~PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    1807 </span>            :           else
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :             current|=PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    1809 </span>            :         }
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :       else if((*answer==togglers[2] || *answer==togglers[3])</span>
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 :               &amp;&amp; possible&amp;PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    1812 </span>            :         {
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :           if(current&amp;PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :             current&amp;=~PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1815 </span>            :           else
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :             current|=PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1817 </span>            :         }
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :       else if((*answer==togglers[4] || *answer==togglers[5])</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :               &amp;&amp; possible&amp;PUBKEY_USAGE_AUTH)</span>
<span class="lineNum">    1820 </span>            :         {
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :           if(current&amp;PUBKEY_USAGE_AUTH)</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :             current&amp;=~PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    1823 </span>            :           else
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :             current|=PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    1825 </span>            :         }
<span class="lineNum">    1826 </span>            :       else
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;Invalid selection.\n&quot;));</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :   xfree(answer);</span>
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 :   return current;</span>
<span class="lineNum">    1833 </span>            : }
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            : /* Check whether we have a key for the key with HEXGRIP.  Returns 0 if
<a name="1837"><span class="lineNum">    1837 </span>            :    there is no such key or the OpenPGP algo number for the key.  */</a>
<span class="lineNum">    1838 </span>            : static int
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 : check_keygrip (ctrl_t ctrl, const char *hexgrip)</span>
<span class="lineNum">    1840 </span>            : {
<span class="lineNum">    1841 </span>            :   gpg_error_t err;
<span class="lineNum">    1842 </span>            :   unsigned char *public;
<span class="lineNum">    1843 </span>            :   size_t publiclen;
<span class="lineNum">    1844 </span>            :   int algo;
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :   if (hexgrip[0] == '&amp;')</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :     hexgrip++;</span>
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :   err = agent_readkey (ctrl, 0, hexgrip, &amp;public);</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :   publiclen = gcry_sexp_canon_len (public, 0, NULL, NULL);</span>
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   algo = get_pk_algo_from_canon_sexp (public, publiclen);</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   xfree (public);</span>
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :   return map_pk_gcry_to_openpgp (algo);</span>
<span class="lineNum">    1858 </span>            : }
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            : /* Ask for an algorithm.  The function returns the algorithm id to
<span class="lineNum">    1863 </span>            :  * create. If ADDMODE is false the function won't show an option to
<span class="lineNum">    1864 </span>            :  * create the primary and subkey combined and won't set R_USAGE
<span class="lineNum">    1865 </span>            :  * either.  If a combined algorithm has been selected, the subkey
<span class="lineNum">    1866 </span>            :  * algorithm is stored at R_SUBKEY_ALGO.  If R_KEYGRIP is given, the
<span class="lineNum">    1867 </span>            :  * user has the choice to enter the keygrip of an existing key.  That
<span class="lineNum">    1868 </span>            :  * keygrip is then stored at this address.  The caller needs to free
<a name="1869"><span class="lineNum">    1869 </span>            :  * it. */</a>
<span class="lineNum">    1870 </span>            : static int
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 : ask_algo (ctrl_t ctrl, int addmode, int *r_subkey_algo, unsigned int *r_usage,</span>
<span class="lineNum">    1872 </span>            :           char **r_keygrip)
<span class="lineNum">    1873 </span>            : {
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :   char *keygrip = NULL;</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :   char *answer = NULL;</span>
<span class="lineNum">    1876 </span>            :   int algo;
<span class="lineNum">    1877 </span>            :   int dummy_algo;
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :   if (!r_subkey_algo)</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :     r_subkey_algo = &amp;dummy_algo;</span>
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :   tty_printf (_(&quot;Please select what kind of key you want:\n&quot;));</span>
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span>            : #if GPG_USE_RSA
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :   if (!addmode)</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;   (%d) RSA and RSA (default)\n&quot;), 1 );</span>
<span class="lineNum">    1887 </span>            : #endif
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :   if (!addmode &amp;&amp; opt.compliance != CO_DE_VS)</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;   (%d) DSA and Elgamal\n&quot;), 2 );</span>
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :   if (opt.compliance != CO_DE_VS)</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;   (%d) DSA (sign only)\n&quot;), 3 );</span>
<span class="lineNum">    1894 </span>            : #if GPG_USE_RSA
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   tty_printf (_(&quot;   (%d) RSA (sign only)\n&quot;), 4 );</span>
<span class="lineNum">    1896 </span>            : #endif
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :   if (addmode)</span>
<span class="lineNum">    1899 </span>            :     {
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :       if (opt.compliance != CO_DE_VS)</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;   (%d) Elgamal (encrypt only)\n&quot;), 5 );</span>
<span class="lineNum">    1902 </span>            : #if GPG_USE_RSA
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :       tty_printf (_(&quot;   (%d) RSA (encrypt only)\n&quot;), 6 );</span>
<span class="lineNum">    1904 </span>            : #endif
<span class="lineNum">    1905 </span>            :     }
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :   if (opt.expert)</span>
<span class="lineNum">    1907 </span>            :     {
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :       if (opt.compliance != CO_DE_VS)</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;   (%d) DSA (set your own capabilities)\n&quot;), 7 );</span>
<span class="lineNum">    1910 </span>            : #if GPG_USE_RSA
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :       tty_printf (_(&quot;   (%d) RSA (set your own capabilities)\n&quot;), 8 );</span>
<span class="lineNum">    1912 </span>            : #endif
<span class="lineNum">    1913 </span>            :     }
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            : #if GPG_USE_ECDSA || GPG_USE_ECDH || GPG_USE_EDDSA
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :   if (opt.expert &amp;&amp; !addmode)</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;   (%d) ECC and ECC\n&quot;), 9 );</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :   if (opt.expert)</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;  (%d) ECC (sign only)\n&quot;), 10 );</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :   if (opt.expert)</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;  (%d) ECC (set your own capabilities)\n&quot;), 11 );</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :   if (opt.expert &amp;&amp; addmode)</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;  (%d) ECC (encrypt only)\n&quot;), 12 );</span>
<span class="lineNum">    1924 </span>            : #endif
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :   if (opt.expert &amp;&amp; r_keygrip)</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :     tty_printf (_(&quot;  (%d) Existing key\n&quot;), 13 );</span>
<span class="lineNum">    1928 </span>            : 
<span class="lineNum">    1929 </span>            :   for (;;)
<span class="lineNum">    1930 </span>            :     {
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :       *r_usage = 0;</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :       *r_subkey_algo = 0;</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :       xfree (answer);</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :       answer = cpr_get (&quot;keygen.algo&quot;, _(&quot;Your selection? &quot;));</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :       cpr_kill_prompt ();</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :       algo = *answer? atoi (answer) : 1;</span>
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :       if (opt.compliance == CO_DE_VS</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :           &amp;&amp; (algo == 2 || algo == 3 || algo == 5 || algo == 7))</span>
<span class="lineNum">    1940 </span>            :         {
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :           tty_printf (_(&quot;Invalid selection.\n&quot;));</span>
<span class="lineNum">    1942 </span>            :         }
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :       else if ((algo == 1 || !strcmp (answer, &quot;rsa+rsa&quot;)) &amp;&amp; !addmode)</span>
<span class="lineNum">    1944 </span>            :         {
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :           *r_subkey_algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1948 </span>            :         }
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :       else if ((algo == 2 || !strcmp (answer, &quot;dsa+elg&quot;)) &amp;&amp; !addmode)</span>
<span class="lineNum">    1950 </span>            :         {
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_DSA;</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :           *r_subkey_algo = PUBKEY_ALGO_ELGAMAL_E;</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1954 </span>            :         }
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :       else if (algo == 3 || !strcmp (answer, &quot;dsa&quot;))</span>
<span class="lineNum">    1956 </span>            :         {
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_DSA;</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1960 </span>            :         }
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :       else if (algo == 4 || !strcmp (answer, &quot;rsa/s&quot;))</span>
<span class="lineNum">    1962 </span>            :         {
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1966 </span>            :         }
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :       else if ((algo == 5 || !strcmp (answer, &quot;elg&quot;)) &amp;&amp; addmode)</span>
<span class="lineNum">    1968 </span>            :         {
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ELGAMAL_E;</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1972 </span>            :         }
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :       else if ((algo == 6 || !strcmp (answer, &quot;rsa/e&quot;)) &amp;&amp; addmode)</span>
<span class="lineNum">    1974 </span>            :         {
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1978 </span>            :         }
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :       else if ((algo == 7 || !strcmp (answer, &quot;dsa/*&quot;)) &amp;&amp; opt.expert)</span>
<span class="lineNum">    1980 </span>            :         {
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_DSA;</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :           *r_usage = ask_key_flags (algo, addmode, 0);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1984 </span>            :         }
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :       else if ((algo == 8 || !strcmp (answer, &quot;rsa/*&quot;)) &amp;&amp; opt.expert)</span>
<span class="lineNum">    1986 </span>            :         {
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :           *r_usage = ask_key_flags (algo, addmode, 0);</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1990 </span>            :         }
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :       else if ((algo == 9 || !strcmp (answer, &quot;ecc+ecc&quot;))</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :                &amp;&amp; opt.expert &amp;&amp; !addmode)</span>
<span class="lineNum">    1993 </span>            :         {
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :           *r_subkey_algo = PUBKEY_ALGO_ECDH;</span>
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1997 </span>            :         }
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :       else if ((algo == 10 || !strcmp (answer, &quot;ecc/s&quot;)) &amp;&amp; opt.expert)</span>
<span class="lineNum">    1999 </span>            :         {
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2003 </span>            :         }
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :       else if ((algo == 11 || !strcmp (answer, &quot;ecc/*&quot;)) &amp;&amp; opt.expert)</span>
<span class="lineNum">    2005 </span>            :         {
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 :           *r_usage = ask_key_flags (algo, addmode, 0);</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2009 </span>            :         }
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :       else if ((algo == 12 || !strcmp (answer, &quot;ecc/e&quot;))</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :                &amp;&amp; opt.expert &amp;&amp; addmode)</span>
<span class="lineNum">    2012 </span>            :         {
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ECDH;</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :           *r_usage = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2016 </span>            :         }
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :       else if ((algo == 13 || !strcmp (answer, &quot;keygrip&quot;))</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :                &amp;&amp; opt.expert &amp;&amp; r_keygrip)</span>
<span class="lineNum">    2019 </span>            :         {
<span class="lineNum">    2020 </span>            :           for (;;)
<span class="lineNum">    2021 </span>            :             {
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :               xfree (answer);</span>
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :               answer = tty_get (_(&quot;Enter the keygrip: &quot;));</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :               tty_kill_prompt ();</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :               trim_spaces (answer);</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :               if (!*answer)</span>
<span class="lineNum">    2027 </span>            :                 {
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :                   xfree (answer);</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :                   answer = NULL;</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">    2031 </span>            :                 }
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :               if (strlen (answer) != 40 &amp;&amp;</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :                        !(answer[0] == '&amp;' &amp;&amp; strlen (answer+1) == 40))</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :                 tty_printf</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :                   (_(&quot;Not a valid keygrip (expecting 40 hex digits)\n&quot;));</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :               else if (!(algo = check_keygrip (ctrl, answer)) )</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :                 tty_printf (_(&quot;No key with this keygrip\n&quot;));</span>
<span class="lineNum">    2039 </span>            :               else
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :                 break; /* Okay.  */</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :           xfree (keygrip);</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :           keygrip = answer;</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :           answer = NULL;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :           *r_usage = ask_key_flags (algo, addmode, 0);</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2047 </span>            :         }
<span class="lineNum">    2048 </span>            :       else
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;Invalid selection.\n&quot;));</span>
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :   xfree(answer);</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :   if (r_keygrip)</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     *r_keygrip = keygrip;</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :   return algo;</span>
<span class="lineNum">    2057 </span>            : }
<span class="lineNum">    2058 </span>            : 
<a name="2059"><span class="lineNum">    2059 </span>            : </a>
<span class="lineNum">    2060 </span>            : static unsigned int
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 : get_keysize_range (int algo, unsigned int *min, unsigned int *max)</span>
<span class="lineNum">    2062 </span>            : {
<span class="lineNum">    2063 </span>            :   unsigned int def;
<span class="lineNum">    2064 </span>            :   unsigned int dummy1, dummy2;
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :   if (!min)</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :     min = &amp;dummy1;</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :   if (!max)</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :     max = &amp;dummy2;</span>
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :   switch(algo)</span>
<span class="lineNum">    2072 </span>            :     {
<span class="lineNum">    2073 </span>            :     case PUBKEY_ALGO_DSA:
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :       *min = opt.expert? 768 : 1024;</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :       *max=3072;</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :       def=2048;</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :     case PUBKEY_ALGO_ECDSA:
<span class="lineNum">    2080 </span>            :     case PUBKEY_ALGO_ECDH:
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :       *min=256;</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :       *max=521;</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :       def=256;</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span>            :     case PUBKEY_ALGO_EDDSA:
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :       *min=255;</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :       *max=441;</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :       def=255;</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :     default:
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :       *min = opt.compliance == CO_DE_VS ? 2048: 1024;</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :       *max = 4096;</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :       def = 2048;</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2097 </span>            :     }
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :   return def;</span>
<span class="lineNum">    2100 </span>            : }
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            : 
<a name="2103"><span class="lineNum">    2103 </span>            : /* Return a fixed up keysize depending on ALGO.  */</a>
<span class="lineNum">    2104 </span>            : static unsigned int
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 : fixup_keysize (unsigned int nbits, int algo, int silent)</span>
<span class="lineNum">    2106 </span>            : {
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_DSA &amp;&amp; (nbits % 64))</span>
<span class="lineNum">    2108 </span>            :     {
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 63) / 64) * 64;</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :       if (!silent)</span>
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;rounded up to %u bits\n&quot;), nbits);</span>
<span class="lineNum">    2112 </span>            :     }
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_EDDSA)</span>
<span class="lineNum">    2114 </span>            :     {
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :       if (nbits != 255 &amp;&amp; nbits != 441)</span>
<span class="lineNum">    2116 </span>            :         {
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :           if (nbits &lt; 256)</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :             nbits = 255;</span>
<span class="lineNum">    2119 </span>            :           else
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :             nbits = 441;</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :           if (!silent)</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :             tty_printf (_(&quot;rounded to %u bits\n&quot;), nbits);</span>
<span class="lineNum">    2123 </span>            :         }
<span class="lineNum">    2124 </span>            :     }
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDH || algo == PUBKEY_ALGO_ECDSA)</span>
<span class="lineNum">    2126 </span>            :     {
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :       if (nbits != 256 &amp;&amp; nbits != 384 &amp;&amp; nbits != 521)</span>
<span class="lineNum">    2128 </span>            :         {
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :           if (nbits &lt; 256)</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :             nbits = 256;</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :           else if (nbits &lt; 384)</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :             nbits = 384;</span>
<span class="lineNum">    2133 </span>            :           else
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :             nbits = 521;</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :           if (!silent)</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :             tty_printf (_(&quot;rounded to %u bits\n&quot;), nbits);</span>
<span class="lineNum">    2137 </span>            :         }
<span class="lineNum">    2138 </span>            :     }
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :   else if ((nbits % 32))</span>
<span class="lineNum">    2140 </span>            :     {
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :       nbits = ((nbits + 31) / 32) * 32;</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :       if (!silent)</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;rounded up to %u bits\n&quot;), nbits );</span>
<span class="lineNum">    2144 </span>            :     }
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :   return nbits;</span>
<span class="lineNum">    2147 </span>            : }
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span>            : /* Ask for the key size.  ALGO is the algorithm.  If PRIMARY_KEYSIZE
<span class="lineNum">    2151 </span>            :    is not 0, the function asks for the size of the encryption
<a name="2152"><span class="lineNum">    2152 </span>            :    subkey. */</a>
<span class="lineNum">    2153 </span>            : static unsigned
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 : ask_keysize (int algo, unsigned int primary_keysize)</span>
<span class="lineNum">    2155 </span>            : {
<span class="lineNum">    2156 </span>            :   unsigned int nbits;
<span class="lineNum">    2157 </span>            :   unsigned int min, def, max;
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :   int for_subkey = !!primary_keysize;</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :   int autocomp = 0;</span>
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :   def = get_keysize_range (algo, &amp;min, &amp;max);</span>
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :   if (primary_keysize &amp;&amp; !opt.expert)</span>
<span class="lineNum">    2164 </span>            :     {
<span class="lineNum">    2165 </span>            :       /* Deduce the subkey size from the primary key size.  */
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :       if (algo == PUBKEY_ALGO_DSA &amp;&amp; primary_keysize &gt; 3072)</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :         nbits = 3072; /* For performance reasons we don't support more</span>
<span class="lineNum">    2168 </span>            :                          than 3072 bit DSA.  However we won't see this
<span class="lineNum">    2169 </span>            :                          case anyway because DSA can't be used as an
<span class="lineNum">    2170 </span>            :                          encryption subkey ;-). */
<span class="lineNum">    2171 </span>            :       else
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         nbits = primary_keysize;</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :       autocomp = 1;</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    2175 </span>            :     }
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :   tty_printf(_(&quot;%s keys may be between %u and %u bits long.\n&quot;),</span>
<span class="lineNum">    2178 </span>            :              openpgp_pk_algo_name (algo), min, max);
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span>            :   for (;;)
<span class="lineNum">    2181 </span>            :     {
<span class="lineNum">    2182 </span>            :       char *prompt, *answer;
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :       if (for_subkey)</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :         prompt = xasprintf (_(&quot;What keysize do you want &quot;</span>
<span class="lineNum">    2186 </span>            :                               &quot;for the subkey? (%u) &quot;), def);
<span class="lineNum">    2187 </span>            :       else
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :         prompt = xasprintf (_(&quot;What keysize do you want? (%u) &quot;), def);</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :       answer = cpr_get (&quot;keygen.size&quot;, prompt);</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :       cpr_kill_prompt ();</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :       nbits = *answer? atoi (answer): def;</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :       xfree(prompt);</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :       xfree(answer);</span>
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :       if(nbits&lt;min || nbits&gt;max)</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;%s keysizes must be in the range %u-%u\n&quot;),</span>
<span class="lineNum">    2197 </span>            :                    openpgp_pk_algo_name (algo), min, max);
<span class="lineNum">    2198 </span>            :       else
<span class="lineNum">    2199 </span>            :         break;
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2201 </span>            : 
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :   tty_printf (_(&quot;Requested keysize is %u bits\n&quot;), nbits);</span>
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span>            :  leave:
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :   nbits = fixup_keysize (nbits, algo, autocomp);</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :   return nbits;</span>
<span class="lineNum">    2207 </span>            : }
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span>            : /* Ask for the curve.  ALGO is the selected algorithm which this
<span class="lineNum">    2211 </span>            :    function may adjust.  Returns a malloced string with the name of
<a name="2212"><span class="lineNum">    2212 </span>            :    the curve.  BOTH tells that gpg creates a primary and subkey. */</a>
<span class="lineNum">    2213 </span>            : static char *
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 : ask_curve (int *algo, int *subkey_algo)</span>
<span class="lineNum">    2215 </span>            : {
<span class="lineNum">    2216 </span>            :   /* NB: We always use a complete algo list so that we have stable
<span class="lineNum">    2217 </span>            :      numbers in the menu regardless on how Gpg was configured.  */
<span class="lineNum">    2218 </span>            :   struct {
<span class="lineNum">    2219 </span>            :     const char *name;
<span class="lineNum">    2220 </span>            :     const char* eddsa_curve; /* Corresponding EdDSA curve.  */
<span class="lineNum">    2221 </span>            :     const char *pretty_name;
<span class="lineNum">    2222 </span>            :     unsigned int supported : 1;   /* Supported by gpg.     */
<span class="lineNum">    2223 </span>            :     unsigned int de_vs : 1;       /* Allowed in CO_DE_VS.  */
<span class="lineNum">    2224 </span>            :     unsigned int expert_only : 1; /* Only with --expert    */
<span class="lineNum">    2225 </span>            :     unsigned int available : 1;   /* Available in Libycrypt (runtime checked) */
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :   } curves[] = {</span>
<span class="lineNum">    2227 </span>            : #if GPG_USE_ECDSA || GPG_USE_ECDH
<span class="lineNum">    2228 </span>            : # define MY_USE_ECDSADH 1
<span class="lineNum">    2229 </span>            : #else
<span class="lineNum">    2230 </span>            : # define MY_USE_ECDSADH 0
<span class="lineNum">    2231 </span>            : #endif
<span class="lineNum">    2232 </span>            :     { &quot;Curve25519&quot;,      &quot;Ed25519&quot;, &quot;Curve 25519&quot;, !!GPG_USE_EDDSA, 0, 0, 0 },
<span class="lineNum">    2233 </span>            :     { &quot;Curve448&quot;,        &quot;Ed448&quot;,   &quot;Curve 448&quot;,   0/*reserved*/  , 0, 1, 0 },
<span class="lineNum">    2234 </span>            :     { &quot;NIST P-256&quot;,      NULL, NULL,               MY_USE_ECDSADH,  0, 1, 0 },
<span class="lineNum">    2235 </span>            :     { &quot;NIST P-384&quot;,      NULL, NULL,               MY_USE_ECDSADH,  0, 0, 0 },
<span class="lineNum">    2236 </span>            :     { &quot;NIST P-521&quot;,      NULL, NULL,               MY_USE_ECDSADH,  0, 1, 0 },
<span class="lineNum">    2237 </span>            :     { &quot;brainpoolP256r1&quot;, NULL, &quot;Brainpool P-256&quot;,  MY_USE_ECDSADH,  1, 1, 0 },
<span class="lineNum">    2238 </span>            :     { &quot;brainpoolP384r1&quot;, NULL, &quot;Brainpool P-384&quot;,  MY_USE_ECDSADH,  1, 1, 0 },
<span class="lineNum">    2239 </span>            :     { &quot;brainpoolP512r1&quot;, NULL, &quot;Brainpool P-512&quot;,  MY_USE_ECDSADH,  1, 1, 0 },
<span class="lineNum">    2240 </span>            :     { &quot;secp256k1&quot;,       NULL, NULL,               MY_USE_ECDSADH,  0, 1, 0 },
<span class="lineNum">    2241 </span>            :   };
<span class="lineNum">    2242 </span>            : #undef MY_USE_ECDSADH
<span class="lineNum">    2243 </span>            :   int idx;
<span class="lineNum">    2244 </span>            :   char *answer;
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :   char *result = NULL;</span>
<span class="lineNum">    2246 </span>            :   gcry_sexp_t keyparms;
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :   tty_printf (_(&quot;Please select which elliptic curve you want:\n&quot;));</span>
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :   keyparms = NULL;</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :   for (idx=0; idx &lt; DIM(curves); idx++)</span>
<span class="lineNum">    2252 </span>            :     {
<span class="lineNum">    2253 </span>            :       int rc;
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :       curves[idx].available = 0;</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :       if (!curves[idx].supported)</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :       if (opt.compliance==CO_DE_VS)</span>
<span class="lineNum">    2260 </span>            :         {
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :           if (!curves[idx].de_vs)</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :             continue; /* Not allowed.  */</span>
<span class="lineNum">    2263 </span>            :         }
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :       else if (!opt.expert &amp;&amp; curves[idx].expert_only)</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2266 </span>            : 
<span class="lineNum">    2267 </span>            :       /* We need to switch from the ECDH name of the curve to the
<span class="lineNum">    2268 </span>            :          EDDSA name of the curve if we want a signing key.  */
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :       gcry_sexp_release (keyparms);</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :       rc = gcry_sexp_build (&amp;keyparms, NULL,</span>
<span class="lineNum">    2271 </span>            :                             &quot;(public-key(ecc(curve %s)))&quot;,
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :                             curves[idx].eddsa_curve? curves[idx].eddsa_curve</span>
<span class="lineNum">    2273 </span>            :                             /**/                   : curves[idx].name);
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :       if (rc)</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :       if (!gcry_pk_get_curve (keyparms, 0, NULL))</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :       if (subkey_algo &amp;&amp; curves[idx].eddsa_curve)</span>
<span class="lineNum">    2279 </span>            :         {
<span class="lineNum">    2280 </span>            :           /* Both Curve 25519 (or 448) keys are to be created.  Check that
<span class="lineNum">    2281 </span>            :              Libgcrypt also supports the real Curve25519 (or 448).  */
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :           gcry_sexp_release (keyparms);</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :           rc = gcry_sexp_build (&amp;keyparms, NULL,</span>
<span class="lineNum">    2284 </span>            :                                 &quot;(public-key(ecc(curve %s)))&quot;,
<span class="lineNum">    2285 </span>            :                                  curves[idx].name);
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :           if (rc)</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :           if (!gcry_pk_get_curve (keyparms, 0, NULL))</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2290 </span>            :         }
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :       curves[idx].available = 1;</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :       tty_printf (&quot;   (%d) %s\n&quot;, idx + 1,</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :                   curves[idx].pretty_name?</span>
<span class="lineNum">    2295 </span>            :                   curves[idx].pretty_name:curves[idx].name);
<span class="lineNum">    2296 </span>            :     }
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :   gcry_sexp_release (keyparms);</span>
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span>            :   for (;;)
<span class="lineNum">    2301 </span>            :     {
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :       answer = cpr_get (&quot;keygen.curve&quot;, _(&quot;Your selection? &quot;));</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :       cpr_kill_prompt ();</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :       idx = *answer? atoi (answer) : 1;</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :       if (*answer &amp;&amp; !idx)</span>
<span class="lineNum">    2306 </span>            :         {
<span class="lineNum">    2307 </span>            :           /* See whether the user entered the name of the curve.  */
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :           for (idx=0; idx &lt; DIM(curves); idx++)</span>
<span class="lineNum">    2309 </span>            :             {
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :               if (!opt.expert &amp;&amp; curves[idx].expert_only)</span>
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :               if (!stricmp (curves[idx].name, answer)</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :                   || (curves[idx].pretty_name</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :                       &amp;&amp; !stricmp (curves[idx].pretty_name, answer)))</span>
<span class="lineNum">    2315 </span>            :                 break;
<span class="lineNum">    2316 </span>            :             }
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :           if (idx == DIM(curves))</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :             idx = -1;</span>
<span class="lineNum">    2319 </span>            :         }
<span class="lineNum">    2320 </span>            :       else
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :         idx--;</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :       xfree(answer);</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :       answer = NULL;</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :       if (idx &lt; 0 || idx &gt;= DIM (curves) || !curves[idx].available)</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;Invalid selection.\n&quot;));</span>
<span class="lineNum">    2326 </span>            :       else
<span class="lineNum">    2327 </span>            :         {
<span class="lineNum">    2328 </span>            :           /* If the user selected a signing algorithm and Curve25519
<span class="lineNum">    2329 </span>            :              we need to set the algo to EdDSA and update the curve name. */
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :           if ((*algo == PUBKEY_ALGO_ECDSA || *algo == PUBKEY_ALGO_EDDSA)</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :               &amp;&amp; curves[idx].eddsa_curve)</span>
<span class="lineNum">    2332 </span>            :             {
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :               if (subkey_algo &amp;&amp; *subkey_algo == PUBKEY_ALGO_ECDSA)</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :                 *subkey_algo = PUBKEY_ALGO_EDDSA;</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :               *algo = PUBKEY_ALGO_EDDSA;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :               result = xstrdup (curves[idx].eddsa_curve);</span>
<span class="lineNum">    2337 </span>            :             }
<span class="lineNum">    2338 </span>            :           else
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :             result = xstrdup (curves[idx].name);</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2341 </span>            :         }
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2343 </span>            : 
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :   if (!result)</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :     result = xstrdup (curves[0].name);</span>
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    2348 </span>            : }
<span class="lineNum">    2349 </span>            : 
<span class="lineNum">    2350 </span>            : 
<span class="lineNum">    2351 </span>            : /****************
<span class="lineNum">    2352 </span>            :  * Parse an expire string and return its value in seconds.
<span class="lineNum">    2353 </span>            :  * Returns (u32)-1 on error.
<span class="lineNum">    2354 </span>            :  * This isn't perfect since scan_isodatestr returns unix time, and
<span class="lineNum">    2355 </span>            :  * OpenPGP actually allows a 32-bit time *plus* a 32-bit offset.
<span class="lineNum">    2356 </span>            :  * Because of this, we only permit setting expirations up to 2106, but
<span class="lineNum">    2357 </span>            :  * OpenPGP could theoretically allow up to 2242.  I think we'll all
<span class="lineNum">    2358 </span>            :  * just cope for the next few years until we get a 64-bit time_t or
<span class="lineNum">    2359 </span>            :  * similar.
<a name="2360"><span class="lineNum">    2360 </span>            :  */</a>
<span class="lineNum">    2361 </span>            : u32
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 : parse_expire_string( const char *string )</span>
<span class="lineNum">    2363 </span>            : {
<span class="lineNum">    2364 </span>            :   int mult;
<span class="lineNum">    2365 </span>            :   u32 seconds;
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :   u32 abs_date = 0;</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :   u32 curtime = make_timestamp ();</span>
<span class="lineNum">    2368 </span>            :   time_t tt;
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   if (!string || !*string || !strcmp (string, &quot;none&quot;)</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :       || !strcmp (string, &quot;never&quot;) || !strcmp (string, &quot;-&quot;))</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :     seconds = 0;</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :   else if (!strncmp (string, &quot;seconds=&quot;, 8))</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :     seconds = atoi (string+8);</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :   else if ((abs_date = scan_isodatestr(string))</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :            &amp;&amp; (abs_date+86400/2) &gt; curtime)</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :     seconds = (abs_date+86400/2) - curtime;</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :   else if ((tt = isotime2epoch (string)) != (time_t)(-1))</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :     seconds = (u32)tt - curtime;</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :   else if ((mult = check_valid_days (string)))</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :     seconds = atoi (string) * 86400L * mult;</span>
<span class="lineNum">    2382 </span>            :   else
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :     seconds = (u32)(-1);</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :   return seconds;</span>
<span class="lineNum">    2386 </span>            : }
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            : /* Parse a Creation-Date string which is either &quot;1986-04-26&quot; or
<a name="2389"><span class="lineNum">    2389 </span>            :    &quot;19860426T042640&quot;.  Returns 0 on error. */</a>
<span class="lineNum">    2390 </span>            : static u32
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 : parse_creation_string (const char *string)</span>
<span class="lineNum">    2392 </span>            : {
<span class="lineNum">    2393 </span>            :   u32 seconds;
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :   if (!*string)</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :     seconds = 0;</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :   else if ( !strncmp (string, &quot;seconds=&quot;, 8) )</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     seconds = atoi (string+8);</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :   else if ( !(seconds = scan_isodatestr (string)))</span>
<span class="lineNum">    2400 </span>            :     {
<span class="lineNum">    2401 </span><span class="lineNoCov">          0 :       time_t tmp = isotime2epoch (string);</span>
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :       seconds = (tmp == (time_t)(-1))? 0 : tmp;</span>
<span class="lineNum">    2403 </span>            :     }
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :   return seconds;</span>
<span class="lineNum">    2405 </span>            : }
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span>            : 
<a name="2408"><span class="lineNum">    2408 </span>            : /* object == 0 for a key, and 1 for a sig */</a>
<span class="lineNum">    2409 </span>            : u32
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 : ask_expire_interval(int object,const char *def_expire)</span>
<span class="lineNum">    2411 </span>            : {
<span class="lineNum">    2412 </span>            :     u32 interval;
<span class="lineNum">    2413 </span>            :     char *answer;
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :     switch(object)</span>
<span class="lineNum">    2416 </span>            :       {
<span class="lineNum">    2417 </span>            :       case 0:
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :         if(def_expire)</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :           BUG();</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;Please specify how long the key should be valid.\n&quot;</span>
<span class="lineNum">    2421 </span>            :                      &quot;         0 = key does not expire\n&quot;
<span class="lineNum">    2422 </span>            :                      &quot;      &lt;n&gt;  = key expires in n days\n&quot;
<span class="lineNum">    2423 </span>            :                      &quot;      &lt;n&gt;w = key expires in n weeks\n&quot;
<span class="lineNum">    2424 </span>            :                      &quot;      &lt;n&gt;m = key expires in n months\n&quot;
<span class="lineNum">    2425 </span>            :                      &quot;      &lt;n&gt;y = key expires in n years\n&quot;));
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span>            :       case 1:
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :         if(!def_expire)</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :           BUG();</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;Please specify how long the signature should be valid.\n&quot;</span>
<span class="lineNum">    2432 </span>            :                      &quot;         0 = signature does not expire\n&quot;
<span class="lineNum">    2433 </span>            :                      &quot;      &lt;n&gt;  = signature expires in n days\n&quot;
<span class="lineNum">    2434 </span>            :                      &quot;      &lt;n&gt;w = signature expires in n weeks\n&quot;
<span class="lineNum">    2435 </span>            :                      &quot;      &lt;n&gt;m = signature expires in n months\n&quot;
<span class="lineNum">    2436 </span>            :                      &quot;      &lt;n&gt;y = signature expires in n years\n&quot;));
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2438 </span>            : 
<span class="lineNum">    2439 </span>            :       default:
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :         BUG();</span>
<span class="lineNum">    2441 </span>            :       }
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            :     /* Note: The elgamal subkey for DSA has no expiration date because
<span class="lineNum">    2444 </span>            :      * it must be signed with the DSA key and this one has the expiration
<span class="lineNum">    2445 </span>            :      * date */
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     answer = NULL;</span>
<span class="lineNum">    2448 </span>            :     for(;;)
<span class="lineNum">    2449 </span>            :       {
<span class="lineNum">    2450 </span>            :         u32 curtime;
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :         xfree(answer);</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :         if(object==0)</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :           answer = cpr_get(&quot;keygen.valid&quot;,_(&quot;Key is valid for? (0) &quot;));</span>
<span class="lineNum">    2455 </span>            :         else
<span class="lineNum">    2456 </span>            :           {
<span class="lineNum">    2457 </span>            :             char *prompt;
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :             prompt = xasprintf (_(&quot;Signature is valid for? (%s) &quot;), def_expire);</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :             answer = cpr_get(&quot;siggen.valid&quot;,prompt);</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :             xfree(prompt);</span>
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :             if(*answer=='\0')</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :               answer=xstrdup(def_expire);</span>
<span class="lineNum">    2465 </span>            :           }
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :         cpr_kill_prompt();</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :         trim_spaces(answer);</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :         curtime = make_timestamp ();</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :         interval = parse_expire_string( answer );</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :         if( interval == (u32)-1 )</span>
<span class="lineNum">    2471 </span>            :           {
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;invalid value\n&quot;));</span>
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2474 </span>            :           }
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :         if( !interval )</span>
<span class="lineNum">    2477 </span>            :           {
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :             tty_printf((object==0)</span>
<span class="lineNum">    2479 </span>            :                        ? _(&quot;Key does not expire at all\n&quot;)
<span class="lineNum">    2480 </span>            :                        : _(&quot;Signature does not expire at all\n&quot;));
<span class="lineNum">    2481 </span>            :           }
<span class="lineNum">    2482 </span>            :         else
<span class="lineNum">    2483 </span>            :           {
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :             tty_printf(object==0</span>
<span class="lineNum">    2485 </span>            :                        ? _(&quot;Key expires at %s\n&quot;)
<span class="lineNum">    2486 </span>            :                        : _(&quot;Signature expires at %s\n&quot;),
<span class="lineNum">    2487 </span>            :                        asctimestamp((ulong)(curtime + interval) ) );
<span class="lineNum">    2488 </span>            : #if SIZEOF_TIME_T &lt;= 4 &amp;&amp; !defined (HAVE_UNSIGNED_TIME_T)
<span class="lineNum">    2489 </span>            :             if ( (time_t)((ulong)(curtime+interval)) &lt; 0 )
<span class="lineNum">    2490 </span>            :               tty_printf (_(&quot;Your system can't display dates beyond 2038.\n&quot;
<span class="lineNum">    2491 </span>            :                             &quot;However, it will be correctly handled up to&quot;
<span class="lineNum">    2492 </span>            :                             &quot; 2106.\n&quot;));
<span class="lineNum">    2493 </span>            :             else
<span class="lineNum">    2494 </span>            : #endif /*SIZEOF_TIME_T*/
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :               if ( (time_t)((unsigned long)(curtime+interval)) &lt; curtime )</span>
<span class="lineNum">    2496 </span>            :                 {
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :                   tty_printf (_(&quot;invalid value\n&quot;));</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :                   continue;</span>
<span class="lineNum">    2499 </span>            :                 }
<span class="lineNum">    2500 </span>            :           }
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :         if( cpr_enabled() || cpr_get_answer_is_yes(&quot;keygen.valid.okay&quot;,</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                                                    _(&quot;Is this correct? (y/N) &quot;)) )</span>
<span class="lineNum">    2504 </span>            :           break;
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :       }</span>
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :     xfree(answer);</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :     return interval;</span>
<span class="lineNum">    2509 </span>            : }
<a name="2510"><span class="lineNum">    2510 </span>            : </a>
<span class="lineNum">    2511 </span>            : u32
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 : ask_expiredate()</span>
<span class="lineNum">    2513 </span>            : {
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :     u32 x = ask_expire_interval(0,NULL);</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :     return x? make_timestamp() + x : 0;</span>
<span class="lineNum">    2516 </span>            : }
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span>            : 
<a name="2519"><span class="lineNum">    2519 </span>            : </a>
<span class="lineNum">    2520 </span>            : static PKT_user_id *
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 : uid_from_string (const char *string)</span>
<span class="lineNum">    2522 </span>            : {
<span class="lineNum">    2523 </span>            :   size_t n;
<span class="lineNum">    2524 </span>            :   PKT_user_id *uid;
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :   n = strlen (string);</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :   uid = xmalloc_clear (sizeof *uid + n);</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :   uid-&gt;len = n;</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :   strcpy (uid-&gt;name, string);</span>
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :   uid-&gt;ref = 1;</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :   return uid;</span>
<span class="lineNum">    2532 </span>            : }
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span>            : 
<a name="2535"><span class="lineNum">    2535 </span>            : /* Return true if the user id UID already exists in the keyblock.  */</a>
<span class="lineNum">    2536 </span>            : static int
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 : uid_already_in_keyblock (kbnode_t keyblock, const char *uid)</span>
<span class="lineNum">    2538 </span>            : {
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :   PKT_user_id *uidpkt = uid_from_string (uid);</span>
<span class="lineNum">    2540 </span>            :   kbnode_t node;
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :   int result = 0;</span>
<span class="lineNum">    2542 </span>            : 
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :   for (node=keyblock; node &amp;&amp; !result; node=node-&gt;next)</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :     if (!is_deleted_kbnode (node)</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :         &amp;&amp; node-&gt;pkt-&gt;pkttype == PKT_USER_ID</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :         &amp;&amp; !cmp_user_ids (uidpkt, node-&gt;pkt-&gt;pkt.user_id))</span>
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :       result = 1;</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   free_user_id (uidpkt);</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    2550 </span>            : }
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            : 
<span class="lineNum">    2553 </span>            : /* Ask for a user ID.  With a MODE of 1 an extra help prompt is
<span class="lineNum">    2554 </span>            :    printed for use during a new key creation.  If KEYBLOCK is not NULL
<span class="lineNum">    2555 </span>            :    the function prevents the creation of an already existing user
<a name="2556"><span class="lineNum">    2556 </span>            :    ID.  IF FULL is not set some prompts are not shown.  */</a>
<span class="lineNum">    2557 </span>            : static char *
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 : ask_user_id (int mode, int full, KBNODE keyblock)</span>
<span class="lineNum">    2559 </span>            : {
<span class="lineNum">    2560 </span>            :     char *answer;
<span class="lineNum">    2561 </span>            :     char *aname, *acomment, *amail, *uid;
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :     if ( !mode )</span>
<span class="lineNum">    2564 </span>            :       {
<span class="lineNum">    2565 </span>            :         /* TRANSLATORS: This is the new string telling the user what
<span class="lineNum">    2566 </span>            :            gpg is now going to do (i.e. ask for the parts of the user
<span class="lineNum">    2567 </span>            :            ID).  Note that if you do not translate this string, a
<span class="lineNum">    2568 </span>            :            different string will be used, which might still have
<span class="lineNum">    2569 </span>            :            a correct translation.  */
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :         const char *s1 =</span>
<span class="lineNum">    2571 </span>            :           N_(&quot;\n&quot;
<span class="lineNum">    2572 </span>            :              &quot;GnuPG needs to construct a user ID to identify your key.\n&quot;
<span class="lineNum">    2573 </span>            :              &quot;\n&quot;);
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :         const char *s2 = _(s1);</span>
<span class="lineNum">    2575 </span>            : 
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :         if (!strcmp (s1, s2))</span>
<span class="lineNum">    2577 </span>            :           {
<span class="lineNum">    2578 </span>            :             /* There is no translation for the string thus we to use
<span class="lineNum">    2579 </span>            :                the old info text.  gettext has no way to tell whether
<span class="lineNum">    2580 </span>            :                a translation is actually available, thus we need to
<span class="lineNum">    2581 </span>            :                to compare again. */
<span class="lineNum">    2582 </span>            :             /* TRANSLATORS: This string is in general not anymore used
<span class="lineNum">    2583 </span>            :                but you should keep your existing translation.  In case
<span class="lineNum">    2584 </span>            :                the new string is not translated this old string will
<span class="lineNum">    2585 </span>            :                be used. */
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :             const char *s3 = N_(&quot;\n&quot;</span>
<span class="lineNum">    2587 </span>            : &quot;You need a user ID to identify your key; &quot;
<span class="lineNum">    2588 </span>            :                                         &quot;the software constructs the user ID\n&quot;
<span class="lineNum">    2589 </span>            : &quot;from the Real Name, Comment and Email Address in this form:\n&quot;
<span class="lineNum">    2590 </span>            : &quot;    \&quot;Heinrich Heine (Der Dichter) &lt;heinrichh@duesseldorf.de&gt;\&quot;\n\n&quot;);
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :             const char *s4 = _(s3);</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :             if (strcmp (s3, s4))</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :               s2 = s3; /* A translation exists - use it. */</span>
<span class="lineNum">    2594 </span>            :           }
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :         tty_printf (&quot;%s&quot;, s2) ;</span>
<span class="lineNum">    2596 </span>            :       }
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :     uid = aname = acomment = amail = NULL;</span>
<span class="lineNum">    2598 </span>            :     for(;;) {
<span class="lineNum">    2599 </span>            :         char *p;
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :         int fail=0;</span>
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :         if( !aname ) {</span>
<span class="lineNum">    2603 </span>            :             for(;;) {
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :                 xfree(aname);</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :                 aname = cpr_get(&quot;keygen.name&quot;,_(&quot;Real name: &quot;));</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :                 trim_spaces(aname);</span>
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :                 cpr_kill_prompt();</span>
<span class="lineNum">    2608 </span>            : 
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :                 if( opt.allow_freeform_uid )</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :                 if( strpbrk( aname, &quot;&lt;&gt;&quot; ) )</span>
<span class="lineNum">    2613 </span>            :                   {
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Invalid character in name\n&quot;));</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;The characters '%s' and '%s' may not &quot;</span>
<span class="lineNum">    2616 </span>            :                                  &quot;appear in name\n&quot;), &quot;&lt;&quot;, &quot;&gt;&quot;);
<span class="lineNum">    2617 </span>            :                   }
<span class="lineNum">    2618 </span><span class="lineNoCov">          0 :                 else if( digitp(aname) )</span>
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Name may not start with a digit\n&quot;));</span>
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :                 else if (*aname &amp;&amp; strlen (aname) &lt; 5)</span>
<span class="lineNum">    2621 </span>            :                   {
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Name must be at least 5 characters long\n&quot;));</span>
<span class="lineNum">    2623 </span>            :                     /* However, we allow an empty name.  */
<span class="lineNum">    2624 </span>            :                   }
<span class="lineNum">    2625 </span>            :                 else
<span class="lineNum">    2626 </span>            :                     break;
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2628 </span>            :         }
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :         if( !amail ) {</span>
<span class="lineNum">    2630 </span>            :             for(;;) {
<span class="lineNum">    2631 </span><span class="lineNoCov">          0 :                 xfree(amail);</span>
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :                 amail = cpr_get(&quot;keygen.email&quot;,_(&quot;Email address: &quot;));</span>
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :                 trim_spaces(amail);</span>
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :                 cpr_kill_prompt();</span>
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :                 if( !*amail || opt.allow_freeform_uid )</span>
<span class="lineNum">    2636 </span>            :                     break;   /* no email address is okay */
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :                 else if ( !is_valid_mailbox (amail) )</span>
<span class="lineNum">    2638 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Not a valid email address\n&quot;));</span>
<span class="lineNum">    2639 </span>            :                 else
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2642 </span>            :         }
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :         if (!acomment) {</span>
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :           if (full) {</span>
<span class="lineNum">    2645 </span>            :             for(;;) {
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :                 xfree(acomment);</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :                 acomment = cpr_get(&quot;keygen.comment&quot;,_(&quot;Comment: &quot;));</span>
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :                 trim_spaces(acomment);</span>
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :                 cpr_kill_prompt();</span>
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 :                 if( !*acomment )</span>
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :                     break;   /* no comment is okay */</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :                 else if( strpbrk( acomment, &quot;()&quot; ) )</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Invalid character in comment\n&quot;));</span>
<span class="lineNum">    2654 </span>            :                 else
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    2657 </span>            :           }
<span class="lineNum">    2658 </span>            :           else {
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :             xfree (acomment);</span>
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :             acomment = xstrdup (&quot;&quot;);</span>
<span class="lineNum">    2661 </span>            :           }
<span class="lineNum">    2662 </span>            :         }
<span class="lineNum">    2663 </span>            : 
<span class="lineNum">    2664 </span>            : 
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :         xfree(uid);</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :         uid = p = xmalloc(strlen(aname)+strlen(amail)+strlen(acomment)+12+10);</span>
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :         if (!*aname &amp;&amp; *amail &amp;&amp; !*acomment &amp;&amp; !random_is_faked ())</span>
<span class="lineNum">    2668 </span>            :           { /* Empty name and comment but with mail address.  Use
<span class="lineNum">    2669 </span>            :                simplified form with only the non-angle-bracketed mail
<span class="lineNum">    2670 </span>            :                address.  */
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :             p = stpcpy (p, amail);</span>
<span class="lineNum">    2672 </span>            :           }
<span class="lineNum">    2673 </span>            :         else
<span class="lineNum">    2674 </span>            :           {
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :             p = stpcpy (p, aname );</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :             if (*acomment)</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :               p = stpcpy(stpcpy(stpcpy(p,&quot; (&quot;), acomment),&quot;)&quot;);</span>
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :             if (*amail)</span>
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :               p = stpcpy(stpcpy(stpcpy(p,&quot; &lt;&quot;), amail),&quot;&gt;&quot;);</span>
<span class="lineNum">    2680 </span>            :           }
<span class="lineNum">    2681 </span>            : 
<span class="lineNum">    2682 </span>            :         /* Append a warning if the RNG is switched into fake mode.  */
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :         if ( random_is_faked ()  )</span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :           strcpy(p, &quot; (insecure!)&quot; );</span>
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span>            :         /* print a note in case that UTF8 mapping has to be done */
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :         for(p=uid; *p; p++ ) {</span>
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :             if( *p &amp; 0x80 ) {</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :                 tty_printf(_(&quot;You are using the '%s' character set.\n&quot;),</span>
<span class="lineNum">    2690 </span>            :                            get_native_charset() );
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2692 </span>            :             }
<span class="lineNum">    2693 </span>            :         }
<span class="lineNum">    2694 </span>            : 
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :         tty_printf(_(&quot;You selected this USER-ID:\n    \&quot;%s\&quot;\n\n&quot;), uid);</span>
<span class="lineNum">    2696 </span>            : 
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :         if( !*amail &amp;&amp; !opt.allow_freeform_uid</span>
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :             &amp;&amp; (strchr( aname, '@' ) || strchr( acomment, '@'))) {</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :             fail = 1;</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :             tty_printf(_(&quot;Please don't put the email address &quot;</span>
<span class="lineNum">    2701 </span>            :                          &quot;into the real name or the comment\n&quot;) );
<span class="lineNum">    2702 </span>            :         }
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :         if (!fail &amp;&amp; keyblock)</span>
<span class="lineNum">    2705 </span>            :           {
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :             if (uid_already_in_keyblock (keyblock, uid))</span>
<span class="lineNum">    2707 </span>            :               {
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :                 tty_printf (_(&quot;Such a user ID already exists on this key!\n&quot;));</span>
<span class="lineNum">    2709 </span><span class="lineNoCov">          0 :                 fail = 1;</span>
<span class="lineNum">    2710 </span>            :               }
<span class="lineNum">    2711 </span>            :           }
<span class="lineNum">    2712 </span>            : 
<span class="lineNum">    2713 </span>            :         for(;;) {
<span class="lineNum">    2714 </span>            :             /* TRANSLATORS: These are the allowed answers in
<span class="lineNum">    2715 </span>            :                lower and uppercase.  Below you will find the matching
<span class="lineNum">    2716 </span>            :                string which should be translated accordingly and the
<span class="lineNum">    2717 </span>            :                letter changed to match the one in the answer string.
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            :                  n = Change name
<span class="lineNum">    2720 </span>            :                  c = Change comment
<span class="lineNum">    2721 </span>            :                  e = Change email
<span class="lineNum">    2722 </span>            :                  o = Okay (ready, continue)
<span class="lineNum">    2723 </span>            :                  q = Quit
<span class="lineNum">    2724 </span>            :              */
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :             const char *ansstr = _(&quot;NnCcEeOoQq&quot;);</span>
<span class="lineNum">    2726 </span>            : 
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :             if( strlen(ansstr) != 10 )</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :                 BUG();</span>
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :             if( cpr_enabled() ) {</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :                 answer = xstrdup (ansstr + (fail?8:6));</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :                 answer[1] = 0;</span>
<span class="lineNum">    2732 </span>            :             }
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :             else if (full) {</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :                 answer = cpr_get(&quot;keygen.userid.cmd&quot;, fail?</span>
<span class="lineNum">    2735 </span>            :                   _(&quot;Change (N)ame, (C)omment, (E)mail or (Q)uit? &quot;) :
<span class="lineNum">    2736 </span>            :                   _(&quot;Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? &quot;));
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :                 cpr_kill_prompt();</span>
<span class="lineNum">    2738 </span>            :             }
<span class="lineNum">    2739 </span>            :             else {
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :                 answer = cpr_get(&quot;keygen.userid.cmd&quot;, fail?</span>
<span class="lineNum">    2741 </span>            :                   _(&quot;Change (N)ame, (E)mail, or (Q)uit? &quot;) :
<span class="lineNum">    2742 </span>            :                   _(&quot;Change (N)ame, (E)mail, or (O)kay/(Q)uit? &quot;));
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :                 cpr_kill_prompt();</span>
<span class="lineNum">    2744 </span>            :             }
<span class="lineNum">    2745 </span><span class="lineNoCov">          0 :             if( strlen(answer) &gt; 1 )</span>
<span class="lineNum">    2746 </span>            :                 ;
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :             else if( *answer == ansstr[0] || *answer == ansstr[1] ) {</span>
<span class="lineNum">    2748 </span><span class="lineNoCov">          0 :                 xfree(aname); aname = NULL;</span>
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2750 </span>            :             }
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :             else if( *answer == ansstr[2] || *answer == ansstr[3] ) {</span>
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :                 xfree(acomment); acomment = NULL;</span>
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2754 </span>            :             }
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :             else if( *answer == ansstr[4] || *answer == ansstr[5] ) {</span>
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :                 xfree(amail); amail = NULL;</span>
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2758 </span>            :             }
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :             else if( *answer == ansstr[6] || *answer == ansstr[7] ) {</span>
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :                 if( fail ) {</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :                     tty_printf(_(&quot;Please correct the error first\n&quot;));</span>
<span class="lineNum">    2762 </span>            :                 }
<span class="lineNum">    2763 </span>            :                 else {
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :                     xfree(aname); aname = NULL;</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :                     xfree(acomment); acomment = NULL;</span>
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :                     xfree(amail); amail = NULL;</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2768 </span>            :                 }
<span class="lineNum">    2769 </span>            :             }
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :             else if( *answer == ansstr[8] || *answer == ansstr[9] ) {</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :                 xfree(aname); aname = NULL;</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :                 xfree(acomment); acomment = NULL;</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :                 xfree(amail); amail = NULL;</span>
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :                 xfree(uid); uid = NULL;</span>
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2776 </span>            :             }
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :             xfree(answer);</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :         xfree(answer);</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :         if (!amail &amp;&amp; !acomment)</span>
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :         xfree(uid); uid = NULL;</span>
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :     if( uid ) {</span>
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :         char *p = native_to_utf8( uid );</span>
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :         xfree( uid );</span>
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :         uid = p;</span>
<span class="lineNum">    2788 </span>            :     }
<span class="lineNum">    2789 </span><span class="lineNoCov">          0 :     return uid;</span>
<span class="lineNum">    2790 </span>            : }
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span>            : 
<span class="lineNum">    2793 </span>            : /* Basic key generation.  Here we divert to the actual generation
<a name="2794"><span class="lineNum">    2794 </span>            :    routines based on the requested algorithm.  */</a>
<span class="lineNum">    2795 </span>            : static int
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 : do_create (int algo, unsigned int nbits, const char *curve, KBNODE pub_root,</span>
<span class="lineNum">    2797 </span>            :            u32 timestamp, u32 expiredate, int is_subkey,
<span class="lineNum">    2798 </span>            :            int keygen_flags, const char *passphrase,
<span class="lineNum">    2799 </span>            :            char **cache_nonce_addr, char **passwd_nonce_addr)
<span class="lineNum">    2800 </span>            : {
<span class="lineNum">    2801 </span>            :   gpg_error_t err;
<span class="lineNum">    2802 </span>            : 
<span class="lineNum">    2803 </span>            :   /* Fixme: The entropy collecting message should be moved to a
<span class="lineNum">    2804 </span>            :      libgcrypt progress handler.  */
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :   if (!opt.batch)</span>
<span class="lineNum">    2806 </span><span class="lineNoCov">          0 :     tty_printf (_(</span>
<span class="lineNum">    2807 </span>            : &quot;We need to generate a lot of random bytes. It is a good idea to perform\n&quot;
<span class="lineNum">    2808 </span>            : &quot;some other action (type on the keyboard, move the mouse, utilize the\n&quot;
<span class="lineNum">    2809 </span>            : &quot;disks) during the prime generation; this gives the random number\n&quot;
<span class="lineNum">    2810 </span>            : &quot;generator a better chance to gain enough entropy.\n&quot;) );
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_ELGAMAL_E)</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :     err = gen_elg (algo, nbits, pub_root, timestamp, expiredate, is_subkey,</span>
<span class="lineNum">    2814 </span>            :                    keygen_flags, passphrase,
<span class="lineNum">    2815 </span>            :                    cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_DSA)</span>
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :     err = gen_dsa (nbits, pub_root, timestamp, expiredate, is_subkey,</span>
<span class="lineNum">    2818 </span>            :                    keygen_flags, passphrase,
<span class="lineNum">    2819 </span>            :                    cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    2820 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :            || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :            || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 :     err = gen_ecc (algo, curve, pub_root, timestamp, expiredate, is_subkey,</span>
<span class="lineNum">    2824 </span>            :                    keygen_flags, passphrase,
<span class="lineNum">    2825 </span>            :                    cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_RSA)</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :     err = gen_rsa (algo, nbits, pub_root, timestamp, expiredate, is_subkey,</span>
<span class="lineNum">    2828 </span>            :                    keygen_flags, passphrase,
<span class="lineNum">    2829 </span>            :                    cache_nonce_addr, passwd_nonce_addr);
<span class="lineNum">    2830 </span>            :   else
<span class="lineNum">    2831 </span><span class="lineNoCov">          0 :     BUG();</span>
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    2834 </span>            : }
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            : /* Generate a new user id packet or return NULL if canceled.  If
<span class="lineNum">    2838 </span>            :    KEYBLOCK is not NULL the function prevents the creation of an
<span class="lineNum">    2839 </span>            :    already existing user ID.  If UIDSTR is not NULL the user is not
<span class="lineNum">    2840 </span>            :    asked but UIDSTR is used to create the user id packet; if the user
<span class="lineNum">    2841 </span>            :    id already exists NULL is returned.  UIDSTR is expected to be utf-8
<span class="lineNum">    2842 </span>            :    encoded and should have already been checked for a valid length
<a name="2843"><span class="lineNum">    2843 </span>            :    etc.  */</a>
<span class="lineNum">    2844 </span>            : PKT_user_id *
<span class="lineNum">    2845 </span><span class="lineNoCov">          0 : generate_user_id (KBNODE keyblock, const char *uidstr)</span>
<span class="lineNum">    2846 </span>            : {
<span class="lineNum">    2847 </span>            :   PKT_user_id *uid;
<span class="lineNum">    2848 </span>            :   char *p;
<span class="lineNum">    2849 </span>            : 
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :   if (uidstr)</span>
<span class="lineNum">    2851 </span>            :     {
<span class="lineNum">    2852 </span><span class="lineNoCov">          0 :       if (uid_already_in_keyblock (keyblock, uidstr))</span>
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :         return NULL;  /* Already exists.  */</span>
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :       uid = uid_from_string (uidstr);</span>
<span class="lineNum">    2855 </span>            :     }
<span class="lineNum">    2856 </span>            :   else
<span class="lineNum">    2857 </span>            :     {
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :       p = ask_user_id (1, 1, keyblock);</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :       if (!p)</span>
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :         return NULL;  /* Canceled. */</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :       uid = uid_from_string (p);</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :       xfree (p);</span>
<span class="lineNum">    2863 </span>            :     }
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :   return uid;</span>
<span class="lineNum">    2865 </span>            : }
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span>            : 
<span class="lineNum">    2868 </span>            : /* Helper for parse_key_parameter_string for one part of the
<span class="lineNum">    2869 </span>            :  * specification string; i.e.  ALGO/FLAGS.  If STRING is NULL or empty
<span class="lineNum">    2870 </span>            :  * success is returned.  On error an error code is returned.  Note
<span class="lineNum">    2871 </span>            :  * that STRING may be modified by this function.  NULL may be passed
<span class="lineNum">    2872 </span>            :  * for any parameter.  FOR_SUBKEY shall be true if this is used as a
<a name="2873"><span class="lineNum">    2873 </span>            :  * subkey.  */</a>
<span class="lineNum">    2874 </span>            : static gpg_error_t
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 : parse_key_parameter_part (char *string, int for_subkey,</span>
<span class="lineNum">    2876 </span>            :                           int *r_algo, unsigned int *r_size,
<span class="lineNum">    2877 </span>            :                           unsigned int *r_keyuse,
<span class="lineNum">    2878 </span>            :                           char const **r_curve)
<span class="lineNum">    2879 </span>            : {
<span class="lineNum">    2880 </span>            :   char *flags;
<span class="lineNum">    2881 </span>            :   int algo;
<span class="lineNum">    2882 </span>            :   char *endp;
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :   const char *curve = NULL;</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :   int ecdh_or_ecdsa = 0;</span>
<span class="lineNum">    2885 </span>            :   unsigned int size;
<span class="lineNum">    2886 </span>            :   int keyuse;
<span class="lineNum">    2887 </span>            :   int i;
<span class="lineNum">    2888 </span>            :   const char *s;
<span class="lineNum">    2889 </span>            : 
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :   if (!string || !*string)</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :     return 0; /* Success.  */</span>
<span class="lineNum">    2892 </span>            : 
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :   flags = strchr (string, '/');</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :   if (flags)</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :     *flags++ = 0;</span>
<span class="lineNum">    2896 </span>            : 
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :   algo = 0;</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :   if (strlen (string) &gt;= 3 &amp;&amp; (digitp (string+3) || !string[3]))</span>
<span class="lineNum">    2899 </span>            :     {
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :       if (!ascii_memcasecmp (string, &quot;rsa&quot;, 3))</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :         algo = PUBKEY_ALGO_RSA;</span>
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :       else if (!ascii_memcasecmp (string, &quot;dsa&quot;, 3))</span>
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :         algo = PUBKEY_ALGO_DSA;</span>
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :       else if (!ascii_memcasecmp (string, &quot;elg&quot;, 3))</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :         algo = PUBKEY_ALGO_ELGAMAL_E;</span>
<span class="lineNum">    2906 </span>            :     }
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :   if (algo)</span>
<span class="lineNum">    2908 </span>            :     {
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :       if (!string[3])</span>
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :         size = get_keysize_range (algo, NULL, NULL);</span>
<span class="lineNum">    2911 </span>            :       else
<span class="lineNum">    2912 </span>            :         {
<span class="lineNum">    2913 </span><span class="lineNoCov">          0 :           size = strtoul (string+3, &amp;endp, 10);</span>
<span class="lineNum">    2914 </span><span class="lineNoCov">          0 :           if (size &lt; 512 || size &gt; 16384 || *endp)</span>
<span class="lineNum">    2915 </span><span class="lineNoCov">          0 :             return gpg_error (GPG_ERR_INV_VALUE);</span>
<span class="lineNum">    2916 </span>            :         }
<span class="lineNum">    2917 </span>            :     }
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :   else if ((curve = openpgp_is_curve_supported (string, &amp;algo, &amp;size)))</span>
<span class="lineNum">    2919 </span>            :     {
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :       if (!algo)</span>
<span class="lineNum">    2921 </span>            :         {
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :           algo = PUBKEY_ALGO_ECDH; /* Default ECC algorithm.  */</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :           ecdh_or_ecdsa = 1;       /* We may need to switch the algo.  */</span>
<span class="lineNum">    2924 </span>            :         }
<span class="lineNum">    2925 </span>            :     }
<span class="lineNum">    2926 </span>            :   else
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_UNKNOWN_CURVE);</span>
<span class="lineNum">    2928 </span>            : 
<span class="lineNum">    2929 </span>            :   /* Parse the flags.  */
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :   keyuse = 0;</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :   if (flags)</span>
<span class="lineNum">    2932 </span>            :     {
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :       char **tokens = NULL;</span>
<span class="lineNum">    2934 </span>            : 
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :       tokens = strtokenize (flags, &quot;,&quot;);</span>
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :       if (!tokens)</span>
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :         return gpg_error_from_syserror ();</span>
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :       for (i=0; (s = tokens[i]); i++)</span>
<span class="lineNum">    2940 </span>            :         {
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :           if (!*s)</span>
<span class="lineNum">    2942 </span>            :             ;
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;sign&quot;))</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :             keyuse |= PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;encrypt&quot;)</span>
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :                    || !ascii_strcasecmp (s, &quot;encr&quot;))</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :             keyuse |= PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;auth&quot;))</span>
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :             keyuse |= PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;cert&quot;))</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :             keyuse |= PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;ecdsa&quot;))</span>
<span class="lineNum">    2953 </span>            :             {
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_ECDH || algo == PUBKEY_ALGO_ECDSA)</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :                 algo = PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    2956 </span>            :               else
<span class="lineNum">    2957 </span>            :                 {
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :                   xfree (tokens);</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                   return gpg_error (GPG_ERR_INV_FLAG);</span>
<span class="lineNum">    2960 </span>            :                 }
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :               ecdh_or_ecdsa = 0;</span>
<span class="lineNum">    2962 </span>            :             }
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;ecdh&quot;))</span>
<span class="lineNum">    2964 </span>            :             {
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_ECDH || algo == PUBKEY_ALGO_ECDSA)</span>
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :                 algo = PUBKEY_ALGO_ECDH;</span>
<span class="lineNum">    2967 </span>            :               else
<span class="lineNum">    2968 </span>            :                 {
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :                   xfree (tokens);</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :                   return gpg_error (GPG_ERR_INV_FLAG);</span>
<span class="lineNum">    2971 </span>            :                 }
<span class="lineNum">    2972 </span><span class="lineNoCov">          0 :               ecdh_or_ecdsa = 0;</span>
<span class="lineNum">    2973 </span>            :             }
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :           else if (!ascii_strcasecmp (s, &quot;eddsa&quot;))</span>
<span class="lineNum">    2975 </span>            :             {
<span class="lineNum">    2976 </span>            :               /* Not required but we allow it for consistency.  */
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_EDDSA)</span>
<span class="lineNum">    2978 </span>            :                 ;
<span class="lineNum">    2979 </span>            :               else
<span class="lineNum">    2980 </span>            :                 {
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :                   xfree (tokens);</span>
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :                   return gpg_error (GPG_ERR_INV_FLAG);</span>
<span class="lineNum">    2983 </span>            :                 }
<span class="lineNum">    2984 </span>            :             }
<span class="lineNum">    2985 </span>            :           else
<span class="lineNum">    2986 </span>            :             {
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :               xfree (tokens);</span>
<span class="lineNum">    2988 </span><span class="lineNoCov">          0 :               return gpg_error (GPG_ERR_UNKNOWN_FLAG);</span>
<span class="lineNum">    2989 </span>            :             }
<span class="lineNum">    2990 </span>            :         }
<span class="lineNum">    2991 </span>            : 
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :       xfree (tokens);</span>
<span class="lineNum">    2993 </span>            :     }
<span class="lineNum">    2994 </span>            : 
<span class="lineNum">    2995 </span>            :   /* If not yet decided switch between ecdh and ecdsa.  */
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :   if (ecdh_or_ecdsa &amp;&amp; keyuse)</span>
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :     algo = (keyuse &amp; PUBKEY_USAGE_ENC)? PUBKEY_ALGO_ECDH : PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :   else if (ecdh_or_ecdsa)</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :     algo = for_subkey? PUBKEY_ALGO_ECDH : PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    3000 </span>            : 
<span class="lineNum">    3001 </span>            :   /* Set or fix key usage.  */
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :   if (!keyuse)</span>
<span class="lineNum">    3003 </span>            :     {
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :       if (algo == PUBKEY_ALGO_ECDSA || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :           || algo == PUBKEY_ALGO_DSA)</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :         keyuse = PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    3007 </span><span class="lineNoCov">          0 :       else if (algo == PUBKEY_ALGO_RSA)</span>
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :         keyuse = for_subkey? PUBKEY_USAGE_ENC : PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    3009 </span>            :       else
<span class="lineNum">    3010 </span><span class="lineNoCov">          0 :         keyuse = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    3011 </span>            :     }
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDSA || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :            || algo == PUBKEY_ALGO_DSA)</span>
<span class="lineNum">    3014 </span>            :     {
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :       keyuse &amp;= ~PUBKEY_USAGE_ENC; /* Forbid encryption.  */</span>
<span class="lineNum">    3016 </span>            :     }
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDH || algo == PUBKEY_ALGO_ELGAMAL_E)</span>
<span class="lineNum">    3018 </span>            :     {
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :       keyuse = PUBKEY_USAGE_ENC;   /* Allow only encryption.  */</span>
<span class="lineNum">    3020 </span>            :     }
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span>            :   /* Make sure a primary key can certify.  */
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :   if (!for_subkey)</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :     keyuse |= PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    3025 </span>            : 
<span class="lineNum">    3026 </span>            :   /* Check that usage is actually possible.  */
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :   if (/**/((keyuse &amp; (PUBKEY_USAGE_SIG|PUBKEY_USAGE_AUTH|PUBKEY_USAGE_CERT))</span>
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 :            &amp;&amp; !pubkey_get_nsig (algo))</span>
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :        || ((keyuse &amp; PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :            &amp;&amp; !pubkey_get_nenc (algo))</span>
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 :        || (for_subkey &amp;&amp; (keyuse &amp; PUBKEY_USAGE_CERT)))</span>
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_WRONG_KEY_USAGE);</span>
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span>            :   /* Return values.  */
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 :   if (r_algo)</span>
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :     *r_algo = algo;</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :   if (r_size)</span>
<span class="lineNum">    3038 </span>            :     {
<span class="lineNum">    3039 </span>            :       unsigned int min, def, max;
<span class="lineNum">    3040 </span>            : 
<span class="lineNum">    3041 </span>            :       /* Make sure the keysize is in the allowed range.  */
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :       def = get_keysize_range (algo, &amp;min, &amp;max);</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :       if (!size)</span>
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 :         size = def;</span>
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :       else if (size &lt; min)</span>
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :         size = min;</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :       else if (size &gt; max)</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :         size = max;</span>
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :       *r_size = fixup_keysize (size, algo, 1);</span>
<span class="lineNum">    3051 </span>            :     }
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :   if (r_keyuse)</span>
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :     *r_keyuse = keyuse;</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :   if (r_curve)</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :     *r_curve = curve;</span>
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3058 </span>            : }
<span class="lineNum">    3059 </span>            : 
<span class="lineNum">    3060 </span>            : /* Parse and return the standard key generation parameter.
<span class="lineNum">    3061 </span>            :  * The string is expected to be in this format:
<span class="lineNum">    3062 </span>            :  *
<span class="lineNum">    3063 </span>            :  *   ALGO[/FLAGS][+SUBALGO[/FLAGS]]
<span class="lineNum">    3064 </span>            :  *
<span class="lineNum">    3065 </span>            :  * Here ALGO is a string in the same format as printed by the
<span class="lineNum">    3066 </span>            :  * keylisting.  For example:
<span class="lineNum">    3067 </span>            :  *
<span class="lineNum">    3068 </span>            :  *   rsa3072 := RSA with 3072 bit.
<span class="lineNum">    3069 </span>            :  *   dsa2048 := DSA with 2048 bit.
<span class="lineNum">    3070 </span>            :  *   elg2048 := Elgamal with 2048 bit.
<span class="lineNum">    3071 </span>            :  *   ed25519 := EDDSA using curve Ed25519.
<span class="lineNum">    3072 </span>            :  *   cv25519 := ECDH using curve Curve25519.
<span class="lineNum">    3073 </span>            :  *   nistp256:= ECDSA or ECDH using curve NIST P-256
<span class="lineNum">    3074 </span>            :  *
<span class="lineNum">    3075 </span>            :  * All strings with an unknown prefix are considered an elliptic
<span class="lineNum">    3076 </span>            :  * curve.  Curves which have no implicit algorithm require that FLAGS
<span class="lineNum">    3077 </span>            :  * is given to select whether ECDSA or ECDH is used; this can eoither
<span class="lineNum">    3078 </span>            :  * be done using an algorithm keyword or usage keywords.
<span class="lineNum">    3079 </span>            :  *
<span class="lineNum">    3080 </span>            :  * FLAGS is a comma delimited string of keywords:
<span class="lineNum">    3081 </span>            :  *
<span class="lineNum">    3082 </span>            :  *   cert := Allow usage Certify
<span class="lineNum">    3083 </span>            :  *   sign := Allow usage Sign
<span class="lineNum">    3084 </span>            :  *   encr := Allow usage Encrypt
<span class="lineNum">    3085 </span>            :  *   auth := Allow usage Authentication
<span class="lineNum">    3086 </span>            :  *   encrypt := Alias for &quot;encr&quot;
<span class="lineNum">    3087 </span>            :  *   ecdsa := Use algorithm ECDSA.
<span class="lineNum">    3088 </span>            :  *   eddsa := Use algorithm EdDSA.
<span class="lineNum">    3089 </span>            :  *   ecdh  := Use algorithm ECDH.
<span class="lineNum">    3090 </span>            :  *
<span class="lineNum">    3091 </span>            :  * There are several defaults and fallbacks depending on the
<span class="lineNum">    3092 </span>            :  * algorithm.  PART can be used to select which part of STRING is
<span class="lineNum">    3093 </span>            :  * used:
<span class="lineNum">    3094 </span>            :  *   -1 := Both parts
<span class="lineNum">    3095 </span>            :  *    0 := Only the part of the primary key
<span class="lineNum">    3096 </span>            :  *    1 := If there is one part parse that one, if there are
<span class="lineNum">    3097 </span>            :  *         two parts parse the second part.  Always return
<span class="lineNum">    3098 </span>            :  *         in the args for the primary key (R_ALGO,....).
<span class="lineNum">    3099 </span>            :  *
<a name="3100"><span class="lineNum">    3100 </span>            :  */</a>
<span class="lineNum">    3101 </span>            : gpg_error_t
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 : parse_key_parameter_string (const char *string, int part,</span>
<span class="lineNum">    3103 </span>            :                             int *r_algo, unsigned int *r_size,
<span class="lineNum">    3104 </span>            :                             unsigned *r_keyuse,
<span class="lineNum">    3105 </span>            :                             char const **r_curve,
<span class="lineNum">    3106 </span>            :                             int *r_subalgo, unsigned int *r_subsize,
<span class="lineNum">    3107 </span>            :                             unsigned *r_subkeyuse,
<span class="lineNum">    3108 </span>            :                             char const **r_subcurve)
<span class="lineNum">    3109 </span>            : {
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 :   gpg_error_t err = 0;</span>
<span class="lineNum">    3111 </span>            :   char *primary, *secondary;
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :   if (r_algo)</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :     *r_algo = 0;</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :   if (r_size)</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :     *r_size = 0;</span>
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :   if (r_keyuse)</span>
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :     *r_keyuse = 0;</span>
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :   if (r_curve)</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :     *r_curve = NULL;</span>
<span class="lineNum">    3121 </span><span class="lineNoCov">          0 :   if (r_subalgo)</span>
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :     *r_subalgo = 0;</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :   if (r_subsize)</span>
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :     *r_subsize = 0;</span>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :   if (r_subkeyuse)</span>
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :     *r_subkeyuse = 0;</span>
<span class="lineNum">    3127 </span><span class="lineNoCov">          0 :   if (r_subcurve)</span>
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :     *r_subcurve = NULL;</span>
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :   if (!string || !*string</span>
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :       || !strcmp (string, &quot;default&quot;) || !strcmp (string, &quot;-&quot;))</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :     string = get_default_pubkey_algo ();</span>
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :   else if (!strcmp (string, &quot;future-default&quot;))</span>
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :     string = FUTURE_STD_KEY_PARAM;</span>
<span class="lineNum">    3135 </span>            : 
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :   primary = xstrdup (string);</span>
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :   secondary = strchr (primary, '+');</span>
<span class="lineNum">    3138 </span><span class="lineNoCov">          0 :   if (secondary)</span>
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :     *secondary++ = 0;</span>
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :   if (part == -1 || part == 0)</span>
<span class="lineNum">    3141 </span>            :     {
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :       err = parse_key_parameter_part (primary, 0, r_algo, r_size,</span>
<span class="lineNum">    3143 </span>            :                                       r_keyuse, r_curve);
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :       if (!err &amp;&amp; part == -1)</span>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :         err = parse_key_parameter_part (secondary, 1, r_subalgo, r_subsize,</span>
<span class="lineNum">    3146 </span>            :                                         r_subkeyuse, r_subcurve);
<span class="lineNum">    3147 </span>            :     }
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :   else if (part == 1)</span>
<span class="lineNum">    3149 </span>            :     {
<span class="lineNum">    3150 </span>            :       /* If we have SECONDARY, use that part.  If there is only one
<span class="lineNum">    3151 </span>            :        * part consider this to be the subkey algo.  */
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 :       err = parse_key_parameter_part (secondary? secondary : primary, 1,</span>
<span class="lineNum">    3153 </span>            :                                       r_algo, r_size, r_keyuse, r_curve);
<span class="lineNum">    3154 </span>            :     }
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :   xfree (primary);</span>
<span class="lineNum">    3157 </span>            : 
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    3159 </span>            : }
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span>            : 
<span class="lineNum">    3162 </span>            : 
<a name="3163"><span class="lineNum">    3163 </span>            : /* Append R to the linked list PARA.  */</a>
<span class="lineNum">    3164 </span>            : static void
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 : append_to_parameter (struct para_data_s *para, struct para_data_s *r)</span>
<span class="lineNum">    3166 </span>            : {
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :   log_assert (para);</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :   while (para-&gt;next)</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :     para = para-&gt;next;</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :   para-&gt;next = r;</span>
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3172 </span>            : 
<a name="3173"><span class="lineNum">    3173 </span>            : /* Release the parameter list R.  */</a>
<span class="lineNum">    3174 </span>            : static void
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 : release_parameter_list (struct para_data_s *r)</span>
<span class="lineNum">    3176 </span>            : {
<span class="lineNum">    3177 </span>            :   struct para_data_s *r2;
<span class="lineNum">    3178 </span>            : 
<span class="lineNum">    3179 </span><span class="lineNoCov">          0 :   for (; r ; r = r2)</span>
<span class="lineNum">    3180 </span>            :     {
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :       r2 = r-&gt;next;</span>
<span class="lineNum">    3182 </span><span class="lineNoCov">          0 :       if (r-&gt;key == pPASSPHRASE &amp;&amp; *r-&gt;u.value)</span>
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :         wipememory (r-&gt;u.value, strlen (r-&gt;u.value));</span>
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :       xfree (r);</span>
<span class="lineNum">    3185 </span>            :     }
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 : }</span>
<a name="3187"><span class="lineNum">    3187 </span>            : </a>
<span class="lineNum">    3188 </span>            : static struct para_data_s *
<span class="lineNum">    3189 </span><span class="lineNoCov">          0 : get_parameter( struct para_data_s *para, enum para_name key )</span>
<span class="lineNum">    3190 </span>            : {
<span class="lineNum">    3191 </span>            :     struct para_data_s *r;
<span class="lineNum">    3192 </span>            : 
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 :     for( r = para; r &amp;&amp; r-&gt;key != key; r = r-&gt;next )</span>
<span class="lineNum">    3194 </span>            :         ;
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     return r;</span>
<span class="lineNum">    3196 </span>            : }
<a name="3197"><span class="lineNum">    3197 </span>            : </a>
<span class="lineNum">    3198 </span>            : static const char *
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 : get_parameter_value( struct para_data_s *para, enum para_name key )</span>
<span class="lineNum">    3200 </span>            : {
<span class="lineNum">    3201 </span><span class="lineNoCov">          0 :     struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3202 </span><span class="lineNoCov">          0 :     return (r &amp;&amp; *r-&gt;u.value)? r-&gt;u.value : NULL;</span>
<span class="lineNum">    3203 </span>            : }
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span>            : 
<span class="lineNum">    3206 </span>            : /* This is similar to get_parameter_value but also returns the empty
<span class="lineNum">    3207 </span>            :    string.  This is required so that quick_generate_keypair can use an
<a name="3208"><span class="lineNum">    3208 </span>            :    empty Passphrase to specify no-protection.  */</a>
<span class="lineNum">    3209 </span>            : static const char *
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 : get_parameter_passphrase (struct para_data_s *para)</span>
<span class="lineNum">    3211 </span>            : {
<span class="lineNum">    3212 </span><span class="lineNoCov">          0 :   struct para_data_s *r = get_parameter (para, pPASSPHRASE);</span>
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :   return r ? r-&gt;u.value : NULL;</span>
<span class="lineNum">    3214 </span>            : }
<span class="lineNum">    3215 </span>            : 
<a name="3216"><span class="lineNum">    3216 </span>            : </a>
<span class="lineNum">    3217 </span>            : static int
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 : get_parameter_algo( struct para_data_s *para, enum para_name key,</span>
<span class="lineNum">    3219 </span>            :                     int *r_default)
<span class="lineNum">    3220 </span>            : {
<span class="lineNum">    3221 </span>            :   int i;
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :   struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :   if (r_default)</span>
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :     *r_default = 0;</span>
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span><span class="lineNoCov">          0 :   if (!r)</span>
<span class="lineNum">    3228 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3229 </span>            : 
<span class="lineNum">    3230 </span>            :   /* Note that we need to handle the ECC algorithms specified as
<span class="lineNum">    3231 </span>            :      strings directly because Libgcrypt folds them all to ECC.  */
<span class="lineNum">    3232 </span><span class="lineNoCov">          0 :   if (!ascii_strcasecmp (r-&gt;u.value, &quot;default&quot;))</span>
<span class="lineNum">    3233 </span>            :     {
<span class="lineNum">    3234 </span>            :       /* Note: If you change this default algo, remember to change it
<span class="lineNum">    3235 </span>            :        * also in gpg.c:gpgconf_list.  */
<span class="lineNum">    3236 </span>            :       /* FIXME: We only allow the algo here and have a separate thing
<span class="lineNum">    3237 </span>            :        * for the curve etc.  That is a ugly but demanded for backward
<span class="lineNum">    3238 </span>            :        * compatibility with the batch key generation.  It would be
<span class="lineNum">    3239 </span>            :        * better to make full use of parse_key_parameter_string.  */
<span class="lineNum">    3240 </span><span class="lineNoCov">          0 :       parse_key_parameter_string (NULL, 0,</span>
<span class="lineNum">    3241 </span>            :                                   &amp;i, NULL, NULL, NULL,
<span class="lineNum">    3242 </span>            :                                   NULL, NULL, NULL, NULL);
<span class="lineNum">    3243 </span>            : 
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :       if (r_default)</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :         *r_default = 1;</span>
<span class="lineNum">    3246 </span>            :     }
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :   else if (digitp (r-&gt;u.value))</span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :     i = atoi( r-&gt;u.value );</span>
<span class="lineNum">    3249 </span><span class="lineNoCov">          0 :   else if (!strcmp (r-&gt;u.value, &quot;ELG-E&quot;)</span>
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 :            || !strcmp (r-&gt;u.value, &quot;ELG&quot;))</span>
<span class="lineNum">    3251 </span><span class="lineNoCov">          0 :     i = PUBKEY_ALGO_ELGAMAL_E;</span>
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :   else if (!ascii_strcasecmp (r-&gt;u.value, &quot;EdDSA&quot;))</span>
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :     i = PUBKEY_ALGO_EDDSA;</span>
<span class="lineNum">    3254 </span><span class="lineNoCov">          0 :   else if (!ascii_strcasecmp (r-&gt;u.value, &quot;ECDSA&quot;))</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :     i = PUBKEY_ALGO_ECDSA;</span>
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :   else if (!ascii_strcasecmp (r-&gt;u.value, &quot;ECDH&quot;))</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :     i = PUBKEY_ALGO_ECDH;</span>
<span class="lineNum">    3258 </span>            :   else
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :     i = map_pk_gcry_to_openpgp (gcry_pk_map_name (r-&gt;u.value));</span>
<span class="lineNum">    3260 </span>            : 
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :   if (i == PUBKEY_ALGO_RSA_E || i == PUBKEY_ALGO_RSA_S)</span>
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :     i = 0; /* we don't want to allow generation of these algorithms */</span>
<span class="lineNum">    3263 </span><span class="lineNoCov">          0 :   return i;</span>
<span class="lineNum">    3264 </span>            : }
<span class="lineNum">    3265 </span>            : 
<span class="lineNum">    3266 </span>            : 
<span class="lineNum">    3267 </span>            : /* Parse a usage string.  The usage keywords &quot;auth&quot;, &quot;sign&quot;, &quot;encr&quot;
<span class="lineNum">    3268 </span>            :  * may be delimited by space, tab, or comma.  On error -1 is returned
<a name="3269"><span class="lineNum">    3269 </span>            :  * instead of the usage flags.  */</a>
<span class="lineNum">    3270 </span>            : static int
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 : parse_usagestr (const char *usagestr)</span>
<span class="lineNum">    3272 </span>            : {
<span class="lineNum">    3273 </span>            :   gpg_error_t err;
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :   char **tokens = NULL;</span>
<span class="lineNum">    3275 </span>            :   const char *s;
<span class="lineNum">    3276 </span>            :   int i;
<span class="lineNum">    3277 </span><span class="lineNoCov">          0 :   unsigned int use = 0;</span>
<span class="lineNum">    3278 </span>            : 
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 :   tokens = strtokenize (usagestr, &quot; \t,&quot;);</span>
<span class="lineNum">    3280 </span><span class="lineNoCov">          0 :   if (!tokens)</span>
<span class="lineNum">    3281 </span>            :     {
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 :       log_error (&quot;strtokenize failed: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    3284 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    3285 </span>            :     }
<span class="lineNum">    3286 </span>            : 
<span class="lineNum">    3287 </span><span class="lineNoCov">          0 :   for (i=0; (s = tokens[i]); i++)</span>
<span class="lineNum">    3288 </span>            :     {
<span class="lineNum">    3289 </span><span class="lineNoCov">          0 :       if (!*s)</span>
<span class="lineNum">    3290 </span>            :         ;
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 :       else if (!ascii_strcasecmp (s, &quot;sign&quot;))</span>
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :         use |= PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :       else if (!ascii_strcasecmp (s, &quot;encrypt&quot;)</span>
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :                 || !ascii_strcasecmp (s, &quot;encr&quot;))</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :         use |= PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :       else if (!ascii_strcasecmp (s, &quot;auth&quot;))</span>
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :         use |= PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 :       else if (!ascii_strcasecmp (s, &quot;cert&quot;))</span>
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :         use |= PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    3300 </span>            :       else
<span class="lineNum">    3301 </span>            :         {
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 :           xfree (tokens);</span>
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :           return -1; /* error */</span>
<span class="lineNum">    3304 </span>            :         }
<span class="lineNum">    3305 </span>            :     }
<span class="lineNum">    3306 </span>            : 
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :   xfree (tokens);</span>
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :   return use;</span>
<span class="lineNum">    3309 </span>            : }
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span>            : 
<span class="lineNum">    3312 </span>            : /*
<span class="lineNum">    3313 </span>            :  * Parse the usage parameter and set the keyflags.  Returns -1 on
<span class="lineNum">    3314 </span>            :  * error, 0 for no usage given or 1 for usage available.
<a name="3315"><span class="lineNum">    3315 </span>            :  */</a>
<span class="lineNum">    3316 </span>            : static int
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 : parse_parameter_usage (const char *fname,</span>
<span class="lineNum">    3318 </span>            :                        struct para_data_s *para, enum para_name key)
<span class="lineNum">    3319 </span>            : {
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :   struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3321 </span>            :   int i;
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :   if (!r)</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :     return 0; /* none (this is an optional parameter)*/</span>
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :   i = parse_usagestr (r-&gt;u.value);</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :   if (i == -1)</span>
<span class="lineNum">    3328 </span>            :     {
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 :       log_error (&quot;%s:%d: invalid usage list\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :       return -1; /* error */</span>
<span class="lineNum">    3331 </span>            :     }
<span class="lineNum">    3332 </span>            : 
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :   r-&gt;u.usage = i;</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">    3335 </span>            : }
<span class="lineNum">    3336 </span>            : 
<a name="3337"><span class="lineNum">    3337 </span>            : </a>
<span class="lineNum">    3338 </span>            : static int
<span class="lineNum">    3339 </span><span class="lineNoCov">          0 : parse_revocation_key (const char *fname,</span>
<span class="lineNum">    3340 </span>            :                       struct para_data_s *para, enum para_name key)
<span class="lineNum">    3341 </span>            : {
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :   struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3343 </span>            :   struct revocation_key revkey;
<span class="lineNum">    3344 </span>            :   char *pn;
<span class="lineNum">    3345 </span>            :   int i;
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span><span class="lineNoCov">          0 :   if( !r )</span>
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :     return 0; /* none (this is an optional parameter) */</span>
<span class="lineNum">    3349 </span>            : 
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :   pn = r-&gt;u.value;</span>
<span class="lineNum">    3351 </span>            : 
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :   revkey.class=0x80;</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :   revkey.algid=atoi(pn);</span>
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :   if(!revkey.algid)</span>
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :     goto fail;</span>
<span class="lineNum">    3356 </span>            : 
<span class="lineNum">    3357 </span>            :   /* Skip to the fpr */
<span class="lineNum">    3358 </span><span class="lineNoCov">          0 :   while(*pn &amp;&amp; *pn!=':')</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 :     pn++;</span>
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span><span class="lineNoCov">          0 :   if(*pn!=':')</span>
<span class="lineNum">    3362 </span><span class="lineNoCov">          0 :     goto fail;</span>
<span class="lineNum">    3363 </span>            : 
<span class="lineNum">    3364 </span><span class="lineNoCov">          0 :   pn++;</span>
<span class="lineNum">    3365 </span>            : 
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 :   for(i=0;i&lt;MAX_FINGERPRINT_LEN &amp;&amp; *pn;i++,pn+=2)</span>
<span class="lineNum">    3367 </span>            :     {
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 :       int c=hextobyte(pn);</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :       if(c==-1)</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :         goto fail;</span>
<span class="lineNum">    3371 </span>            : 
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :       revkey.fpr[i]=c;</span>
<span class="lineNum">    3373 </span>            :     }
<span class="lineNum">    3374 </span>            : 
<span class="lineNum">    3375 </span>            :   /* skip to the tag */
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 :   while(*pn &amp;&amp; *pn!='s' &amp;&amp; *pn!='S')</span>
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 :     pn++;</span>
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :   if(ascii_strcasecmp(pn,&quot;sensitive&quot;)==0)</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :     revkey.class|=0x40;</span>
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span><span class="lineNoCov">          0 :   memcpy(&amp;r-&gt;u.revkey,&amp;revkey,sizeof(struct revocation_key));</span>
<span class="lineNum">    3383 </span>            : 
<span class="lineNum">    3384 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span>            :   fail:
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :   log_error(&quot;%s:%d: invalid revocation key\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :   return -1; /* error */</span>
<span class="lineNum">    3389 </span>            : }
<span class="lineNum">    3390 </span>            : 
<a name="3391"><span class="lineNum">    3391 </span>            : </a>
<span class="lineNum">    3392 </span>            : static u32
<span class="lineNum">    3393 </span><span class="lineNoCov">          0 : get_parameter_u32( struct para_data_s *para, enum para_name key )</span>
<span class="lineNum">    3394 </span>            : {
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :   struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3396 </span>            : 
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :   if( !r )</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :   if( r-&gt;key == pKEYCREATIONDATE )</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :     return r-&gt;u.creation;</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :   if( r-&gt;key == pKEYEXPIRE || r-&gt;key == pSUBKEYEXPIRE )</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :     return r-&gt;u.expire;</span>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :   if( r-&gt;key == pKEYUSAGE || r-&gt;key == pSUBKEYUSAGE )</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :     return r-&gt;u.usage;</span>
<span class="lineNum">    3405 </span>            : 
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :   return (unsigned int)strtoul( r-&gt;u.value, NULL, 10 );</span>
<span class="lineNum">    3407 </span>            : }
<a name="3408"><span class="lineNum">    3408 </span>            : </a>
<span class="lineNum">    3409 </span>            : static unsigned int
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 : get_parameter_uint( struct para_data_s *para, enum para_name key )</span>
<span class="lineNum">    3411 </span>            : {
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :     return get_parameter_u32( para, key );</span>
<span class="lineNum">    3413 </span>            : }
<a name="3414"><span class="lineNum">    3414 </span>            : </a>
<span class="lineNum">    3415 </span>            : static struct revocation_key *
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 : get_parameter_revkey( struct para_data_s *para, enum para_name key )</span>
<span class="lineNum">    3417 </span>            : {
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :     struct para_data_s *r = get_parameter( para, key );</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :     return r? &amp;r-&gt;u.revkey : NULL;</span>
<span class="lineNum">    3420 </span>            : }
<a name="3421"><span class="lineNum">    3421 </span>            : </a>
<span class="lineNum">    3422 </span>            : static int
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 : proc_parameter_file (ctrl_t ctrl, struct para_data_s *para, const char *fname,</span>
<span class="lineNum">    3424 </span>            :                      struct output_control_s *outctrl, int card )
<span class="lineNum">    3425 </span>            : {
<span class="lineNum">    3426 </span>            :   struct para_data_s *r;
<span class="lineNum">    3427 </span>            :   const char *s1, *s2, *s3;
<span class="lineNum">    3428 </span>            :   size_t n;
<span class="lineNum">    3429 </span>            :   char *p;
<span class="lineNum">    3430 </span><span class="lineNoCov">          0 :   int is_default = 0;</span>
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :   int have_user_id = 0;</span>
<span class="lineNum">    3432 </span>            :   int err, algo;
<span class="lineNum">    3433 </span>            : 
<span class="lineNum">    3434 </span>            :   /* Check that we have all required parameters. */
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 :   r = get_parameter( para, pKEYTYPE );</span>
<span class="lineNum">    3436 </span><span class="lineNoCov">          0 :   if(r)</span>
<span class="lineNum">    3437 </span>            :     {
<span class="lineNum">    3438 </span><span class="lineNoCov">          0 :       algo = get_parameter_algo (para, pKEYTYPE, &amp;is_default);</span>
<span class="lineNum">    3439 </span><span class="lineNoCov">          0 :       if (openpgp_pk_test_algo2 (algo, PUBKEY_USAGE_SIG))</span>
<span class="lineNum">    3440 </span>            :         {
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :           log_error (&quot;%s:%d: invalid algorithm\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3443 </span>            :         }
<span class="lineNum">    3444 </span>            :     }
<span class="lineNum">    3445 </span>            :   else
<span class="lineNum">    3446 </span>            :     {
<span class="lineNum">    3447 </span><span class="lineNoCov">          0 :       log_error (&quot;%s: no Key-Type specified\n&quot;,fname);</span>
<span class="lineNum">    3448 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    3449 </span>            :     }
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span><span class="lineNoCov">          0 :   err = parse_parameter_usage (fname, para, pKEYUSAGE);</span>
<span class="lineNum">    3452 </span><span class="lineNoCov">          0 :   if (!err)</span>
<span class="lineNum">    3453 </span>            :     {
<span class="lineNum">    3454 </span>            :       /* Default to algo capabilities if key-usage is not provided and
<span class="lineNum">    3455 </span>            :          no default algorithm has been requested.  */
<span class="lineNum">    3456 </span><span class="lineNoCov">          0 :       r = xmalloc_clear(sizeof(*r));</span>
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYUSAGE;</span>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 :       r-&gt;u.usage = (is_default</span>
<span class="lineNum">    3459 </span><span class="lineNoCov">          0 :                     ? (PUBKEY_USAGE_CERT | PUBKEY_USAGE_SIG)</span>
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 :                     : openpgp_pk_algo_usage(algo));</span>
<span class="lineNum">    3461 </span><span class="lineNoCov">          0 :       append_to_parameter (para, r);</span>
<span class="lineNum">    3462 </span>            :     }
<span class="lineNum">    3463 </span><span class="lineNoCov">          0 :   else if (err == -1)</span>
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3465 </span>            :   else
<span class="lineNum">    3466 </span>            :     {
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 :       r = get_parameter (para, pKEYUSAGE);</span>
<span class="lineNum">    3468 </span><span class="lineNoCov">          0 :       if (r &amp;&amp; (r-&gt;u.usage &amp; ~openpgp_pk_algo_usage (algo)))</span>
<span class="lineNum">    3469 </span>            :         {
<span class="lineNum">    3470 </span><span class="lineNoCov">          0 :           log_error (&quot;%s:%d: specified Key-Usage not allowed for algo %d\n&quot;,</span>
<span class="lineNum">    3471 </span>            :                      fname, r-&gt;lnr, algo);
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3473 </span>            :         }
<span class="lineNum">    3474 </span>            :     }
<span class="lineNum">    3475 </span>            : 
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :   is_default = 0;</span>
<span class="lineNum">    3477 </span><span class="lineNoCov">          0 :   r = get_parameter( para, pSUBKEYTYPE );</span>
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :   if(r)</span>
<span class="lineNum">    3479 </span>            :     {
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :       algo = get_parameter_algo (para, pSUBKEYTYPE, &amp;is_default);</span>
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :       if (openpgp_pk_test_algo (algo))</span>
<span class="lineNum">    3482 </span>            :         {
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 :           log_error (&quot;%s:%d: invalid algorithm\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3484 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3485 </span>            :         }
<span class="lineNum">    3486 </span>            : 
<span class="lineNum">    3487 </span><span class="lineNoCov">          0 :       err = parse_parameter_usage (fname, para, pSUBKEYUSAGE);</span>
<span class="lineNum">    3488 </span><span class="lineNoCov">          0 :       if (!err)</span>
<span class="lineNum">    3489 </span>            :         {
<span class="lineNum">    3490 </span>            :           /* Default to algo capabilities if subkey-usage is not
<span class="lineNum">    3491 </span>            :              provided */
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :           r = xmalloc_clear (sizeof(*r));</span>
<span class="lineNum">    3493 </span><span class="lineNoCov">          0 :           r-&gt;key = pSUBKEYUSAGE;</span>
<span class="lineNum">    3494 </span><span class="lineNoCov">          0 :           r-&gt;u.usage = (is_default</span>
<span class="lineNum">    3495 </span><span class="lineNoCov">          0 :                         ? PUBKEY_USAGE_ENC</span>
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :                         : openpgp_pk_algo_usage (algo));</span>
<span class="lineNum">    3497 </span><span class="lineNoCov">          0 :           append_to_parameter (para, r);</span>
<span class="lineNum">    3498 </span>            :         }
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :       else if (err == -1)</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    3501 </span>            :       else
<span class="lineNum">    3502 </span>            :         {
<span class="lineNum">    3503 </span><span class="lineNoCov">          0 :           r = get_parameter (para, pSUBKEYUSAGE);</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :           if (r &amp;&amp; (r-&gt;u.usage &amp; ~openpgp_pk_algo_usage (algo)))</span>
<span class="lineNum">    3505 </span>            :             {
<span class="lineNum">    3506 </span><span class="lineNoCov">          0 :               log_error (&quot;%s:%d: specified Subkey-Usage not allowed&quot;</span>
<span class="lineNum">    3507 </span>            :                          &quot; for algo %d\n&quot;, fname, r-&gt;lnr, algo);
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :               return -1;</span>
<span class="lineNum">    3509 </span>            :             }
<span class="lineNum">    3510 </span>            :         }
<span class="lineNum">    3511 </span>            :     }
<span class="lineNum">    3512 </span>            : 
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineNoCov">          0 :   if( get_parameter_value( para, pUSERID ) )</span>
<span class="lineNum">    3515 </span><span class="lineNoCov">          0 :     have_user_id=1;</span>
<span class="lineNum">    3516 </span>            :   else
<span class="lineNum">    3517 </span>            :     {
<span class="lineNum">    3518 </span>            :       /* create the formatted user ID */
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :       s1 = get_parameter_value( para, pNAMEREAL );</span>
<span class="lineNum">    3520 </span><span class="lineNoCov">          0 :       s2 = get_parameter_value( para, pNAMECOMMENT );</span>
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :       s3 = get_parameter_value( para, pNAMEEMAIL );</span>
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :       if( s1 || s2 || s3 )</span>
<span class="lineNum">    3523 </span>            :         {
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :           n = (s1?strlen(s1):0) + (s2?strlen(s2):0) + (s3?strlen(s3):0);</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :           r = xmalloc_clear( sizeof *r + n + 20 );</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :           r-&gt;key = pUSERID;</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :           p = r-&gt;u.value;</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :           if( s1 )</span>
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :             p = stpcpy(p, s1 );</span>
<span class="lineNum">    3530 </span><span class="lineNoCov">          0 :           if( s2 )</span>
<span class="lineNum">    3531 </span><span class="lineNoCov">          0 :             p = stpcpy(stpcpy(stpcpy(p,&quot; (&quot;), s2 ),&quot;)&quot;);</span>
<span class="lineNum">    3532 </span><span class="lineNoCov">          0 :           if( s3 )</span>
<span class="lineNum">    3533 </span><span class="lineNoCov">          0 :             p = stpcpy(stpcpy(stpcpy(p,&quot; &lt;&quot;), s3 ),&quot;&gt;&quot;);</span>
<span class="lineNum">    3534 </span><span class="lineNoCov">          0 :           append_to_parameter (para, r);</span>
<span class="lineNum">    3535 </span><span class="lineNoCov">          0 :           have_user_id=1;</span>
<span class="lineNum">    3536 </span>            :         }
<span class="lineNum">    3537 </span>            :     }
<span class="lineNum">    3538 </span>            : 
<span class="lineNum">    3539 </span><span class="lineNoCov">          0 :   if(!have_user_id)</span>
<span class="lineNum">    3540 </span>            :     {
<span class="lineNum">    3541 </span><span class="lineNoCov">          0 :       log_error(&quot;%s: no User-ID specified\n&quot;,fname);</span>
<span class="lineNum">    3542 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">    3543 </span>            :     }
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span>            :   /* Set preferences, if any. */
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :   keygen_set_std_prefs(get_parameter_value( para, pPREFERENCES ), 0);</span>
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span>            :   /* Set keyserver, if any. */
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :   s1=get_parameter_value( para, pKEYSERVER );</span>
<span class="lineNum">    3550 </span><span class="lineNoCov">          0 :   if(s1)</span>
<span class="lineNum">    3551 </span>            :     {
<span class="lineNum">    3552 </span>            :       struct keyserver_spec *spec;
<span class="lineNum">    3553 </span>            : 
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :       spec = parse_keyserver_uri (s1, 1);</span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :       if(spec)</span>
<span class="lineNum">    3556 </span>            :         {
<span class="lineNum">    3557 </span><span class="lineNoCov">          0 :           free_keyserver_spec(spec);</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :           opt.def_keyserver_url=s1;</span>
<span class="lineNum">    3559 </span>            :         }
<span class="lineNum">    3560 </span>            :       else
<span class="lineNum">    3561 </span>            :         {
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :           r = get_parameter (para, pKEYSERVER);</span>
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 :           log_error(&quot;%s:%d: invalid keyserver url\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3564 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3565 </span>            :         }
<span class="lineNum">    3566 </span>            :     }
<span class="lineNum">    3567 </span>            : 
<span class="lineNum">    3568 </span>            :   /* Set revoker, if any. */
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :   if (parse_revocation_key (fname, para, pREVOKER))</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span>            : 
<span class="lineNum">    3573 </span>            :   /* Make KEYCREATIONDATE from Creation-Date.  */
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :   r = get_parameter (para, pCREATIONDATE);</span>
<span class="lineNum">    3575 </span><span class="lineNoCov">          0 :   if (r &amp;&amp; *r-&gt;u.value)</span>
<span class="lineNum">    3576 </span>            :     {
<span class="lineNum">    3577 </span>            :       u32 seconds;
<span class="lineNum">    3578 </span>            : 
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :       seconds = parse_creation_string (r-&gt;u.value);</span>
<span class="lineNum">    3580 </span><span class="lineNoCov">          0 :       if (!seconds)</span>
<span class="lineNum">    3581 </span>            :         {
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :           log_error (&quot;%s:%d: invalid creation date\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3584 </span>            :         }
<span class="lineNum">    3585 </span><span class="lineNoCov">          0 :       r-&gt;u.creation = seconds;</span>
<span class="lineNum">    3586 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYCREATIONDATE;  /* Change that entry. */</span>
<span class="lineNum">    3587 </span>            :     }
<span class="lineNum">    3588 </span>            : 
<span class="lineNum">    3589 </span>            :   /* Make KEYEXPIRE from Expire-Date.  */
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :   r = get_parameter( para, pEXPIREDATE );</span>
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :   if( r &amp;&amp; *r-&gt;u.value )</span>
<span class="lineNum">    3592 </span>            :     {
<span class="lineNum">    3593 </span>            :       u32 seconds;
<span class="lineNum">    3594 </span>            : 
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :       seconds = parse_expire_string( r-&gt;u.value );</span>
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :       if( seconds == (u32)-1 )</span>
<span class="lineNum">    3597 </span>            :         {
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :           log_error(&quot;%s:%d: invalid expire date\n&quot;, fname, r-&gt;lnr );</span>
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :           return -1;</span>
<span class="lineNum">    3600 </span>            :         }
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :       r-&gt;u.expire = seconds;</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYEXPIRE;  /* change hat entry */</span>
<span class="lineNum">    3603 </span>            :       /* also set it for the subkey */
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :       r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 :       r-&gt;key = pSUBKEYEXPIRE;</span>
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :       r-&gt;u.expire = seconds;</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :       append_to_parameter (para, r);</span>
<span class="lineNum">    3608 </span>            :     }
<span class="lineNum">    3609 </span>            : 
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :   do_generate_keypair (ctrl, para, outctrl, card );</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    3612 </span>            : }
<span class="lineNum">    3613 </span>            : 
<span class="lineNum">    3614 </span>            : 
<span class="lineNum">    3615 </span>            : /****************
<span class="lineNum">    3616 </span>            :  * Kludge to allow non interactive key generation controlled
<span class="lineNum">    3617 </span>            :  * by a parameter file.
<span class="lineNum">    3618 </span>            :  * Note, that string parameters are expected to be in UTF-8
<a name="3619"><span class="lineNum">    3619 </span>            :  */</a>
<span class="lineNum">    3620 </span>            : static void
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 : read_parameter_file (ctrl_t ctrl, const char *fname )</span>
<span class="lineNum">    3622 </span>            : {
<span class="lineNum">    3623 </span>            :     static struct { const char *name;
<span class="lineNum">    3624 </span>            :                     enum para_name key;
<span class="lineNum">    3625 </span>            :     } keywords[] = {
<span class="lineNum">    3626 </span>            :         { &quot;Key-Type&quot;,       pKEYTYPE},
<span class="lineNum">    3627 </span>            :         { &quot;Key-Length&quot;,     pKEYLENGTH },
<span class="lineNum">    3628 </span>            :         { &quot;Key-Curve&quot;,      pKEYCURVE },
<span class="lineNum">    3629 </span>            :         { &quot;Key-Usage&quot;,      pKEYUSAGE },
<span class="lineNum">    3630 </span>            :         { &quot;Subkey-Type&quot;,    pSUBKEYTYPE },
<span class="lineNum">    3631 </span>            :         { &quot;Subkey-Length&quot;,  pSUBKEYLENGTH },
<span class="lineNum">    3632 </span>            :         { &quot;Subkey-Curve&quot;,   pSUBKEYCURVE },
<span class="lineNum">    3633 </span>            :         { &quot;Subkey-Usage&quot;,   pSUBKEYUSAGE },
<span class="lineNum">    3634 </span>            :         { &quot;Name-Real&quot;,      pNAMEREAL },
<span class="lineNum">    3635 </span>            :         { &quot;Name-Email&quot;,     pNAMEEMAIL },
<span class="lineNum">    3636 </span>            :         { &quot;Name-Comment&quot;,   pNAMECOMMENT },
<span class="lineNum">    3637 </span>            :         { &quot;Expire-Date&quot;,    pEXPIREDATE },
<span class="lineNum">    3638 </span>            :         { &quot;Creation-Date&quot;,  pCREATIONDATE },
<span class="lineNum">    3639 </span>            :         { &quot;Passphrase&quot;,     pPASSPHRASE },
<span class="lineNum">    3640 </span>            :         { &quot;Preferences&quot;,    pPREFERENCES },
<span class="lineNum">    3641 </span>            :         { &quot;Revoker&quot;,        pREVOKER },
<span class="lineNum">    3642 </span>            :         { &quot;Handle&quot;,         pHANDLE },
<span class="lineNum">    3643 </span>            :         { &quot;Keyserver&quot;,      pKEYSERVER },
<span class="lineNum">    3644 </span>            :         { &quot;Keygrip&quot;,        pKEYGRIP },
<span class="lineNum">    3645 </span>            :         { NULL, 0 }
<span class="lineNum">    3646 </span>            :     };
<span class="lineNum">    3647 </span>            :     IOBUF fp;
<span class="lineNum">    3648 </span>            :     byte *line;
<span class="lineNum">    3649 </span>            :     unsigned int maxlen, nline;
<span class="lineNum">    3650 </span>            :     char *p;
<span class="lineNum">    3651 </span>            :     int lnr;
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 :     const char *err = NULL;</span>
<span class="lineNum">    3653 </span>            :     struct para_data_s *para, *r;
<span class="lineNum">    3654 </span>            :     int i;
<span class="lineNum">    3655 </span>            :     struct output_control_s outctrl;
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 :     memset( &amp;outctrl, 0, sizeof( outctrl ) );</span>
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :     outctrl.pub.afx = new_armor_context ();</span>
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :     if( !fname || !*fname)</span>
<span class="lineNum">    3661 </span><span class="lineNoCov">          0 :       fname = &quot;-&quot;;</span>
<span class="lineNum">    3662 </span>            : 
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :     fp = iobuf_open (fname);</span>
<span class="lineNum">    3664 </span><span class="lineNoCov">          0 :     if (fp &amp;&amp; is_secured_file (iobuf_get_fd (fp)))</span>
<span class="lineNum">    3665 </span>            :       {
<span class="lineNum">    3666 </span><span class="lineNoCov">          0 :         iobuf_close (fp);</span>
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :         fp = NULL;</span>
<span class="lineNum">    3668 </span><span class="lineNoCov">          0 :         gpg_err_set_errno (EPERM);</span>
<span class="lineNum">    3669 </span>            :       }
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :     if (!fp) {</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :       log_error (_(&quot;can't open '%s': %s\n&quot;), fname, strerror(errno) );</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    3673 </span>            :     }
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :     iobuf_ioctl (fp, IOBUF_IOCTL_NO_CACHE, 1, NULL);</span>
<span class="lineNum">    3675 </span>            : 
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :     lnr = 0;</span>
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :     err = NULL;</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :     para = NULL;</span>
<span class="lineNum">    3679 </span><span class="lineNoCov">          0 :     maxlen = 1024;</span>
<span class="lineNum">    3680 </span><span class="lineNoCov">          0 :     line = NULL;</span>
<span class="lineNum">    3681 </span><span class="lineNoCov">          0 :     while ( iobuf_read_line (fp, &amp;line, &amp;nline, &amp;maxlen) ) {</span>
<span class="lineNum">    3682 </span>            :         char *keyword, *value;
<span class="lineNum">    3683 </span>            : 
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 :         lnr++;</span>
<span class="lineNum">    3685 </span><span class="lineNoCov">          0 :         if( !maxlen ) {</span>
<span class="lineNum">    3686 </span><span class="lineNoCov">          0 :             err = &quot;line too long&quot;;</span>
<span class="lineNum">    3687 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3688 </span>            :         }
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :         for( p = line; isspace(*(byte*)p); p++ )</span>
<span class="lineNum">    3690 </span>            :             ;
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 :         if( !*p || *p == '#' )</span>
<span class="lineNum">    3692 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :         keyword = p;</span>
<span class="lineNum">    3694 </span><span class="lineNoCov">          0 :         if( *keyword == '%' ) {</span>
<span class="lineNum">    3695 </span><span class="lineNoCov">          0 :             for( ; !isspace(*(byte*)p); p++ )</span>
<span class="lineNum">    3696 </span>            :                 ;
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :             if( *p )</span>
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :                 *p++ = 0;</span>
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 :             for( ; isspace(*(byte*)p); p++ )</span>
<span class="lineNum">    3700 </span>            :                 ;
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :             value = p;</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :             trim_trailing_ws( value, strlen(value) );</span>
<span class="lineNum">    3703 </span><span class="lineNoCov">          0 :             if( !ascii_strcasecmp( keyword, &quot;%echo&quot; ) )</span>
<span class="lineNum">    3704 </span><span class="lineNoCov">          0 :                 log_info(&quot;%s\n&quot;, value );</span>
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%dry-run&quot; ) )</span>
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 :                 outctrl.dryrun = 1;</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%ask-passphrase&quot; ) )</span>
<span class="lineNum">    3708 </span>            :               ; /* Dummy for backward compatibility. */
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%no-ask-passphrase&quot; ) )</span>
<span class="lineNum">    3710 </span>            :               ; /* Dummy for backward compatibility. */
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%no-protection&quot; ) )</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :                 outctrl.keygen_flags |= KEYGEN_FLAG_NO_PROTECTION;</span>
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%transient-key&quot; ) )</span>
<span class="lineNum">    3714 </span><span class="lineNoCov">          0 :                 outctrl.keygen_flags |= KEYGEN_FLAG_TRANSIENT_KEY;</span>
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%commit&quot; ) ) {</span>
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :                 outctrl.lnr = lnr;</span>
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :                 if (proc_parameter_file (ctrl, para, fname, &amp;outctrl, 0 ))</span>
<span class="lineNum">    3718 </span><span class="lineNoCov">          0 :                   print_status_key_not_created</span>
<span class="lineNum">    3719 </span>            :                     (get_parameter_value (para, pHANDLE));
<span class="lineNum">    3720 </span><span class="lineNoCov">          0 :                 release_parameter_list( para );</span>
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :                 para = NULL;</span>
<span class="lineNum">    3722 </span>            :             }
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%pubring&quot; ) ) {</span>
<span class="lineNum">    3724 </span><span class="lineNoCov">          0 :                 if( outctrl.pub.fname &amp;&amp; !strcmp( outctrl.pub.fname, value ) )</span>
<span class="lineNum">    3725 </span>            :                     ; /* still the same file - ignore it */
<span class="lineNum">    3726 </span>            :                 else {
<span class="lineNum">    3727 </span><span class="lineNoCov">          0 :                     xfree( outctrl.pub.newfname );</span>
<span class="lineNum">    3728 </span><span class="lineNoCov">          0 :                     outctrl.pub.newfname = xstrdup( value );</span>
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :                     outctrl.use_files = 1;</span>
<span class="lineNum">    3730 </span>            :                 }
<span class="lineNum">    3731 </span>            :             }
<span class="lineNum">    3732 </span><span class="lineNoCov">          0 :             else if( !ascii_strcasecmp( keyword, &quot;%secring&quot; ) ) {</span>
<span class="lineNum">    3733 </span>            :               /* Ignore this command.  */
<span class="lineNum">    3734 </span>            :             }
<span class="lineNum">    3735 </span>            :             else
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 :                 log_info(&quot;skipping control '%s' (%s)\n&quot;, keyword, value );</span>
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span>            : 
<span class="lineNum">    3739 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    3740 </span>            :         }
<span class="lineNum">    3741 </span>            : 
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :         if( !(p = strchr( p, ':' )) || p == keyword ) {</span>
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :             err = &quot;missing colon&quot;;</span>
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3746 </span>            :         }
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :         if( *p )</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :             *p++ = 0;</span>
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :         for( ; isspace(*(byte*)p); p++ )</span>
<span class="lineNum">    3750 </span>            :             ;
<span class="lineNum">    3751 </span><span class="lineNoCov">          0 :         if( !*p ) {</span>
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :             err = &quot;missing argument&quot;;</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3754 </span>            :         }
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :         value = p;</span>
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :         trim_trailing_ws( value, strlen(value) );</span>
<span class="lineNum">    3757 </span>            : 
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :         for(i=0; keywords[i].name; i++ ) {</span>
<span class="lineNum">    3759 </span><span class="lineNoCov">          0 :             if( !ascii_strcasecmp( keywords[i].name, keyword ) )</span>
<span class="lineNum">    3760 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3761 </span>            :         }
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :         if( !keywords[i].name ) {</span>
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :             err = &quot;unknown keyword&quot;;</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3765 </span>            :         }
<span class="lineNum">    3766 </span><span class="lineNoCov">          0 :         if( keywords[i].key != pKEYTYPE &amp;&amp; !para ) {</span>
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :             err = &quot;parameter block does not start with \&quot;Key-Type\&quot;&quot;;</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3769 </span>            :         }
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span><span class="lineNoCov">          0 :         if( keywords[i].key == pKEYTYPE &amp;&amp; para ) {</span>
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :             outctrl.lnr = lnr;</span>
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :             if (proc_parameter_file (ctrl, para, fname, &amp;outctrl, 0 ))</span>
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :               print_status_key_not_created</span>
<span class="lineNum">    3775 </span>            :                 (get_parameter_value (para, pHANDLE));
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :             release_parameter_list( para );</span>
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :             para = NULL;</span>
<span class="lineNum">    3778 </span>            :         }
<span class="lineNum">    3779 </span>            :         else {
<span class="lineNum">    3780 </span><span class="lineNoCov">          0 :             for( r = para; r; r = r-&gt;next ) {</span>
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :                 if( r-&gt;key == keywords[i].key )</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    3783 </span>            :             }
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :             if( r ) {</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :                 err = &quot;duplicate keyword&quot;;</span>
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3787 </span>            :             }
<span class="lineNum">    3788 </span>            :         }
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :         r = xmalloc_clear( sizeof *r + strlen( value ) );</span>
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :         r-&gt;lnr = lnr;</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :         r-&gt;key = keywords[i].key;</span>
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :         strcpy( r-&gt;u.value, value );</span>
<span class="lineNum">    3793 </span><span class="lineNoCov">          0 :         r-&gt;next = para;</span>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :         para = r;</span>
<span class="lineNum">    3795 </span>            :     }
<span class="lineNum">    3796 </span><span class="lineNoCov">          0 :     if( err )</span>
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :         log_error(&quot;%s:%d: %s\n&quot;, fname, lnr, err );</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :     else if( iobuf_error (fp) ) {</span>
<span class="lineNum">    3799 </span><span class="lineNoCov">          0 :         log_error(&quot;%s:%d: read error\n&quot;, fname, lnr);</span>
<span class="lineNum">    3800 </span>            :     }
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :     else if( para ) {</span>
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :         outctrl.lnr = lnr;</span>
<span class="lineNum">    3803 </span><span class="lineNoCov">          0 :         if (proc_parameter_file (ctrl, para, fname, &amp;outctrl, 0 ))</span>
<span class="lineNum">    3804 </span><span class="lineNoCov">          0 :           print_status_key_not_created (get_parameter_value (para, pHANDLE));</span>
<span class="lineNum">    3805 </span>            :     }
<span class="lineNum">    3806 </span>            : 
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :     if( outctrl.use_files ) { /* close open streams */</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :         iobuf_close( outctrl.pub.stream );</span>
<span class="lineNum">    3809 </span>            : 
<span class="lineNum">    3810 </span>            :         /* Must invalidate that ugly cache to actually close it.  */
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :         if (outctrl.pub.fname)</span>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :           iobuf_ioctl (NULL, IOBUF_IOCTL_INVALIDATE_CACHE,</span>
<span class="lineNum">    3813 </span><span class="lineNoCov">          0 :                        0, (char*)outctrl.pub.fname);</span>
<span class="lineNum">    3814 </span>            : 
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :         xfree( outctrl.pub.fname );</span>
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 :         xfree( outctrl.pub.newfname );</span>
<span class="lineNum">    3817 </span>            :     }
<span class="lineNum">    3818 </span>            : 
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :     xfree (line);</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :     release_parameter_list( para );</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :     iobuf_close (fp);</span>
<span class="lineNum">    3822 </span><span class="lineNoCov">          0 :     release_armor_context (outctrl.pub.afx);</span>
<span class="lineNum">    3823 </span>            : }
<span class="lineNum">    3824 </span>            : 
<span class="lineNum">    3825 </span>            : 
<a name="3826"><span class="lineNum">    3826 </span>            : /* Helper for quick_generate_keypair.  */</a>
<span class="lineNum">    3827 </span>            : static struct para_data_s *
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 : quickgen_set_para (struct para_data_s *para, int for_subkey,</span>
<span class="lineNum">    3829 </span>            :                    int algo, int nbits, const char *curve, unsigned int use)
<span class="lineNum">    3830 </span>            : {
<span class="lineNum">    3831 </span>            :   struct para_data_s *r;
<span class="lineNum">    3832 </span>            : 
<span class="lineNum">    3833 </span><span class="lineNoCov">          0 :   r = xmalloc_clear (sizeof *r + 30);</span>
<span class="lineNum">    3834 </span><span class="lineNoCov">          0 :   r-&gt;key = for_subkey? pSUBKEYUSAGE :  pKEYUSAGE;</span>
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :   if (use)</span>
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :     snprintf (r-&gt;u.value, 30, &quot;%s%s%s%s&quot;,</span>
<span class="lineNum">    3837 </span><span class="lineNoCov">          0 :               (use &amp; PUBKEY_USAGE_ENC)?  &quot;encr &quot; : &quot;&quot;,</span>
<span class="lineNum">    3838 </span><span class="lineNoCov">          0 :               (use &amp; PUBKEY_USAGE_SIG)?  &quot;sign &quot; : &quot;&quot;,</span>
<span class="lineNum">    3839 </span><span class="lineNoCov">          0 :               (use &amp; PUBKEY_USAGE_AUTH)? &quot;auth &quot; : &quot;&quot;,</span>
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :               (use &amp; PUBKEY_USAGE_CERT)? &quot;cert &quot; : &quot;&quot;);</span>
<span class="lineNum">    3841 </span>            :   else
<span class="lineNum">    3842 </span><span class="lineNoCov">          0 :     strcpy (r-&gt;u.value, for_subkey ? &quot;encr&quot; : &quot;sign&quot;);</span>
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    3844 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 :   r = xmalloc_clear (sizeof *r + 20);</span>
<span class="lineNum">    3846 </span><span class="lineNoCov">          0 :   r-&gt;key = for_subkey? pSUBKEYTYPE : pKEYTYPE;</span>
<span class="lineNum">    3847 </span><span class="lineNoCov">          0 :   snprintf (r-&gt;u.value, 20, &quot;%d&quot;, algo);</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    3850 </span>            : 
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :   if (curve)</span>
<span class="lineNum">    3852 </span>            :     {
<span class="lineNum">    3853 </span><span class="lineNoCov">          0 :       r = xmalloc_clear (sizeof *r + strlen (curve));</span>
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :       r-&gt;key = for_subkey? pSUBKEYCURVE : pKEYCURVE;</span>
<span class="lineNum">    3855 </span><span class="lineNoCov">          0 :       strcpy (r-&gt;u.value, curve);</span>
<span class="lineNum">    3856 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    3857 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    3858 </span>            :     }
<span class="lineNum">    3859 </span>            :   else
<span class="lineNum">    3860 </span>            :     {
<span class="lineNum">    3861 </span><span class="lineNoCov">          0 :       r = xmalloc_clear (sizeof *r + 20);</span>
<span class="lineNum">    3862 </span><span class="lineNoCov">          0 :       r-&gt;key = for_subkey? pSUBKEYLENGTH : pKEYLENGTH;</span>
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :       sprintf (r-&gt;u.value, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    3866 </span>            :     }
<span class="lineNum">    3867 </span>            : 
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :   return para;</span>
<span class="lineNum">    3869 </span>            : }
<span class="lineNum">    3870 </span>            : 
<span class="lineNum">    3871 </span>            : 
<span class="lineNum">    3872 </span>            : /*
<span class="lineNum">    3873 </span>            :  * Unattended generation of a standard key.
<a name="3874"><span class="lineNum">    3874 </span>            :  */</a>
<span class="lineNum">    3875 </span>            : void
<span class="lineNum">    3876 </span><span class="lineNoCov">          0 : quick_generate_keypair (ctrl_t ctrl, const char *uid, const char *algostr,</span>
<span class="lineNum">    3877 </span>            :                         const char *usagestr, const char *expirestr)
<span class="lineNum">    3878 </span>            : {
<span class="lineNum">    3879 </span>            :   gpg_error_t err;
<span class="lineNum">    3880 </span><span class="lineNoCov">          0 :   struct para_data_s *para = NULL;</span>
<span class="lineNum">    3881 </span>            :   struct para_data_s *r;
<span class="lineNum">    3882 </span>            :   struct output_control_s outctrl;
<span class="lineNum">    3883 </span>            :   int use_tty;
<span class="lineNum">    3884 </span>            : 
<span class="lineNum">    3885 </span><span class="lineNoCov">          0 :   memset (&amp;outctrl, 0, sizeof outctrl);</span>
<span class="lineNum">    3886 </span>            : 
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :   use_tty = (!opt.batch &amp;&amp; !opt.answer_yes</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :              &amp;&amp; !*algostr &amp;&amp; !*usagestr &amp;&amp; !*expirestr</span>
<span class="lineNum">    3889 </span><span class="lineNoCov">          0 :              &amp;&amp; !cpr_enabled ()</span>
<span class="lineNum">    3890 </span><span class="lineNoCov">          0 :              &amp;&amp; gnupg_isatty (fileno (stdin))</span>
<span class="lineNum">    3891 </span><span class="lineNoCov">          0 :              &amp;&amp; gnupg_isatty (fileno (stdout))</span>
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :              &amp;&amp; gnupg_isatty (fileno (stderr)));</span>
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span><span class="lineNoCov">          0 :   r = xmalloc_clear (sizeof *r + strlen (uid));</span>
<span class="lineNum">    3895 </span><span class="lineNoCov">          0 :   r-&gt;key = pUSERID;</span>
<span class="lineNum">    3896 </span><span class="lineNoCov">          0 :   strcpy (r-&gt;u.value, uid);</span>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    3898 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    3899 </span>            : 
<span class="lineNum">    3900 </span><span class="lineNoCov">          0 :   uid = trim_spaces (r-&gt;u.value);</span>
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 :   if (!*uid || (!opt.allow_freeform_uid &amp;&amp; !is_valid_user_id (uid)))</span>
<span class="lineNum">    3902 </span>            :     {
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :       log_error (_(&quot;Key generation failed: %s\n&quot;),</span>
<span class="lineNum">    3904 </span>            :                  gpg_strerror (GPG_ERR_INV_USER_ID));
<span class="lineNum">    3905 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    3906 </span>            :     }
<span class="lineNum">    3907 </span>            : 
<span class="lineNum">    3908 </span>            :   /* If gpg is directly used on the console ask whether a key with the
<span class="lineNum">    3909 </span>            :      given user id shall really be created.  */
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :   if (use_tty)</span>
<span class="lineNum">    3911 </span>            :     {
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :       tty_printf (_(&quot;About to create a key for:\n    \&quot;%s\&quot;\n\n&quot;), uid);</span>
<span class="lineNum">    3913 </span><span class="lineNoCov">          0 :       if (!cpr_get_answer_is_yes_def (&quot;quick_keygen.okay&quot;,</span>
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :                                       _(&quot;Continue? (Y/n) &quot;), 1))</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :         goto leave;</span>
<span class="lineNum">    3916 </span>            :     }
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span>            :   /* Check whether such a user ID already exists.  */
<span class="lineNum">    3919 </span>            :   {
<span class="lineNum">    3920 </span>            :     KEYDB_HANDLE kdbhd;
<span class="lineNum">    3921 </span>            :     KEYDB_SEARCH_DESC desc;
<span class="lineNum">    3922 </span>            : 
<span class="lineNum">    3923 </span><span class="lineNoCov">          0 :     memset (&amp;desc, 0, sizeof desc);</span>
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :     desc.mode = KEYDB_SEARCH_MODE_EXACT;</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :     desc.u.name = uid;</span>
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :     kdbhd = keydb_new ();</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :     if (!kdbhd)</span>
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    3930 </span>            : 
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :     err = keydb_search (kdbhd, &amp;desc, 1, NULL);</span>
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :     keydb_release (kdbhd);</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :     if (gpg_err_code (err) != GPG_ERR_NOT_FOUND)</span>
<span class="lineNum">    3934 </span>            :       {
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :         log_info (_(&quot;A key for \&quot;%s\&quot; already exists\n&quot;), uid);</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :         if (opt.answer_yes)</span>
<span class="lineNum">    3937 </span>            :           ;
<span class="lineNum">    3938 </span><span class="lineNoCov">          0 :         else if (!use_tty</span>
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :                  || !cpr_get_answer_is_yes_def (&quot;quick_keygen.force&quot;,</span>
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :                                                 _(&quot;Create anyway? (y/N) &quot;), 0))</span>
<span class="lineNum">    3941 </span>            :           {
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 :             write_status_error (&quot;genkey&quot;, gpg_error (304));</span>
<span class="lineNum">    3943 </span><span class="lineNoCov">          0 :             log_inc_errorcount ();  /* we used log_info */</span>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :             goto leave;</span>
<span class="lineNum">    3945 </span>            :           }
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :         log_info (_(&quot;creating anyway\n&quot;));</span>
<span class="lineNum">    3947 </span>            :       }
<span class="lineNum">    3948 </span>            :   }
<span class="lineNum">    3949 </span>            : 
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :   if (!*expirestr || strcmp (expirestr, &quot;-&quot;) == 0)</span>
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :     expirestr = default_expiration_interval;</span>
<span class="lineNum">    3952 </span>            : 
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :   if ((!*algostr || !strcmp (algostr, &quot;default&quot;)</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :        || !strcmp (algostr, &quot;future-default&quot;))</span>
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :       &amp;&amp; (!*usagestr || !strcmp (usagestr, &quot;default&quot;)</span>
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :           || !strcmp (usagestr, &quot;-&quot;)))</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    3958 </span>            :       /* Use default key parameters.  */
<span class="lineNum">    3959 </span>            :       int algo, subalgo;
<span class="lineNum">    3960 </span>            :       unsigned int size, subsize;
<span class="lineNum">    3961 </span>            :       unsigned int keyuse, subkeyuse;
<span class="lineNum">    3962 </span>            :       const char *curve, *subcurve;
<span class="lineNum">    3963 </span>            : 
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :       err = parse_key_parameter_string (algostr, -1,</span>
<span class="lineNum">    3965 </span>            :                                         &amp;algo, &amp;size, &amp;keyuse, &amp;curve,
<span class="lineNum">    3966 </span>            :                                         &amp;subalgo, &amp;subsize, &amp;subkeyuse,
<span class="lineNum">    3967 </span>            :                                         &amp;subcurve);
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    3969 </span>            :         {
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :           log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err));</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    3972 </span>            :         }
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :       para = quickgen_set_para (para, 0, algo, size, curve, keyuse);</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :       if (subalgo)</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :         para = quickgen_set_para (para, 1,</span>
<span class="lineNum">    3977 </span>            :                                   subalgo, subsize, subcurve, subkeyuse);
<span class="lineNum">    3978 </span>            : 
<span class="lineNum">    3979 </span><span class="lineNoCov">          0 :       if (*expirestr)</span>
<span class="lineNum">    3980 </span>            :         {
<span class="lineNum">    3981 </span>            :           u32 expire;
<span class="lineNum">    3982 </span>            : 
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 :           expire = parse_expire_string (expirestr);</span>
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :           if (expire == (u32)-1 )</span>
<span class="lineNum">    3985 </span>            :             {
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 :               err = gpg_error (GPG_ERR_INV_VALUE);</span>
<span class="lineNum">    3987 </span><span class="lineNoCov">          0 :               log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err));</span>
<span class="lineNum">    3988 </span><span class="lineNoCov">          0 :               goto leave;</span>
<span class="lineNum">    3989 </span>            :             }
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :           r = xmalloc_clear (sizeof *r + 20);</span>
<span class="lineNum">    3991 </span><span class="lineNoCov">          0 :           r-&gt;key = pKEYEXPIRE;</span>
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :           r-&gt;u.expire = expire;</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    3995 </span>            :         }
<span class="lineNum">    3996 </span>            :     }
<span class="lineNum">    3997 </span>            :   else
<span class="lineNum">    3998 </span>            :     {
<span class="lineNum">    3999 </span>            :       /* Extended unattended mode.  Creates only the primary key. */
<span class="lineNum">    4000 </span>            :       int algo;
<span class="lineNum">    4001 </span>            :       unsigned int use;
<span class="lineNum">    4002 </span>            :       u32 expire;
<span class="lineNum">    4003 </span>            :       unsigned int nbits;
<span class="lineNum">    4004 </span>            :       char *curve;
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span><span class="lineNoCov">          0 :       err = parse_algo_usage_expire (ctrl, 0, algostr, usagestr, expirestr,</span>
<span class="lineNum">    4007 </span>            :                                      &amp;algo, &amp;use, &amp;expire, &amp;nbits, &amp;curve);
<span class="lineNum">    4008 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    4009 </span>            :         {
<span class="lineNum">    4010 </span><span class="lineNoCov">          0 :           log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err) );</span>
<span class="lineNum">    4011 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    4012 </span>            :         }
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span><span class="lineNoCov">          0 :       para = quickgen_set_para (para, 0, algo, nbits, curve, use);</span>
<span class="lineNum">    4015 </span><span class="lineNoCov">          0 :       r = xmalloc_clear (sizeof *r + 20);</span>
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYEXPIRE;</span>
<span class="lineNum">    4017 </span><span class="lineNoCov">          0 :       r-&gt;u.expire = expire;</span>
<span class="lineNum">    4018 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4020 </span>            :     }
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span>            :   /* If the pinentry loopback mode is not and we have a static
<span class="lineNum">    4023 </span>            :      passphrase (i.e. set with --passphrase{,-fd,-file} while in batch
<span class="lineNum">    4024 </span>            :      mode), we use that passphrase for the new key.  */
<span class="lineNum">    4025 </span><span class="lineNoCov">          0 :   if (opt.pinentry_mode != PINENTRY_MODE_LOOPBACK</span>
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 :       &amp;&amp; have_static_passphrase ())</span>
<span class="lineNum">    4027 </span>            :     {
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :       const char *s = get_static_passphrase ();</span>
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :       r = xmalloc_clear (sizeof *r + strlen (s));</span>
<span class="lineNum">    4031 </span><span class="lineNoCov">          0 :       r-&gt;key = pPASSPHRASE;</span>
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 :       strcpy (r-&gt;u.value, s);</span>
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4035 </span>            :     }
<span class="lineNum">    4036 </span>            : 
<span class="lineNum">    4037 </span><span class="lineNoCov">          0 :   proc_parameter_file (ctrl, para, &quot;[internal]&quot;, &amp;outctrl, 0);</span>
<span class="lineNum">    4038 </span>            : 
<span class="lineNum">    4039 </span>            :  leave:
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 :   release_parameter_list (para);</span>
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span>            : /*
<span class="lineNum">    4045 </span>            :  * Generate a keypair (fname is only used in batch mode) If
<span class="lineNum">    4046 </span>            :  * CARD_SERIALNO is not NULL the function will create the keys on an
<span class="lineNum">    4047 </span>            :  * OpenPGP Card.  If CARD_BACKUP_KEY has been set and CARD_SERIALNO is
<span class="lineNum">    4048 </span>            :  * NOT NULL, the encryption key for the card is generated on the host,
<span class="lineNum">    4049 </span>            :  * imported to the card and a backup file created by gpg-agent.  If
<span class="lineNum">    4050 </span>            :  * FULL is not set only the basic prompts are used (except for batch
<span class="lineNum">    4051 </span>            :  * mode).
<a name="4052"><span class="lineNum">    4052 </span>            :  */</a>
<span class="lineNum">    4053 </span>            : void
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 : generate_keypair (ctrl_t ctrl, int full, const char *fname,</span>
<span class="lineNum">    4055 </span>            :                   const char *card_serialno, int card_backup_key)
<span class="lineNum">    4056 </span>            : {
<span class="lineNum">    4057 </span>            :   gpg_error_t err;
<span class="lineNum">    4058 </span>            :   unsigned int nbits;
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 :   char *uid = NULL;</span>
<span class="lineNum">    4060 </span>            :   int algo;
<span class="lineNum">    4061 </span>            :   unsigned int use;
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :   int both = 0;</span>
<span class="lineNum">    4063 </span>            :   u32 expire;
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :   struct para_data_s *para = NULL;</span>
<span class="lineNum">    4065 </span>            :   struct para_data_s *r;
<span class="lineNum">    4066 </span>            :   struct output_control_s outctrl;
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span>            : #ifndef ENABLE_CARD_SUPPORT
<span class="lineNum">    4069 </span>            :   (void)card_backup_key;
<span class="lineNum">    4070 </span>            : #endif
<span class="lineNum">    4071 </span>            : 
<span class="lineNum">    4072 </span><span class="lineNoCov">          0 :   memset( &amp;outctrl, 0, sizeof( outctrl ) );</span>
<span class="lineNum">    4073 </span>            : 
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :   if (opt.batch &amp;&amp; card_serialno)</span>
<span class="lineNum">    4075 </span>            :     {
<span class="lineNum">    4076 </span>            :       /* We don't yet support unattended key generation. */
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :       log_error (_(&quot;can't do this in batch mode\n&quot;));</span>
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4079 </span>            :     }
<span class="lineNum">    4080 </span>            : 
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :   if (opt.batch)</span>
<span class="lineNum">    4082 </span>            :     {
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 :       read_parameter_file (ctrl, fname);</span>
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4085 </span>            :     }
<span class="lineNum">    4086 </span>            : 
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :   if (card_serialno)</span>
<span class="lineNum">    4088 </span>            :     {
<span class="lineNum">    4089 </span>            : #ifdef ENABLE_CARD_SUPPORT
<span class="lineNum">    4090 </span>            :       struct agent_card_info_s info;
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 :       memset (&amp;info, 0, sizeof (info));</span>
<span class="lineNum">    4093 </span><span class="lineNoCov">          0 :       err = agent_scd_getattr (&quot;KEY-ATTR&quot;, &amp;info);</span>
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    4095 </span>            :         {
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 :           log_error (_(&quot;error getting current key info: %s\n&quot;),</span>
<span class="lineNum">    4097 </span>            :                      gpg_strerror (err));
<span class="lineNum">    4098 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    4099 </span>            :         }
<span class="lineNum">    4100 </span>            : 
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + strlen (card_serialno) );</span>
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :       r-&gt;key = pSERIALNO;</span>
<span class="lineNum">    4103 </span><span class="lineNoCov">          0 :       strcpy( r-&gt;u.value, card_serialno);</span>
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4108 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYTYPE;</span>
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :       sprintf( r-&gt;u.value, &quot;%d&quot;, info.key_attr[0].algo );</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4112 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4113 </span><span class="lineNoCov">          0 :       r-&gt;key = pKEYUSAGE;</span>
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :       strcpy (r-&gt;u.value, &quot;sign&quot;);</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4116 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4117 </span>            : 
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :       r-&gt;key = pSUBKEYTYPE;</span>
<span class="lineNum">    4120 </span><span class="lineNoCov">          0 :       sprintf( r-&gt;u.value, &quot;%d&quot;, info.key_attr[1].algo );</span>
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4122 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :       r-&gt;key = pSUBKEYUSAGE;</span>
<span class="lineNum">    4125 </span><span class="lineNoCov">          0 :       strcpy (r-&gt;u.value, &quot;encrypt&quot;);</span>
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :       if (info.key_attr[1].algo == PUBKEY_ALGO_RSA)</span>
<span class="lineNum">    4129 </span>            :         {
<span class="lineNum">    4130 </span><span class="lineNoCov">          0 :           r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 :           r-&gt;key = pSUBKEYLENGTH;</span>
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 :           sprintf( r-&gt;u.value, &quot;%u&quot;, info.key_attr[1].nbits);</span>
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    4135 </span>            :         }
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :       else if (info.key_attr[1].algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :                || info.key_attr[1].algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :                || info.key_attr[1].algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4139 </span>            :         {
<span class="lineNum">    4140 </span><span class="lineNoCov">          0 :           r = xcalloc (1, sizeof *r + strlen (info.key_attr[1].curve));</span>
<span class="lineNum">    4141 </span><span class="lineNoCov">          0 :           r-&gt;key = pSUBKEYCURVE;</span>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 :           strcpy (r-&gt;u.value, info.key_attr[1].curve);</span>
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    4144 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    4145 </span>            :         }
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span><span class="lineNoCov">          0 :       r = xcalloc (1, sizeof *r + 20 );</span>
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 :       r-&gt;key = pAUTHKEYTYPE;</span>
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :       sprintf( r-&gt;u.value, &quot;%d&quot;, info.key_attr[2].algo );</span>
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :       r-&gt;next = para;</span>
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :       para = r;</span>
<span class="lineNum">    4152 </span>            : 
<span class="lineNum">    4153 </span><span class="lineNoCov">          0 :       if (card_backup_key)</span>
<span class="lineNum">    4154 </span>            :         {
<span class="lineNum">    4155 </span><span class="lineNoCov">          0 :           r = xcalloc (1, sizeof *r + 1);</span>
<span class="lineNum">    4156 </span><span class="lineNoCov">          0 :           r-&gt;key = pCARDBACKUPKEY;</span>
<span class="lineNum">    4157 </span><span class="lineNoCov">          0 :           strcpy (r-&gt;u.value, &quot;1&quot;);</span>
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    4160 </span>            :         }
<span class="lineNum">    4161 </span>            : #endif /*ENABLE_CARD_SUPPORT*/
<span class="lineNum">    4162 </span>            :     }
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :   else if (full)  /* Full featured key generation.  */</span>
<span class="lineNum">    4164 </span>            :     {
<span class="lineNum">    4165 </span>            :       int subkey_algo;
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 :       char *key_from_hexgrip = NULL;</span>
<span class="lineNum">    4167 </span>            : 
<span class="lineNum">    4168 </span><span class="lineNoCov">          0 :       algo = ask_algo (ctrl, 0, &amp;subkey_algo, &amp;use, &amp;key_from_hexgrip);</span>
<span class="lineNum">    4169 </span><span class="lineNoCov">          0 :       if (key_from_hexgrip)</span>
<span class="lineNum">    4170 </span>            :         {
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :           r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :           r-&gt;key = pKEYTYPE;</span>
<span class="lineNum">    4173 </span><span class="lineNoCov">          0 :           sprintf( r-&gt;u.value, &quot;%d&quot;, algo);</span>
<span class="lineNum">    4174 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    4176 </span>            : 
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :           if (use)</span>
<span class="lineNum">    4178 </span>            :             {
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 25 );</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :               r-&gt;key = pKEYUSAGE;</span>
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :               sprintf( r-&gt;u.value, &quot;%s%s%s&quot;,</span>
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :                        (use &amp; PUBKEY_USAGE_SIG)? &quot;sign &quot;:&quot;&quot;,</span>
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :                        (use &amp; PUBKEY_USAGE_ENC)? &quot;encrypt &quot;:&quot;&quot;,</span>
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :                        (use &amp; PUBKEY_USAGE_AUTH)? &quot;auth&quot;:&quot;&quot; );</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4186 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4187 </span>            :             }
<span class="lineNum">    4188 </span>            : 
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :           r = xmalloc_clear( sizeof *r + 40 );</span>
<span class="lineNum">    4190 </span><span class="lineNoCov">          0 :           r-&gt;key = pKEYGRIP;</span>
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :           strcpy (r-&gt;u.value, key_from_hexgrip);</span>
<span class="lineNum">    4192 </span><span class="lineNoCov">          0 :           r-&gt;next = para;</span>
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :           para = r;</span>
<span class="lineNum">    4194 </span>            : 
<span class="lineNum">    4195 </span><span class="lineNoCov">          0 :           xfree (key_from_hexgrip);</span>
<span class="lineNum">    4196 </span>            :         }
<span class="lineNum">    4197 </span>            :       else
<span class="lineNum">    4198 </span>            :         {
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :           char *curve = NULL;</span>
<span class="lineNum">    4200 </span>            : 
<span class="lineNum">    4201 </span><span class="lineNoCov">          0 :           if (subkey_algo)</span>
<span class="lineNum">    4202 </span>            :             {
<span class="lineNum">    4203 </span>            :               /* Create primary and subkey at once.  */
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :               both = 1;</span>
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4207 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4208 </span>            :                 {
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :                   curve = ask_curve (&amp;algo, &amp;subkey_algo);</span>
<span class="lineNum">    4210 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4211 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYTYPE;</span>
<span class="lineNum">    4212 </span><span class="lineNoCov">          0 :                   sprintf( r-&gt;u.value, &quot;%d&quot;, algo);</span>
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :                   nbits = 0;</span>
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear (sizeof *r + strlen (curve));</span>
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYCURVE;</span>
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :                   strcpy (r-&gt;u.value, curve);</span>
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4220 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4221 </span>            :                 }
<span class="lineNum">    4222 </span>            :               else
<span class="lineNum">    4223 </span>            :                 {
<span class="lineNum">    4224 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYTYPE;</span>
<span class="lineNum">    4226 </span><span class="lineNoCov">          0 :                   sprintf( r-&gt;u.value, &quot;%d&quot;, algo);</span>
<span class="lineNum">    4227 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4229 </span><span class="lineNoCov">          0 :                   nbits = ask_keysize (algo, 0);</span>
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYLENGTH;</span>
<span class="lineNum">    4232 </span><span class="lineNoCov">          0 :                   sprintf( r-&gt;u.value, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4235 </span>            :                 }
<span class="lineNum">    4236 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4237 </span><span class="lineNoCov">          0 :               r-&gt;key = pKEYUSAGE;</span>
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :               strcpy( r-&gt;u.value, &quot;sign&quot; );</span>
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4241 </span>            : 
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :               r-&gt;key = pSUBKEYTYPE;</span>
<span class="lineNum">    4244 </span><span class="lineNoCov">          0 :               sprintf( r-&gt;u.value, &quot;%d&quot;, subkey_algo);</span>
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4246 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :               r-&gt;key = pSUBKEYUSAGE;</span>
<span class="lineNum">    4249 </span><span class="lineNoCov">          0 :               strcpy( r-&gt;u.value, &quot;encrypt&quot; );</span>
<span class="lineNum">    4250 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4251 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4252 </span>            : 
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4255 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4256 </span>            :                 {
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 :                   if (algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4258 </span><span class="lineNoCov">          0 :                       &amp;&amp; subkey_algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4259 </span>            :                     {
<span class="lineNum">    4260 </span>            :                       /* Need to switch to a different curve for the
<span class="lineNum">    4261 </span>            :                          encryption key.  */
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :                       xfree (curve);</span>
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :                       curve = xstrdup (&quot;Curve25519&quot;);</span>
<span class="lineNum">    4264 </span>            :                     }
<span class="lineNum">    4265 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear (sizeof *r + strlen (curve));</span>
<span class="lineNum">    4266 </span><span class="lineNoCov">          0 :                   r-&gt;key = pSUBKEYCURVE;</span>
<span class="lineNum">    4267 </span><span class="lineNoCov">          0 :                   strcpy (r-&gt;u.value, curve);</span>
<span class="lineNum">    4268 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4269 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4270 </span>            :                 }
<span class="lineNum">    4271 </span>            :             }
<span class="lineNum">    4272 </span>            :           else /* Create only a single key.  */
<span class="lineNum">    4273 </span>            :             {
<span class="lineNum">    4274 </span>            :               /* For ECC we need to ask for the curve before storing the
<span class="lineNum">    4275 </span>            :                  algo because ask_curve may change the algo.  */
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :               if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    4277 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 :                   || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4279 </span>            :                 {
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :                   curve = ask_curve (&amp;algo, NULL);</span>
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear (sizeof *r + strlen (curve));</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYCURVE;</span>
<span class="lineNum">    4283 </span><span class="lineNoCov">          0 :                   strcpy (r-&gt;u.value, curve);</span>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4286 </span>            :                 }
<span class="lineNum">    4287 </span>            : 
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :               r-&gt;key = pKEYTYPE;</span>
<span class="lineNum">    4290 </span><span class="lineNoCov">          0 :               sprintf( r-&gt;u.value, &quot;%d&quot;, algo );</span>
<span class="lineNum">    4291 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4292 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4293 </span>            : 
<span class="lineNum">    4294 </span><span class="lineNoCov">          0 :               if (use)</span>
<span class="lineNum">    4295 </span>            :                 {
<span class="lineNum">    4296 </span><span class="lineNoCov">          0 :                   r = xmalloc_clear( sizeof *r + 25 );</span>
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :                   r-&gt;key = pKEYUSAGE;</span>
<span class="lineNum">    4298 </span><span class="lineNoCov">          0 :                   sprintf( r-&gt;u.value, &quot;%s%s%s&quot;,</span>
<span class="lineNum">    4299 </span><span class="lineNoCov">          0 :                            (use &amp; PUBKEY_USAGE_SIG)? &quot;sign &quot;:&quot;&quot;,</span>
<span class="lineNum">    4300 </span><span class="lineNoCov">          0 :                            (use &amp; PUBKEY_USAGE_ENC)? &quot;encrypt &quot;:&quot;&quot;,</span>
<span class="lineNum">    4301 </span><span class="lineNoCov">          0 :                            (use &amp; PUBKEY_USAGE_AUTH)? &quot;auth&quot;:&quot;&quot; );</span>
<span class="lineNum">    4302 </span><span class="lineNoCov">          0 :                   r-&gt;next = para;</span>
<span class="lineNum">    4303 </span><span class="lineNoCov">          0 :                   para = r;</span>
<span class="lineNum">    4304 </span>            :                 }
<span class="lineNum">    4305 </span><span class="lineNoCov">          0 :               nbits = 0;</span>
<span class="lineNum">    4306 </span>            :             }
<span class="lineNum">    4307 </span>            : 
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :           if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    4309 </span><span class="lineNoCov">          0 :               || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    4310 </span><span class="lineNoCov">          0 :               || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    4311 </span>            :             {
<span class="lineNum">    4312 </span>            :               /* The curve has already been set.  */
<span class="lineNum">    4313 </span>            :             }
<span class="lineNum">    4314 </span>            :           else
<span class="lineNum">    4315 </span>            :             {
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :               nbits = ask_keysize (both? subkey_algo : algo, nbits);</span>
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :               r = xmalloc_clear( sizeof *r + 20 );</span>
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :               r-&gt;key = both? pSUBKEYLENGTH : pKEYLENGTH;</span>
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :               sprintf( r-&gt;u.value, &quot;%u&quot;, nbits);</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :               r-&gt;next = para;</span>
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :               para = r;</span>
<span class="lineNum">    4322 </span>            :             }
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :           xfree (curve);</span>
<span class="lineNum">    4325 </span>            :         }
<span class="lineNum">    4326 </span>            :     }
<span class="lineNum">    4327 </span>            :   else /* Default key generation.  */
<span class="lineNum">    4328 </span>            :     {
<span class="lineNum">    4329 </span>            :       int subalgo;
<span class="lineNum">    4330 </span>            :       unsigned int size, subsize;
<span class="lineNum">    4331 </span>            :       unsigned int keyuse, subkeyuse;
<span class="lineNum">    4332 </span>            :       const char *curve, *subcurve;
<span class="lineNum">    4333 </span>            : 
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 :       tty_printf ( _(&quot;Note: Use \&quot;%s %s\&quot;&quot;</span>
<span class="lineNum">    4335 </span>            :                      &quot; for a full featured key generation dialog.\n&quot;),
<span class="lineNum">    4336 </span>            : #if USE_GPG2_HACK
<span class="lineNum">    4337 </span>            :                    GPG_NAME &quot;2&quot;
<span class="lineNum">    4338 </span>            : #else
<span class="lineNum">    4339 </span>            :                    GPG_NAME
<span class="lineNum">    4340 </span>            : #endif
<span class="lineNum">    4341 </span>            :                    , &quot;--full-generate-key&quot; );
<span class="lineNum">    4342 </span>            : 
<span class="lineNum">    4343 </span><span class="lineNoCov">          0 :       err = parse_key_parameter_string (NULL, -1,</span>
<span class="lineNum">    4344 </span>            :                                         &amp;algo, &amp;size, &amp;keyuse, &amp;curve,
<span class="lineNum">    4345 </span>            :                                         &amp;subalgo, &amp;subsize,
<span class="lineNum">    4346 </span>            :                                         &amp;subkeyuse, &amp;subcurve);
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    4348 </span>            :         {
<span class="lineNum">    4349 </span><span class="lineNoCov">          0 :           log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err));</span>
<span class="lineNum">    4350 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    4351 </span>            :         }
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :       para = quickgen_set_para (para, 0, algo, size, curve, keyuse);</span>
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :       if (subalgo)</span>
<span class="lineNum">    4354 </span><span class="lineNoCov">          0 :         para = quickgen_set_para (para, 1,</span>
<span class="lineNum">    4355 </span>            :                                   subalgo, subsize, subcurve, subkeyuse);
<span class="lineNum">    4356 </span>            : 
<span class="lineNum">    4357 </span>            : 
<span class="lineNum">    4358 </span>            :     }
<span class="lineNum">    4359 </span>            : 
<span class="lineNum">    4360 </span>            : 
<span class="lineNum">    4361 </span><span class="lineNoCov">          0 :   expire = full? ask_expire_interval (0, NULL)</span>
<span class="lineNum">    4362 </span><span class="lineNoCov">          0 :                : parse_expire_string (default_expiration_interval);</span>
<span class="lineNum">    4363 </span><span class="lineNoCov">          0 :   r = xcalloc (1, sizeof *r + 20);</span>
<span class="lineNum">    4364 </span><span class="lineNoCov">          0 :   r-&gt;key = pKEYEXPIRE;</span>
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :   r-&gt;u.expire = expire;</span>
<span class="lineNum">    4366 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    4368 </span><span class="lineNoCov">          0 :   r = xcalloc (1, sizeof *r + 20);</span>
<span class="lineNum">    4369 </span><span class="lineNoCov">          0 :   r-&gt;key = pSUBKEYEXPIRE;</span>
<span class="lineNum">    4370 </span><span class="lineNoCov">          0 :   r-&gt;u.expire = expire;</span>
<span class="lineNum">    4371 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    4372 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    4373 </span>            : 
<span class="lineNum">    4374 </span><span class="lineNoCov">          0 :   uid = ask_user_id (0, full, NULL);</span>
<span class="lineNum">    4375 </span><span class="lineNoCov">          0 :   if (!uid)</span>
<span class="lineNum">    4376 </span>            :     {
<span class="lineNum">    4377 </span><span class="lineNoCov">          0 :       log_error(_(&quot;Key generation canceled.\n&quot;));</span>
<span class="lineNum">    4378 </span><span class="lineNoCov">          0 :       release_parameter_list( para );</span>
<span class="lineNum">    4379 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4380 </span>            :     }
<span class="lineNum">    4381 </span><span class="lineNoCov">          0 :   r = xcalloc (1, sizeof *r + strlen (uid));</span>
<span class="lineNum">    4382 </span><span class="lineNoCov">          0 :   r-&gt;key = pUSERID;</span>
<span class="lineNum">    4383 </span><span class="lineNoCov">          0 :   strcpy (r-&gt;u.value, uid);</span>
<span class="lineNum">    4384 </span><span class="lineNoCov">          0 :   r-&gt;next = para;</span>
<span class="lineNum">    4385 </span><span class="lineNoCov">          0 :   para = r;</span>
<span class="lineNum">    4386 </span>            : 
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 :   proc_parameter_file (ctrl, para, &quot;[internal]&quot;, &amp;outctrl, !!card_serialno);</span>
<span class="lineNum">    4388 </span><span class="lineNoCov">          0 :   release_parameter_list (para);</span>
<span class="lineNum">    4389 </span>            : }
<span class="lineNum">    4390 </span>            : 
<span class="lineNum">    4391 </span>            : 
<a name="4392"><span class="lineNum">    4392 </span>            : /* Create and delete a dummy packet to start off a list of kbnodes. */</a>
<span class="lineNum">    4393 </span>            : static void
<span class="lineNum">    4394 </span><span class="lineNoCov">          0 : start_tree(KBNODE *tree)</span>
<span class="lineNum">    4395 </span>            : {
<span class="lineNum">    4396 </span>            :   PACKET *pkt;
<span class="lineNum">    4397 </span>            : 
<span class="lineNum">    4398 </span><span class="lineNoCov">          0 :   pkt=xmalloc_clear(sizeof(*pkt));</span>
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype=PKT_NONE;</span>
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :   *tree=new_kbnode(pkt);</span>
<span class="lineNum">    4401 </span><span class="lineNoCov">          0 :   delete_kbnode(*tree);</span>
<span class="lineNum">    4402 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4403 </span>            : 
<span class="lineNum">    4404 </span>            : 
<a name="4405"><span class="lineNum">    4405 </span>            : /* Write the *protected* secret key to the file.  */</a>
<span class="lineNum">    4406 </span>            : static gpg_error_t
<span class="lineNum">    4407 </span><span class="lineNoCov">          0 : card_write_key_to_backup_file (PKT_public_key *sk, const char *backup_dir)</span>
<span class="lineNum">    4408 </span>            : {
<span class="lineNum">    4409 </span><span class="lineNoCov">          0 :   gpg_error_t err = 0;</span>
<span class="lineNum">    4410 </span>            :   int rc;
<span class="lineNum">    4411 </span>            :   char keyid_buffer[2 * 8 + 1];
<span class="lineNum">    4412 </span>            :   char name_buffer[50];
<span class="lineNum">    4413 </span>            :   char *fname;
<span class="lineNum">    4414 </span>            :   IOBUF fp;
<span class="lineNum">    4415 </span>            :   mode_t oldmask;
<span class="lineNum">    4416 </span><span class="lineNoCov">          0 :   PACKET *pkt = NULL;</span>
<span class="lineNum">    4417 </span>            : 
<span class="lineNum">    4418 </span><span class="lineNoCov">          0 :   format_keyid (pk_keyid (sk), KF_LONG, keyid_buffer, sizeof (keyid_buffer));</span>
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :   snprintf (name_buffer, sizeof name_buffer, &quot;sk_%s.gpg&quot;, keyid_buffer);</span>
<span class="lineNum">    4420 </span>            : 
<span class="lineNum">    4421 </span><span class="lineNoCov">          0 :   fname = make_filename (backup_dir, name_buffer, NULL);</span>
<span class="lineNum">    4422 </span>            :   /* Note that the umask call is not anymore needed because
<span class="lineNum">    4423 </span>            :      iobuf_create now takes care of it.  However, it does not harm
<span class="lineNum">    4424 </span>            :      and thus we keep it.  */
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :   oldmask = umask (077);</span>
<span class="lineNum">    4426 </span><span class="lineNoCov">          0 :   if (is_secured_filename (fname))</span>
<span class="lineNum">    4427 </span>            :     {
<span class="lineNum">    4428 </span><span class="lineNoCov">          0 :       fp = NULL;</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :       gpg_err_set_errno (EPERM);</span>
<span class="lineNum">    4430 </span>            :     }
<span class="lineNum">    4431 </span>            :   else
<span class="lineNum">    4432 </span><span class="lineNoCov">          0 :     fp = iobuf_create (fname, 1);</span>
<span class="lineNum">    4433 </span><span class="lineNoCov">          0 :   umask (oldmask);</span>
<span class="lineNum">    4434 </span><span class="lineNoCov">          0 :   if (!fp)</span>
<span class="lineNum">    4435 </span>            :     {
<span class="lineNum">    4436 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    4437 </span><span class="lineNoCov">          0 :       log_error (_(&quot;can't create backup file '%s': %s\n&quot;), fname, strerror (errno) );</span>
<span class="lineNum">    4438 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4439 </span>            :     }
<span class="lineNum">    4440 </span>            : 
<span class="lineNum">    4441 </span><span class="lineNoCov">          0 :   pkt = xcalloc (1, sizeof *pkt);</span>
<span class="lineNum">    4442 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = PKT_SECRET_KEY;</span>
<span class="lineNum">    4443 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.secret_key = sk;</span>
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span><span class="lineNoCov">          0 :   rc = build_packet (fp, pkt);</span>
<span class="lineNum">    4446 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    4447 </span>            :     {
<span class="lineNum">    4448 </span><span class="lineNoCov">          0 :       log_error (&quot;build packet failed: %s\n&quot;, gpg_strerror (rc));</span>
<span class="lineNum">    4449 </span><span class="lineNoCov">          0 :       iobuf_cancel (fp);</span>
<span class="lineNum">    4450 </span>            :     }
<span class="lineNum">    4451 </span>            :   else
<span class="lineNum">    4452 </span>            :     {
<span class="lineNum">    4453 </span>            :       char *fprbuf;
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span><span class="lineNoCov">          0 :       iobuf_close (fp);</span>
<span class="lineNum">    4456 </span><span class="lineNoCov">          0 :       iobuf_ioctl (NULL, IOBUF_IOCTL_INVALIDATE_CACHE, 0, (char*)fname);</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :       log_info (_(&quot;Note: backup of card key saved to '%s'\n&quot;), fname);</span>
<span class="lineNum">    4458 </span>            : 
<span class="lineNum">    4459 </span><span class="lineNoCov">          0 :       fprbuf = hexfingerprint (sk, NULL, 0);</span>
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :       write_status_text_and_buffer (STATUS_BACKUP_KEY_CREATED, fprbuf,</span>
<span class="lineNum">    4461 </span>            :                                     fname, strlen (fname), 0);
<span class="lineNum">    4462 </span><span class="lineNoCov">          0 :       xfree (fprbuf);</span>
<span class="lineNum">    4463 </span>            :     }
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span>            :  leave:
<span class="lineNum">    4466 </span><span class="lineNoCov">          0 :   xfree (pkt);</span>
<span class="lineNum">    4467 </span><span class="lineNoCov">          0 :   xfree (fname);</span>
<span class="lineNum">    4468 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    4469 </span>            : }
<span class="lineNum">    4470 </span>            : 
<span class="lineNum">    4471 </span>            : 
<a name="4472"><span class="lineNum">    4472 </span>            : /* Store key to card and make a backup file in OpenPGP format.  */</a>
<span class="lineNum">    4473 </span>            : static gpg_error_t
<span class="lineNum">    4474 </span><span class="lineNoCov">          0 : card_store_key_with_backup (ctrl_t ctrl, PKT_public_key *sub_psk,</span>
<span class="lineNum">    4475 </span>            :                             const char *backup_dir)
<span class="lineNum">    4476 </span>            : {
<span class="lineNum">    4477 </span>            :   PKT_public_key *sk;
<span class="lineNum">    4478 </span>            :   gnupg_isotime_t timestamp;
<span class="lineNum">    4479 </span>            :   gpg_error_t err;
<span class="lineNum">    4480 </span>            :   char *hexgrip;
<span class="lineNum">    4481 </span>            :   int rc;
<span class="lineNum">    4482 </span>            :   struct agent_card_info_s info;
<span class="lineNum">    4483 </span><span class="lineNoCov">          0 :   gcry_cipher_hd_t cipherhd = NULL;</span>
<span class="lineNum">    4484 </span><span class="lineNoCov">          0 :   char *cache_nonce = NULL;</span>
<span class="lineNum">    4485 </span><span class="lineNoCov">          0 :   void *kek = NULL;</span>
<span class="lineNum">    4486 </span>            :   size_t keklen;
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span><span class="lineNoCov">          0 :   sk = copy_public_key (NULL, sub_psk);</span>
<span class="lineNum">    4489 </span><span class="lineNoCov">          0 :   if (!sk)</span>
<span class="lineNum">    4490 </span><span class="lineNoCov">          0 :     return gpg_error_from_syserror ();</span>
<span class="lineNum">    4491 </span>            : 
<span class="lineNum">    4492 </span><span class="lineNoCov">          0 :   epoch2isotime (timestamp, (time_t)sk-&gt;timestamp);</span>
<span class="lineNum">    4493 </span><span class="lineNoCov">          0 :   err = hexkeygrip_from_pk (sk, &amp;hexgrip);</span>
<span class="lineNum">    4494 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4495 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    4496 </span>            : 
<span class="lineNum">    4497 </span><span class="lineNoCov">          0 :   memset(&amp;info, 0, sizeof (info));</span>
<span class="lineNum">    4498 </span><span class="lineNoCov">          0 :   rc = agent_scd_getattr (&quot;SERIALNO&quot;, &amp;info);</span>
<span class="lineNum">    4499 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    4500 </span><span class="lineNoCov">          0 :     return (gpg_error_t)rc;</span>
<span class="lineNum">    4501 </span>            : 
<span class="lineNum">    4502 </span><span class="lineNoCov">          0 :   rc = agent_keytocard (hexgrip, 2, 1, info.serialno, timestamp);</span>
<span class="lineNum">    4503 </span><span class="lineNoCov">          0 :   xfree (info.serialno);</span>
<span class="lineNum">    4504 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    4505 </span>            :     {
<span class="lineNum">    4506 </span><span class="lineNoCov">          0 :       err = (gpg_error_t)rc;</span>
<span class="lineNum">    4507 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4508 </span>            :     }
<span class="lineNum">    4509 </span>            : 
<span class="lineNum">    4510 </span><span class="lineNoCov">          0 :   err = agent_keywrap_key (ctrl, 1, &amp;kek, &amp;keklen);</span>
<span class="lineNum">    4511 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4512 </span>            :     {
<span class="lineNum">    4513 </span><span class="lineNoCov">          0 :       log_error (&quot;error getting the KEK: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    4514 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4515 </span>            :     }
<span class="lineNum">    4516 </span>            : 
<span class="lineNum">    4517 </span><span class="lineNoCov">          0 :   err = gcry_cipher_open (&amp;cipherhd, GCRY_CIPHER_AES128,</span>
<span class="lineNum">    4518 </span>            :                           GCRY_CIPHER_MODE_AESWRAP, 0);
<span class="lineNum">    4519 </span><span class="lineNoCov">          0 :   if (!err)</span>
<span class="lineNum">    4520 </span><span class="lineNoCov">          0 :     err = gcry_cipher_setkey (cipherhd, kek, keklen);</span>
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4522 </span>            :     {
<span class="lineNum">    4523 </span><span class="lineNoCov">          0 :       log_error (&quot;error setting up an encryption context: %s\n&quot;,</span>
<span class="lineNum">    4524 </span>            :                  gpg_strerror (err));
<span class="lineNum">    4525 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4526 </span>            :     }
<span class="lineNum">    4527 </span>            : 
<span class="lineNum">    4528 </span><span class="lineNoCov">          0 :   err = receive_seckey_from_agent (ctrl, cipherhd, 0,</span>
<span class="lineNum">    4529 </span>            :                                    &amp;cache_nonce, hexgrip, sk);
<span class="lineNum">    4530 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4531 </span>            :     {
<span class="lineNum">    4532 </span><span class="lineNoCov">          0 :       log_error (&quot;error getting secret key from agent: %s\n&quot;,</span>
<span class="lineNum">    4533 </span>            :                  gpg_strerror (err));
<span class="lineNum">    4534 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4535 </span>            :     }
<span class="lineNum">    4536 </span>            : 
<span class="lineNum">    4537 </span><span class="lineNoCov">          0 :   err = card_write_key_to_backup_file (sk, backup_dir);</span>
<span class="lineNum">    4538 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4539 </span><span class="lineNoCov">          0 :     log_error (&quot;writing card key to backup file: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    4540 </span>            :   else
<span class="lineNum">    4541 </span>            :     /* Remove secret key data in agent side.  */
<span class="lineNum">    4542 </span><span class="lineNoCov">          0 :     agent_scd_learn (NULL, 1);</span>
<span class="lineNum">    4543 </span>            : 
<span class="lineNum">    4544 </span>            :  leave:
<span class="lineNum">    4545 </span><span class="lineNoCov">          0 :   xfree (cache_nonce);</span>
<span class="lineNum">    4546 </span><span class="lineNoCov">          0 :   gcry_cipher_close (cipherhd);</span>
<span class="lineNum">    4547 </span><span class="lineNoCov">          0 :   xfree (kek);</span>
<span class="lineNum">    4548 </span><span class="lineNoCov">          0 :   xfree (hexgrip);</span>
<span class="lineNum">    4549 </span><span class="lineNoCov">          0 :   free_public_key (sk);</span>
<span class="lineNum">    4550 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    4551 </span>            : }
<span class="lineNum">    4552 </span>            : 
<a name="4553"><span class="lineNum">    4553 </span>            : </a>
<span class="lineNum">    4554 </span>            : static void
<span class="lineNum">    4555 </span><span class="lineNoCov">          0 : do_generate_keypair (ctrl_t ctrl, struct para_data_s *para,</span>
<span class="lineNum">    4556 </span>            :                      struct output_control_s *outctrl, int card)
<span class="lineNum">    4557 </span>            : {
<span class="lineNum">    4558 </span>            :   gpg_error_t err;
<span class="lineNum">    4559 </span><span class="lineNoCov">          0 :   KBNODE pub_root = NULL;</span>
<span class="lineNum">    4560 </span>            :   const char *s;
<span class="lineNum">    4561 </span><span class="lineNoCov">          0 :   PKT_public_key *pri_psk = NULL;</span>
<span class="lineNum">    4562 </span><span class="lineNoCov">          0 :   PKT_public_key *sub_psk = NULL;</span>
<span class="lineNum">    4563 </span>            :   struct revocation_key *revkey;
<span class="lineNum">    4564 </span><span class="lineNoCov">          0 :   int did_sub = 0;</span>
<span class="lineNum">    4565 </span>            :   u32 timestamp;
<span class="lineNum">    4566 </span><span class="lineNoCov">          0 :   char *cache_nonce = NULL;</span>
<span class="lineNum">    4567 </span>            :   int algo;
<span class="lineNum">    4568 </span>            :   u32 expire;
<span class="lineNum">    4569 </span><span class="lineNoCov">          0 :   const char *key_from_hexgrip = NULL;</span>
<span class="lineNum">    4570 </span>            : 
<span class="lineNum">    4571 </span><span class="lineNoCov">          0 :   if (outctrl-&gt;dryrun)</span>
<span class="lineNum">    4572 </span>            :     {
<span class="lineNum">    4573 </span><span class="lineNoCov">          0 :       log_info(&quot;dry-run mode - key generation skipped\n&quot;);</span>
<span class="lineNum">    4574 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4575 </span>            :     }
<span class="lineNum">    4576 </span>            : 
<span class="lineNum">    4577 </span><span class="lineNoCov">          0 :   if ( outctrl-&gt;use_files )</span>
<span class="lineNum">    4578 </span>            :     {
<span class="lineNum">    4579 </span><span class="lineNoCov">          0 :       if ( outctrl-&gt;pub.newfname )</span>
<span class="lineNum">    4580 </span>            :         {
<span class="lineNum">    4581 </span><span class="lineNoCov">          0 :           iobuf_close(outctrl-&gt;pub.stream);</span>
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :           outctrl-&gt;pub.stream = NULL;</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :           if (outctrl-&gt;pub.fname)</span>
<span class="lineNum">    4584 </span><span class="lineNoCov">          0 :             iobuf_ioctl (NULL, IOBUF_IOCTL_INVALIDATE_CACHE,</span>
<span class="lineNum">    4585 </span><span class="lineNoCov">          0 :                          0, (char*)outctrl-&gt;pub.fname);</span>
<span class="lineNum">    4586 </span><span class="lineNoCov">          0 :           xfree( outctrl-&gt;pub.fname );</span>
<span class="lineNum">    4587 </span><span class="lineNoCov">          0 :           outctrl-&gt;pub.fname =  outctrl-&gt;pub.newfname;</span>
<span class="lineNum">    4588 </span><span class="lineNoCov">          0 :           outctrl-&gt;pub.newfname = NULL;</span>
<span class="lineNum">    4589 </span>            : 
<span class="lineNum">    4590 </span><span class="lineNoCov">          0 :           if (is_secured_filename (outctrl-&gt;pub.fname) )</span>
<span class="lineNum">    4591 </span>            :             {
<span class="lineNum">    4592 </span><span class="lineNoCov">          0 :               outctrl-&gt;pub.stream = NULL;</span>
<span class="lineNum">    4593 </span><span class="lineNoCov">          0 :               gpg_err_set_errno (EPERM);</span>
<span class="lineNum">    4594 </span>            :             }
<span class="lineNum">    4595 </span>            :           else
<span class="lineNum">    4596 </span><span class="lineNoCov">          0 :             outctrl-&gt;pub.stream = iobuf_create (outctrl-&gt;pub.fname, 0);</span>
<span class="lineNum">    4597 </span><span class="lineNoCov">          0 :           if (!outctrl-&gt;pub.stream)</span>
<span class="lineNum">    4598 </span>            :             {
<span class="lineNum">    4599 </span><span class="lineNoCov">          0 :               log_error(_(&quot;can't create '%s': %s\n&quot;), outctrl-&gt;pub.newfname,</span>
<span class="lineNum">    4600 </span><span class="lineNoCov">          0 :                         strerror(errno) );</span>
<span class="lineNum">    4601 </span><span class="lineNoCov">          0 :               return;</span>
<span class="lineNum">    4602 </span>            :             }
<span class="lineNum">    4603 </span><span class="lineNoCov">          0 :           if (opt.armor)</span>
<span class="lineNum">    4604 </span>            :             {
<span class="lineNum">    4605 </span><span class="lineNoCov">          0 :               outctrl-&gt;pub.afx-&gt;what = 1;</span>
<span class="lineNum">    4606 </span><span class="lineNoCov">          0 :               push_armor_filter (outctrl-&gt;pub.afx, outctrl-&gt;pub.stream);</span>
<span class="lineNum">    4607 </span>            :             }
<span class="lineNum">    4608 </span>            :         }
<span class="lineNum">    4609 </span><span class="lineNoCov">          0 :       log_assert( outctrl-&gt;pub.stream );</span>
<span class="lineNum">    4610 </span><span class="lineNoCov">          0 :       if (opt.verbose)</span>
<span class="lineNum">    4611 </span><span class="lineNoCov">          0 :         log_info (_(&quot;writing public key to '%s'\n&quot;), outctrl-&gt;pub.fname );</span>
<span class="lineNum">    4612 </span>            :     }
<span class="lineNum">    4613 </span>            : 
<span class="lineNum">    4614 </span>            : 
<span class="lineNum">    4615 </span>            :   /* We create the packets as a tree of kbnodes.  Because the
<span class="lineNum">    4616 </span>            :      structure we create is known in advance we simply generate a
<span class="lineNum">    4617 </span>            :      linked list.  The first packet is a dummy packet which we flag as
<span class="lineNum">    4618 </span>            :      deleted.  The very first packet must always be a KEY packet.  */
<span class="lineNum">    4619 </span>            : 
<span class="lineNum">    4620 </span><span class="lineNoCov">          0 :   start_tree (&amp;pub_root);</span>
<span class="lineNum">    4621 </span>            : 
<span class="lineNum">    4622 </span><span class="lineNoCov">          0 :   timestamp = get_parameter_u32 (para, pKEYCREATIONDATE);</span>
<span class="lineNum">    4623 </span><span class="lineNoCov">          0 :   if (!timestamp)</span>
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :     timestamp = make_timestamp ();</span>
<span class="lineNum">    4625 </span>            : 
<span class="lineNum">    4626 </span>            :   /* Note that, depending on the backend (i.e. the used scdaemon
<span class="lineNum">    4627 </span>            :      version), the card key generation may update TIMESTAMP for each
<span class="lineNum">    4628 </span>            :      key.  Thus we need to pass TIMESTAMP to all signing function to
<span class="lineNum">    4629 </span>            :      make sure that the binding signature is done using the timestamp
<span class="lineNum">    4630 </span>            :      of the corresponding (sub)key and not that of the primary key.
<span class="lineNum">    4631 </span>            :      An alternative implementation could tell the signing function the
<span class="lineNum">    4632 </span>            :      node of the subkey but that is more work than just to pass the
<span class="lineNum">    4633 </span>            :      current timestamp.  */
<span class="lineNum">    4634 </span>            : 
<span class="lineNum">    4635 </span><span class="lineNoCov">          0 :   algo = get_parameter_algo( para, pKEYTYPE, NULL );</span>
<span class="lineNum">    4636 </span><span class="lineNoCov">          0 :   expire = get_parameter_u32( para, pKEYEXPIRE );</span>
<span class="lineNum">    4637 </span><span class="lineNoCov">          0 :   key_from_hexgrip = get_parameter_value (para, pKEYGRIP);</span>
<span class="lineNum">    4638 </span><span class="lineNoCov">          0 :   if (key_from_hexgrip)</span>
<span class="lineNum">    4639 </span><span class="lineNoCov">          0 :     err = do_create_from_keygrip (ctrl, algo, key_from_hexgrip,</span>
<span class="lineNum">    4640 </span>            :                                   pub_root, timestamp, expire, 0);
<span class="lineNum">    4641 </span><span class="lineNoCov">          0 :   else if (!card)</span>
<span class="lineNum">    4642 </span><span class="lineNoCov">          0 :     err = do_create (algo,</span>
<span class="lineNum">    4643 </span>            :                      get_parameter_uint( para, pKEYLENGTH ),
<span class="lineNum">    4644 </span>            :                      get_parameter_value (para, pKEYCURVE),
<span class="lineNum">    4645 </span>            :                      pub_root,
<span class="lineNum">    4646 </span>            :                      timestamp,
<span class="lineNum">    4647 </span>            :                      expire, 0,
<span class="lineNum">    4648 </span><span class="lineNoCov">          0 :                      outctrl-&gt;keygen_flags,</span>
<span class="lineNum">    4649 </span>            :                      get_parameter_passphrase (para),
<span class="lineNum">    4650 </span>            :                      &amp;cache_nonce, NULL);
<span class="lineNum">    4651 </span>            :   else
<span class="lineNum">    4652 </span><span class="lineNoCov">          0 :     err = gen_card_key (1, algo,</span>
<span class="lineNum">    4653 </span>            :                         1, pub_root, &amp;timestamp,
<span class="lineNum">    4654 </span>            :                         expire);
<span class="lineNum">    4655 </span>            : 
<span class="lineNum">    4656 </span>            :   /* Get the pointer to the generated public key packet.  */
<span class="lineNum">    4657 </span><span class="lineNoCov">          0 :   if (!err)</span>
<span class="lineNum">    4658 </span>            :     {
<span class="lineNum">    4659 </span><span class="lineNoCov">          0 :       pri_psk = pub_root-&gt;next-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    4660 </span><span class="lineNoCov">          0 :       log_assert (pri_psk);</span>
<span class="lineNum">    4661 </span>            : 
<span class="lineNum">    4662 </span>            :       /* Make sure a few fields are correctly set up before going
<span class="lineNum">    4663 </span>            :          further.  */
<span class="lineNum">    4664 </span><span class="lineNoCov">          0 :       pri_psk-&gt;flags.primary = 1;</span>
<span class="lineNum">    4665 </span><span class="lineNoCov">          0 :       keyid_from_pk (pri_psk, NULL);</span>
<span class="lineNum">    4666 </span>            :       /* We don't use pk_keyid to get keyid, because it also asserts
<span class="lineNum">    4667 </span>            :          that main_keyid is set!  */
<span class="lineNum">    4668 </span><span class="lineNoCov">          0 :       keyid_copy (pri_psk-&gt;main_keyid, pri_psk-&gt;keyid);</span>
<span class="lineNum">    4669 </span>            :     }
<span class="lineNum">    4670 </span>            : 
<span class="lineNum">    4671 </span><span class="lineNoCov">          0 :   if (!err &amp;&amp; (revkey = get_parameter_revkey (para, pREVOKER)))</span>
<span class="lineNum">    4672 </span><span class="lineNoCov">          0 :     err = write_direct_sig (ctrl, pub_root, pri_psk,</span>
<span class="lineNum">    4673 </span>            :                             revkey, timestamp, cache_nonce);
<span class="lineNum">    4674 </span>            : 
<span class="lineNum">    4675 </span><span class="lineNoCov">          0 :   if (!err &amp;&amp; (s = get_parameter_value (para, pUSERID)))</span>
<span class="lineNum">    4676 </span>            :     {
<span class="lineNum">    4677 </span><span class="lineNoCov">          0 :       write_uid (pub_root, s );</span>
<span class="lineNum">    4678 </span><span class="lineNoCov">          0 :       err = write_selfsigs (ctrl, pub_root, pri_psk,</span>
<span class="lineNum">    4679 </span>            :                             get_parameter_uint (para, pKEYUSAGE), timestamp,
<span class="lineNum">    4680 </span>            :                             cache_nonce);
<span class="lineNum">    4681 </span>            :     }
<span class="lineNum">    4682 </span>            : 
<span class="lineNum">    4683 </span>            :   /* Write the auth key to the card before the encryption key.  This
<span class="lineNum">    4684 </span>            :      is a partial workaround for a PGP bug (as of this writing, all
<span class="lineNum">    4685 </span>            :      versions including 8.1), that causes it to try and encrypt to
<span class="lineNum">    4686 </span>            :      the most recent subkey regardless of whether that subkey is
<span class="lineNum">    4687 </span>            :      actually an encryption type.  In this case, the auth key is an
<span class="lineNum">    4688 </span>            :      RSA key so it succeeds. */
<span class="lineNum">    4689 </span>            : 
<span class="lineNum">    4690 </span><span class="lineNoCov">          0 :   if (!err &amp;&amp; card &amp;&amp; get_parameter (para, pAUTHKEYTYPE))</span>
<span class="lineNum">    4691 </span>            :     {
<span class="lineNum">    4692 </span><span class="lineNoCov">          0 :       err = gen_card_key (3, get_parameter_algo( para, pAUTHKEYTYPE, NULL ),</span>
<span class="lineNum">    4693 </span>            :                           0, pub_root, &amp;timestamp,
<span class="lineNum">    4694 </span>            :                           get_parameter_u32 (para, pKEYEXPIRE));
<span class="lineNum">    4695 </span><span class="lineNoCov">          0 :       if (!err)</span>
<span class="lineNum">    4696 </span><span class="lineNoCov">          0 :         err = write_keybinding (ctrl, pub_root, pri_psk, NULL,</span>
<span class="lineNum">    4697 </span>            :                                 PUBKEY_USAGE_AUTH, timestamp, cache_nonce);
<span class="lineNum">    4698 </span>            :     }
<span class="lineNum">    4699 </span>            : 
<span class="lineNum">    4700 </span><span class="lineNoCov">          0 :   if (!err &amp;&amp; get_parameter (para, pSUBKEYTYPE))</span>
<span class="lineNum">    4701 </span>            :     {
<span class="lineNum">    4702 </span><span class="lineNoCov">          0 :       sub_psk = NULL;</span>
<span class="lineNum">    4703 </span><span class="lineNoCov">          0 :       s = NULL;</span>
<span class="lineNum">    4704 </span><span class="lineNoCov">          0 :       if (!card || (s = get_parameter_value (para, pCARDBACKUPKEY)))</span>
<span class="lineNum">    4705 </span>            :         {
<span class="lineNum">    4706 </span><span class="lineNoCov">          0 :           err = do_create (get_parameter_algo (para, pSUBKEYTYPE, NULL),</span>
<span class="lineNum">    4707 </span>            :                            get_parameter_uint (para, pSUBKEYLENGTH),
<span class="lineNum">    4708 </span>            :                            get_parameter_value (para, pSUBKEYCURVE),
<span class="lineNum">    4709 </span>            :                            pub_root,
<span class="lineNum">    4710 </span>            :                            timestamp,
<span class="lineNum">    4711 </span>            :                            get_parameter_u32 (para, pSUBKEYEXPIRE), 1,
<span class="lineNum">    4712 </span><span class="lineNoCov">          0 :                            s ? KEYGEN_FLAG_NO_PROTECTION : outctrl-&gt;keygen_flags,</span>
<span class="lineNum">    4713 </span>            :                            get_parameter_passphrase (para),
<span class="lineNum">    4714 </span>            :                            &amp;cache_nonce, NULL);
<span class="lineNum">    4715 </span>            :           /* Get the pointer to the generated public subkey packet.  */
<span class="lineNum">    4716 </span><span class="lineNoCov">          0 :           if (!err)</span>
<span class="lineNum">    4717 </span>            :             {
<span class="lineNum">    4718 </span>            :               kbnode_t node;
<span class="lineNum">    4719 </span>            : 
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :               for (node = pub_root; node; node = node-&gt;next)</span>
<span class="lineNum">    4721 </span><span class="lineNoCov">          0 :                 if (node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">    4722 </span><span class="lineNoCov">          0 :                   sub_psk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    4723 </span><span class="lineNoCov">          0 :               log_assert (sub_psk);</span>
<span class="lineNum">    4724 </span>            : 
<span class="lineNum">    4725 </span><span class="lineNoCov">          0 :               if (s)</span>
<span class="lineNum">    4726 </span><span class="lineNoCov">          0 :                 err = card_store_key_with_backup (ctrl,</span>
<span class="lineNum">    4727 </span>            :                                                   sub_psk, gnupg_homedir ());
<span class="lineNum">    4728 </span>            :             }
<span class="lineNum">    4729 </span>            :         }
<span class="lineNum">    4730 </span>            :       else
<span class="lineNum">    4731 </span>            :         {
<span class="lineNum">    4732 </span><span class="lineNoCov">          0 :           err = gen_card_key (2, get_parameter_algo (para, pSUBKEYTYPE, NULL),</span>
<span class="lineNum">    4733 </span>            :                               0, pub_root, &amp;timestamp,
<span class="lineNum">    4734 </span>            :                               get_parameter_u32 (para, pKEYEXPIRE));
<span class="lineNum">    4735 </span>            :         }
<span class="lineNum">    4736 </span>            : 
<span class="lineNum">    4737 </span><span class="lineNoCov">          0 :       if (!err)</span>
<span class="lineNum">    4738 </span><span class="lineNoCov">          0 :         err = write_keybinding (ctrl, pub_root, pri_psk, sub_psk,</span>
<span class="lineNum">    4739 </span>            :                                 get_parameter_uint (para, pSUBKEYUSAGE),
<span class="lineNum">    4740 </span>            :                                 timestamp, cache_nonce);
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 :       did_sub = 1;</span>
<span class="lineNum">    4742 </span>            :     }
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span><span class="lineNoCov">          0 :   if (!err &amp;&amp; outctrl-&gt;use_files)  /* Direct write to specified files.  */</span>
<span class="lineNum">    4745 </span>            :     {
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :       err = write_keyblock (outctrl-&gt;pub.stream, pub_root);</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    4748 </span><span class="lineNoCov">          0 :         log_error (&quot;can't write public key: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    4749 </span>            :     }
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :   else if (!err) /* Write to the standard keyrings.  */</span>
<span class="lineNum">    4751 </span>            :     {
<span class="lineNum">    4752 </span>            :       KEYDB_HANDLE pub_hd;
<span class="lineNum">    4753 </span>            : 
<span class="lineNum">    4754 </span><span class="lineNoCov">          0 :       pub_hd = keydb_new ();</span>
<span class="lineNum">    4755 </span><span class="lineNoCov">          0 :       if (!pub_hd)</span>
<span class="lineNum">    4756 </span><span class="lineNoCov">          0 :         err = gpg_error_from_syserror ();</span>
<span class="lineNum">    4757 </span>            :       else
<span class="lineNum">    4758 </span>            :         {
<span class="lineNum">    4759 </span><span class="lineNoCov">          0 :           err = keydb_locate_writable (pub_hd);</span>
<span class="lineNum">    4760 </span><span class="lineNoCov">          0 :           if (err)</span>
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :             log_error (_(&quot;no writable public keyring found: %s\n&quot;),</span>
<span class="lineNum">    4762 </span>            :                        gpg_strerror (err));
<span class="lineNum">    4763 </span>            :         }
<span class="lineNum">    4764 </span>            : 
<span class="lineNum">    4765 </span><span class="lineNoCov">          0 :       if (!err &amp;&amp; opt.verbose)</span>
<span class="lineNum">    4766 </span>            :         {
<span class="lineNum">    4767 </span><span class="lineNoCov">          0 :           log_info (_(&quot;writing public key to '%s'\n&quot;),</span>
<span class="lineNum">    4768 </span>            :                     keydb_get_resource_name (pub_hd));
<span class="lineNum">    4769 </span>            :         }
<span class="lineNum">    4770 </span>            : 
<span class="lineNum">    4771 </span><span class="lineNoCov">          0 :       if (!err)</span>
<span class="lineNum">    4772 </span>            :         {
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :           err = keydb_insert_keyblock (pub_hd, pub_root);</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :           if (err)</span>
<span class="lineNum">    4775 </span><span class="lineNoCov">          0 :             log_error (_(&quot;error writing public keyring '%s': %s\n&quot;),</span>
<span class="lineNum">    4776 </span>            :                        keydb_get_resource_name (pub_hd), gpg_strerror (err));
<span class="lineNum">    4777 </span>            :         }
<span class="lineNum">    4778 </span>            : 
<span class="lineNum">    4779 </span><span class="lineNoCov">          0 :       keydb_release (pub_hd);</span>
<span class="lineNum">    4780 </span>            : 
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 :       if (!err)</span>
<span class="lineNum">    4782 </span>            :         {
<span class="lineNum">    4783 </span>            :           int no_enc_rsa;
<span class="lineNum">    4784 </span>            :           PKT_public_key *pk;
<span class="lineNum">    4785 </span>            : 
<span class="lineNum">    4786 </span><span class="lineNoCov">          0 :           no_enc_rsa = ((get_parameter_algo (para, pKEYTYPE, NULL)</span>
<span class="lineNum">    4787 </span>            :                          == PUBKEY_ALGO_RSA)
<span class="lineNum">    4788 </span><span class="lineNoCov">          0 :                         &amp;&amp; get_parameter_uint (para, pKEYUSAGE)</span>
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :                         &amp;&amp; !((get_parameter_uint (para, pKEYUSAGE)</span>
<span class="lineNum">    4790 </span><span class="lineNoCov">          0 :                               &amp; PUBKEY_USAGE_ENC)) );</span>
<span class="lineNum">    4791 </span>            : 
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :           pk = find_kbnode (pub_root, PKT_PUBLIC_KEY)-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    4793 </span>            : 
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :           keyid_from_pk (pk, pk-&gt;main_keyid);</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :           register_trusted_keyid (pk-&gt;main_keyid);</span>
<span class="lineNum">    4796 </span>            : 
<span class="lineNum">    4797 </span><span class="lineNoCov">          0 :           update_ownertrust (ctrl, pk,</span>
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 :                              ((get_ownertrust (ctrl, pk) &amp; ~TRUST_MASK)</span>
<span class="lineNum">    4799 </span>            :                               | TRUST_ULTIMATE ));
<span class="lineNum">    4800 </span>            : 
<span class="lineNum">    4801 </span><span class="lineNoCov">          0 :           gen_standard_revoke (ctrl, pk, cache_nonce);</span>
<span class="lineNum">    4802 </span>            : 
<span class="lineNum">    4803 </span>            :           /* Get rid of the first empty packet.  */
<span class="lineNum">    4804 </span><span class="lineNoCov">          0 :           commit_kbnode (&amp;pub_root);</span>
<span class="lineNum">    4805 </span>            : 
<span class="lineNum">    4806 </span><span class="lineNoCov">          0 :           if (!opt.batch)</span>
<span class="lineNum">    4807 </span>            :             {
<span class="lineNum">    4808 </span><span class="lineNoCov">          0 :               tty_printf (_(&quot;public and secret key created and signed.\n&quot;) );</span>
<span class="lineNum">    4809 </span><span class="lineNoCov">          0 :               tty_printf (&quot;\n&quot;);</span>
<span class="lineNum">    4810 </span><span class="lineNoCov">          0 :               merge_keys_and_selfsig (ctrl, pub_root);</span>
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :               list_keyblock_direct (ctrl, pub_root, 0, 1, 1, 1);</span>
<span class="lineNum">    4812 </span>            :             }
<span class="lineNum">    4813 </span>            : 
<span class="lineNum">    4814 </span>            : 
<span class="lineNum">    4815 </span><span class="lineNoCov">          0 :           if (!opt.batch</span>
<span class="lineNum">    4816 </span><span class="lineNoCov">          0 :               &amp;&amp; (get_parameter_algo (para, pKEYTYPE, NULL) == PUBKEY_ALGO_DSA</span>
<span class="lineNum">    4817 </span><span class="lineNoCov">          0 :                   || no_enc_rsa )</span>
<span class="lineNum">    4818 </span><span class="lineNoCov">          0 :               &amp;&amp; !get_parameter (para, pSUBKEYTYPE) )</span>
<span class="lineNum">    4819 </span>            :             {
<span class="lineNum">    4820 </span><span class="lineNoCov">          0 :               tty_printf(_(&quot;Note that this key cannot be used for &quot;</span>
<span class="lineNum">    4821 </span>            :                            &quot;encryption.  You may want to use\n&quot;
<span class="lineNum">    4822 </span>            :                            &quot;the command \&quot;--edit-key\&quot; to generate a &quot;
<span class="lineNum">    4823 </span>            :                            &quot;subkey for this purpose.\n&quot;) );
<span class="lineNum">    4824 </span>            :             }
<span class="lineNum">    4825 </span>            :         }
<span class="lineNum">    4826 </span>            :     }
<span class="lineNum">    4827 </span>            : 
<span class="lineNum">    4828 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4829 </span>            :     {
<span class="lineNum">    4830 </span><span class="lineNoCov">          0 :       if (opt.batch)</span>
<span class="lineNum">    4831 </span><span class="lineNoCov">          0 :         log_error (&quot;key generation failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">    4832 </span>            :       else
<span class="lineNum">    4833 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err) );</span>
<span class="lineNum">    4834 </span><span class="lineNoCov">          0 :       write_status_error (card? &quot;card_key_generate&quot;:&quot;key_generate&quot;, err);</span>
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :       print_status_key_not_created ( get_parameter_value (para, pHANDLE) );</span>
<span class="lineNum">    4836 </span>            :     }
<span class="lineNum">    4837 </span>            :   else
<span class="lineNum">    4838 </span>            :     {
<span class="lineNum">    4839 </span><span class="lineNoCov">          0 :       PKT_public_key *pk = find_kbnode (pub_root,</span>
<span class="lineNum">    4840 </span><span class="lineNoCov">          0 :                                         PKT_PUBLIC_KEY)-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    4841 </span><span class="lineNoCov">          0 :       print_status_key_created (did_sub? 'B':'P', pk,</span>
<span class="lineNum">    4842 </span>            :                                 get_parameter_value (para, pHANDLE));
<span class="lineNum">    4843 </span>            :     }
<span class="lineNum">    4844 </span>            : 
<span class="lineNum">    4845 </span><span class="lineNoCov">          0 :   release_kbnode (pub_root);</span>
<span class="lineNum">    4846 </span><span class="lineNoCov">          0 :   xfree (cache_nonce);</span>
<span class="lineNum">    4847 </span>            : }
<span class="lineNum">    4848 </span>            : 
<a name="4849"><span class="lineNum">    4849 </span>            : </a>
<span class="lineNum">    4850 </span>            : static gpg_error_t
<span class="lineNum">    4851 </span><span class="lineNoCov">          0 : parse_algo_usage_expire (ctrl_t ctrl, int for_subkey,</span>
<span class="lineNum">    4852 </span>            :                          const char *algostr, const char *usagestr,
<span class="lineNum">    4853 </span>            :                          const char *expirestr,
<span class="lineNum">    4854 </span>            :                          int *r_algo, unsigned int *r_usage, u32 *r_expire,
<span class="lineNum">    4855 </span>            :                          unsigned int *r_nbits, char **r_curve)
<span class="lineNum">    4856 </span>            : {
<span class="lineNum">    4857 </span>            :   gpg_error_t err;
<span class="lineNum">    4858 </span>            :   int algo;
<span class="lineNum">    4859 </span>            :   unsigned int use, nbits;
<span class="lineNum">    4860 </span>            :   u32 expire;
<span class="lineNum">    4861 </span>            :   int wantuse;
<span class="lineNum">    4862 </span><span class="lineNoCov">          0 :   const char *curve = NULL;</span>
<span class="lineNum">    4863 </span>            : 
<span class="lineNum">    4864 </span><span class="lineNoCov">          0 :   *r_curve = NULL;</span>
<span class="lineNum">    4865 </span>            : 
<span class="lineNum">    4866 </span><span class="lineNoCov">          0 :   nbits = 0;</span>
<span class="lineNum">    4867 </span>            : 
<span class="lineNum">    4868 </span>            :   /* Parse the algo string.  */
<span class="lineNum">    4869 </span><span class="lineNoCov">          0 :   if (algostr &amp;&amp; *algostr == '&amp;' &amp;&amp; strlen (algostr) == 41)</span>
<span class="lineNum">    4870 </span>            :     {
<span class="lineNum">    4871 </span>            :       /* Take algo from existing key.  */
<span class="lineNum">    4872 </span><span class="lineNoCov">          0 :       algo = check_keygrip (ctrl, algostr+1);</span>
<span class="lineNum">    4873 </span>            :       /* FIXME: We need the curve name as well.  */
<span class="lineNum">    4874 </span><span class="lineNoCov">          0 :       return gpg_error (GPG_ERR_NOT_IMPLEMENTED);</span>
<span class="lineNum">    4875 </span>            :     }
<span class="lineNum">    4876 </span>            : 
<span class="lineNum">    4877 </span><span class="lineNoCov">          0 :   err = parse_key_parameter_string (algostr, for_subkey? 1 : 0,</span>
<span class="lineNum">    4878 </span>            :                                     &amp;algo, &amp;nbits, &amp;use, &amp;curve,
<span class="lineNum">    4879 </span>            :                                     NULL, NULL, NULL, NULL);
<span class="lineNum">    4880 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4881 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    4882 </span>            : 
<span class="lineNum">    4883 </span>            :   /* Parse the usage string.  */
<span class="lineNum">    4884 </span><span class="lineNoCov">          0 :   if (!usagestr || !*usagestr</span>
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :       || !strcmp (usagestr, &quot;default&quot;) || !strcmp (usagestr, &quot;-&quot;))</span>
<span class="lineNum">    4886 </span>            :     ; /* Keep usage from parse_key_parameter_string.  */
<span class="lineNum">    4887 </span><span class="lineNoCov">          0 :   else if ((wantuse = parse_usagestr (usagestr)) != -1)</span>
<span class="lineNum">    4888 </span><span class="lineNoCov">          0 :     use = wantuse;</span>
<span class="lineNum">    4889 </span>            :   else
<span class="lineNum">    4890 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_INV_VALUE);</span>
<span class="lineNum">    4891 </span>            : 
<span class="lineNum">    4892 </span>            :   /* Make sure a primary key has the CERT usage.  */
<span class="lineNum">    4893 </span><span class="lineNoCov">          0 :   if (!for_subkey)</span>
<span class="lineNum">    4894 </span><span class="lineNoCov">          0 :     use |= PUBKEY_USAGE_CERT;</span>
<span class="lineNum">    4895 </span>            : 
<span class="lineNum">    4896 </span>            :   /* Check that usage is possible.  NB: We have the same check in
<span class="lineNum">    4897 </span>            :    * parse_key_parameter_string but need it here again in case the
<span class="lineNum">    4898 </span>            :    * separate usage value has been given. */
<span class="lineNum">    4899 </span><span class="lineNoCov">          0 :   if (/**/((use &amp; (PUBKEY_USAGE_SIG|PUBKEY_USAGE_AUTH|PUBKEY_USAGE_CERT))</span>
<span class="lineNum">    4900 </span><span class="lineNoCov">          0 :            &amp;&amp; !pubkey_get_nsig (algo))</span>
<span class="lineNum">    4901 </span><span class="lineNoCov">          0 :        || ((use &amp; PUBKEY_USAGE_ENC)</span>
<span class="lineNum">    4902 </span><span class="lineNoCov">          0 :            &amp;&amp; !pubkey_get_nenc (algo))</span>
<span class="lineNum">    4903 </span><span class="lineNoCov">          0 :        || (for_subkey &amp;&amp; (use &amp; PUBKEY_USAGE_CERT)))</span>
<span class="lineNum">    4904 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_WRONG_KEY_USAGE);</span>
<span class="lineNum">    4905 </span>            : 
<span class="lineNum">    4906 </span>            :   /* Parse the expire string.  */
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :   expire = parse_expire_string (expirestr);</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :   if (expire == (u32)-1 )</span>
<span class="lineNum">    4909 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_INV_VALUE);</span>
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span><span class="lineNoCov">          0 :   if (curve)</span>
<span class="lineNum">    4912 </span>            :     {
<span class="lineNum">    4913 </span><span class="lineNoCov">          0 :       *r_curve = xtrystrdup (curve);</span>
<span class="lineNum">    4914 </span><span class="lineNoCov">          0 :       if (!*r_curve)</span>
<span class="lineNum">    4915 </span><span class="lineNoCov">          0 :         return gpg_error_from_syserror ();</span>
<span class="lineNum">    4916 </span>            :     }
<span class="lineNum">    4917 </span><span class="lineNoCov">          0 :   *r_algo = algo;</span>
<span class="lineNum">    4918 </span><span class="lineNoCov">          0 :   *r_usage = use;</span>
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :   *r_expire = expire;</span>
<span class="lineNum">    4920 </span><span class="lineNoCov">          0 :   *r_nbits = nbits;</span>
<span class="lineNum">    4921 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    4922 </span>            : }
<span class="lineNum">    4923 </span>            : 
<span class="lineNum">    4924 </span>            : 
<span class="lineNum">    4925 </span>            : /* Add a new subkey to an existing key.  Returns 0 if a new key has
<span class="lineNum">    4926 </span>            :    been generated and put into the keyblocks.  If any of ALGOSTR,
<a name="4927"><span class="lineNum">    4927 </span>            :    USAGESTR, or EXPIRESTR is NULL interactive mode is used. */</a>
<span class="lineNum">    4928 </span>            : gpg_error_t
<span class="lineNum">    4929 </span><span class="lineNoCov">          0 : generate_subkeypair (ctrl_t ctrl, kbnode_t keyblock, const char *algostr,</span>
<span class="lineNum">    4930 </span>            :                      const char *usagestr, const char *expirestr)
<span class="lineNum">    4931 </span>            : {
<span class="lineNum">    4932 </span><span class="lineNoCov">          0 :   gpg_error_t err = 0;</span>
<span class="lineNum">    4933 </span>            :   int interactive;
<span class="lineNum">    4934 </span>            :   kbnode_t node;
<span class="lineNum">    4935 </span><span class="lineNoCov">          0 :   PKT_public_key *pri_psk = NULL;</span>
<span class="lineNum">    4936 </span><span class="lineNoCov">          0 :   PKT_public_key *sub_psk = NULL;</span>
<span class="lineNum">    4937 </span>            :   int algo;
<span class="lineNum">    4938 </span>            :   unsigned int use;
<span class="lineNum">    4939 </span>            :   u32 expire;
<span class="lineNum">    4940 </span><span class="lineNoCov">          0 :   unsigned int nbits = 0;</span>
<span class="lineNum">    4941 </span><span class="lineNoCov">          0 :   char *curve = NULL;</span>
<span class="lineNum">    4942 </span>            :   u32 cur_time;
<span class="lineNum">    4943 </span><span class="lineNoCov">          0 :   char *key_from_hexgrip = NULL;</span>
<span class="lineNum">    4944 </span><span class="lineNoCov">          0 :   char *hexgrip = NULL;</span>
<span class="lineNum">    4945 </span><span class="lineNoCov">          0 :   char *serialno = NULL;</span>
<span class="lineNum">    4946 </span><span class="lineNoCov">          0 :   char *cache_nonce = NULL;</span>
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :   char *passwd_nonce = NULL;</span>
<span class="lineNum">    4948 </span>            : 
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :   interactive = (!algostr || !usagestr || !expirestr);</span>
<span class="lineNum">    4950 </span>            : 
<span class="lineNum">    4951 </span>            :   /* Break out the primary key.  */
<span class="lineNum">    4952 </span><span class="lineNoCov">          0 :   node = find_kbnode (keyblock, PKT_PUBLIC_KEY);</span>
<span class="lineNum">    4953 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">    4954 </span>            :     {
<span class="lineNum">    4955 </span><span class="lineNoCov">          0 :       log_error (&quot;Oops; primary key missing in keyblock!\n&quot;);</span>
<span class="lineNum">    4956 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_BUG);</span>
<span class="lineNum">    4957 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4958 </span>            :     }
<span class="lineNum">    4959 </span><span class="lineNoCov">          0 :   pri_psk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    4960 </span>            : 
<span class="lineNum">    4961 </span><span class="lineNoCov">          0 :   cur_time = make_timestamp ();</span>
<span class="lineNum">    4962 </span>            : 
<span class="lineNum">    4963 </span><span class="lineNoCov">          0 :   if (pri_psk-&gt;timestamp &gt; cur_time)</span>
<span class="lineNum">    4964 </span>            :     {
<span class="lineNum">    4965 </span><span class="lineNoCov">          0 :       ulong d = pri_psk-&gt;timestamp - cur_time;</span>
<span class="lineNum">    4966 </span><span class="lineNoCov">          0 :       log_info ( d==1 ? _(&quot;key has been created %lu second &quot;</span>
<span class="lineNum">    4967 </span>            :                           &quot;in future (time warp or clock problem)\n&quot;)
<span class="lineNum">    4968 </span>            :                  : _(&quot;key has been created %lu seconds &quot;
<span class="lineNum">    4969 </span>            :                      &quot;in future (time warp or clock problem)\n&quot;), d );
<span class="lineNum">    4970 </span><span class="lineNoCov">          0 :       if (!opt.ignore_time_conflict)</span>
<span class="lineNum">    4971 </span>            :         {
<span class="lineNum">    4972 </span><span class="lineNoCov">          0 :           err = gpg_error (GPG_ERR_TIME_CONFLICT);</span>
<span class="lineNum">    4973 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    4974 </span>            :         }
<span class="lineNum">    4975 </span>            :     }
<span class="lineNum">    4976 </span>            : 
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :   if (pri_psk-&gt;version &lt; 4)</span>
<span class="lineNum">    4978 </span>            :     {
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :       log_info (_(&quot;Note: creating subkeys for v3 keys &quot;</span>
<span class="lineNum">    4980 </span>            :                   &quot;is not OpenPGP compliant\n&quot;));
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_CONFLICT);</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4983 </span>            :     }
<span class="lineNum">    4984 </span>            : 
<span class="lineNum">    4985 </span><span class="lineNoCov">          0 :   err = hexkeygrip_from_pk (pri_psk, &amp;hexgrip);</span>
<span class="lineNum">    4986 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 :     goto leave;</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :   if (agent_get_keyinfo (NULL, hexgrip, &amp;serialno, NULL))</span>
<span class="lineNum">    4989 </span>            :     {
<span class="lineNum">    4990 </span><span class="lineNoCov">          0 :       if (interactive)</span>
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;Secret parts of primary key are not available.\n&quot;));</span>
<span class="lineNum">    4992 </span>            :       else
<span class="lineNum">    4993 </span><span class="lineNoCov">          0 :         log_info (  _(&quot;Secret parts of primary key are not available.\n&quot;));</span>
<span class="lineNum">    4994 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_NO_SECKEY);</span>
<span class="lineNum">    4995 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    4996 </span>            :     }
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :   if (serialno)</span>
<span class="lineNum">    4998 </span>            :     {
<span class="lineNum">    4999 </span><span class="lineNoCov">          0 :       if (interactive)</span>
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 :         tty_printf (_(&quot;Secret parts of primary key are stored on-card.\n&quot;));</span>
<span class="lineNum">    5001 </span>            :       else
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :         log_info (  _(&quot;Secret parts of primary key are stored on-card.\n&quot;));</span>
<span class="lineNum">    5003 </span>            :     }
<span class="lineNum">    5004 </span>            : 
<span class="lineNum">    5005 </span><span class="lineNoCov">          0 :   if (interactive)</span>
<span class="lineNum">    5006 </span>            :     {
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :       algo = ask_algo (ctrl, 1, NULL, &amp;use, &amp;key_from_hexgrip);</span>
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :       log_assert (algo);</span>
<span class="lineNum">    5009 </span>            : 
<span class="lineNum">    5010 </span><span class="lineNoCov">          0 :       if (key_from_hexgrip)</span>
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :         nbits = 0;</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :       else if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    5014 </span><span class="lineNoCov">          0 :                || algo == PUBKEY_ALGO_ECDH)</span>
<span class="lineNum">    5015 </span><span class="lineNoCov">          0 :         curve = ask_curve (&amp;algo, NULL);</span>
<span class="lineNum">    5016 </span>            :       else
<span class="lineNum">    5017 </span><span class="lineNoCov">          0 :         nbits = ask_keysize (algo, 0);</span>
<span class="lineNum">    5018 </span>            : 
<span class="lineNum">    5019 </span><span class="lineNoCov">          0 :       expire = ask_expire_interval (0, NULL);</span>
<span class="lineNum">    5020 </span><span class="lineNoCov">          0 :       if (!cpr_enabled() &amp;&amp; !cpr_get_answer_is_yes(&quot;keygen.sub.okay&quot;,</span>
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                                                    _(&quot;Really create? (y/N) &quot;)))</span>
<span class="lineNum">    5022 </span>            :         {
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :           err = gpg_error (GPG_ERR_CANCELED);</span>
<span class="lineNum">    5024 </span><span class="lineNoCov">          0 :           goto leave;</span>
<span class="lineNum">    5025 </span>            :         }
<span class="lineNum">    5026 </span>            :     }
<span class="lineNum">    5027 </span>            :   else /* Unattended mode.  */
<span class="lineNum">    5028 </span>            :     {
<span class="lineNum">    5029 </span><span class="lineNoCov">          0 :       err = parse_algo_usage_expire (ctrl, 1, algostr, usagestr, expirestr,</span>
<span class="lineNum">    5030 </span>            :                                      &amp;algo, &amp;use, &amp;expire, &amp;nbits, &amp;curve);
<span class="lineNum">    5031 </span><span class="lineNoCov">          0 :       if (err)</span>
<span class="lineNum">    5032 </span><span class="lineNoCov">          0 :         goto leave;</span>
<span class="lineNum">    5033 </span>            :     }
<span class="lineNum">    5034 </span>            : 
<span class="lineNum">    5035 </span>            :   /* Verify the passphrase now so that we get a cache item for the
<span class="lineNum">    5036 </span>            :    * primary key passphrase.  The agent also returns a passphrase
<span class="lineNum">    5037 </span>            :    * nonce, which we can use to set the passphrase for the subkey to
<span class="lineNum">    5038 </span>            :    * that of the primary key.  */
<span class="lineNum">    5039 </span>            :   {
<span class="lineNum">    5040 </span><span class="lineNoCov">          0 :     char *desc = gpg_format_keydesc (ctrl, pri_psk, FORMAT_KEYDESC_NORMAL, 1);</span>
<span class="lineNum">    5041 </span><span class="lineNoCov">          0 :     err = agent_passwd (ctrl, hexgrip, desc, 1 /*=verify*/,</span>
<span class="lineNum">    5042 </span>            :                         &amp;cache_nonce, &amp;passwd_nonce);
<span class="lineNum">    5043 </span><span class="lineNoCov">          0 :     xfree (desc);</span>
<span class="lineNum">    5044 </span>            :   }
<span class="lineNum">    5045 </span>            : 
<span class="lineNum">    5046 </span>            :   /* Start creation.  */
<span class="lineNum">    5047 </span><span class="lineNoCov">          0 :   if (key_from_hexgrip)</span>
<span class="lineNum">    5048 </span>            :     {
<span class="lineNum">    5049 </span><span class="lineNoCov">          0 :       err = do_create_from_keygrip (ctrl, algo, key_from_hexgrip,</span>
<span class="lineNum">    5050 </span>            :                                     keyblock, cur_time, expire, 1);
<span class="lineNum">    5051 </span>            :     }
<span class="lineNum">    5052 </span>            :   else
<span class="lineNum">    5053 </span>            :     {
<span class="lineNum">    5054 </span>            :       const char *passwd;
<span class="lineNum">    5055 </span>            : 
<span class="lineNum">    5056 </span>            :       /* If the pinentry loopback mode is not and we have a static
<span class="lineNum">    5057 </span>            :          passphrase (i.e. set with --passphrase{,-fd,-file} while in batch
<span class="lineNum">    5058 </span>            :          mode), we use that passphrase for the new subkey.  */
<span class="lineNum">    5059 </span><span class="lineNoCov">          0 :       if (opt.pinentry_mode != PINENTRY_MODE_LOOPBACK</span>
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :           &amp;&amp; have_static_passphrase ())</span>
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :         passwd = get_static_passphrase ();</span>
<span class="lineNum">    5062 </span>            :       else
<span class="lineNum">    5063 </span><span class="lineNoCov">          0 :         passwd = NULL;</span>
<span class="lineNum">    5064 </span>            : 
<span class="lineNum">    5065 </span><span class="lineNoCov">          0 :       err = do_create (algo, nbits, curve,</span>
<span class="lineNum">    5066 </span>            :                        keyblock, cur_time, expire, 1, 0,
<span class="lineNum">    5067 </span>            :                        passwd, &amp;cache_nonce, &amp;passwd_nonce);
<span class="lineNum">    5068 </span>            :     }
<span class="lineNum">    5069 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5070 </span><span class="lineNoCov">          0 :     goto leave;</span>
<span class="lineNum">    5071 </span>            : 
<span class="lineNum">    5072 </span>            :   /* Get the pointer to the generated public subkey packet.  */
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 :   for (node = keyblock; node; node = node-&gt;next)</span>
<span class="lineNum">    5074 </span><span class="lineNoCov">          0 :     if (node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">    5075 </span><span class="lineNoCov">          0 :       sub_psk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    5076 </span>            : 
<span class="lineNum">    5077 </span>            :   /* Write the binding signature.  */
<span class="lineNum">    5078 </span><span class="lineNoCov">          0 :   err = write_keybinding (ctrl, keyblock, pri_psk, sub_psk, use, cur_time,</span>
<span class="lineNum">    5079 </span>            :                           cache_nonce);
<span class="lineNum">    5080 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5081 </span><span class="lineNoCov">          0 :     goto leave;</span>
<span class="lineNum">    5082 </span>            : 
<span class="lineNum">    5083 </span><span class="lineNoCov">          0 :   print_status_key_created ('S', sub_psk, NULL);</span>
<span class="lineNum">    5084 </span>            : 
<span class="lineNum">    5085 </span>            : 
<span class="lineNum">    5086 </span>            :  leave:
<span class="lineNum">    5087 </span><span class="lineNoCov">          0 :   xfree (key_from_hexgrip);</span>
<span class="lineNum">    5088 </span><span class="lineNoCov">          0 :   xfree (curve);</span>
<span class="lineNum">    5089 </span><span class="lineNoCov">          0 :   xfree (hexgrip);</span>
<span class="lineNum">    5090 </span><span class="lineNoCov">          0 :   xfree (serialno);</span>
<span class="lineNum">    5091 </span><span class="lineNoCov">          0 :   xfree (cache_nonce);</span>
<span class="lineNum">    5092 </span><span class="lineNoCov">          0 :   xfree (passwd_nonce);</span>
<span class="lineNum">    5093 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5094 </span><span class="lineNoCov">          0 :     log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err) );</span>
<span class="lineNum">    5095 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    5096 </span>            : }
<span class="lineNum">    5097 </span>            : 
<span class="lineNum">    5098 </span>            : 
<span class="lineNum">    5099 </span>            : #ifdef ENABLE_CARD_SUPPORT
<a name="5100"><span class="lineNum">    5100 </span>            : /* Generate a subkey on a card. */</a>
<span class="lineNum">    5101 </span>            : gpg_error_t
<span class="lineNum">    5102 </span><span class="lineNoCov">          0 : generate_card_subkeypair (ctrl_t ctrl, kbnode_t pub_keyblock,</span>
<span class="lineNum">    5103 </span>            :                           int keyno, const char *serialno)
<span class="lineNum">    5104 </span>            : {
<span class="lineNum">    5105 </span><span class="lineNoCov">          0 :   gpg_error_t err = 0;</span>
<span class="lineNum">    5106 </span>            :   kbnode_t node;
<span class="lineNum">    5107 </span><span class="lineNoCov">          0 :   PKT_public_key *pri_pk = NULL;</span>
<span class="lineNum">    5108 </span>            :   unsigned int use;
<span class="lineNum">    5109 </span>            :   u32 expire;
<span class="lineNum">    5110 </span>            :   u32 cur_time;
<span class="lineNum">    5111 </span><span class="lineNoCov">          0 :   struct para_data_s *para = NULL;</span>
<span class="lineNum">    5112 </span><span class="lineNoCov">          0 :   PKT_public_key *sub_pk = NULL;</span>
<span class="lineNum">    5113 </span>            :   int algo;
<span class="lineNum">    5114 </span>            :   struct agent_card_info_s info;
<span class="lineNum">    5115 </span>            : 
<span class="lineNum">    5116 </span><span class="lineNoCov">          0 :   log_assert (keyno &gt;= 1 &amp;&amp; keyno &lt;= 3);</span>
<span class="lineNum">    5117 </span>            : 
<span class="lineNum">    5118 </span><span class="lineNoCov">          0 :   memset (&amp;info, 0, sizeof (info));</span>
<span class="lineNum">    5119 </span><span class="lineNoCov">          0 :   err = agent_scd_getattr (&quot;KEY-ATTR&quot;, &amp;info);</span>
<span class="lineNum">    5120 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5121 </span>            :     {
<span class="lineNum">    5122 </span><span class="lineNoCov">          0 :       log_error (_(&quot;error getting current key info: %s\n&quot;), gpg_strerror (err));</span>
<span class="lineNum">    5123 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    5124 </span>            :     }
<span class="lineNum">    5125 </span><span class="lineNoCov">          0 :   algo = info.key_attr[keyno-1].algo;</span>
<span class="lineNum">    5126 </span>            : 
<span class="lineNum">    5127 </span><span class="lineNoCov">          0 :   para = xtrycalloc (1, sizeof *para + strlen (serialno) );</span>
<span class="lineNum">    5128 </span><span class="lineNoCov">          0 :   if (!para)</span>
<span class="lineNum">    5129 </span>            :     {
<span class="lineNum">    5130 </span><span class="lineNoCov">          0 :       err = gpg_error_from_syserror ();</span>
<span class="lineNum">    5131 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    5132 </span>            :     }
<span class="lineNum">    5133 </span><span class="lineNoCov">          0 :   para-&gt;key = pSERIALNO;</span>
<span class="lineNum">    5134 </span><span class="lineNoCov">          0 :   strcpy (para-&gt;u.value, serialno);</span>
<span class="lineNum">    5135 </span>            : 
<span class="lineNum">    5136 </span>            :   /* Break out the primary secret key */
<span class="lineNum">    5137 </span><span class="lineNoCov">          0 :   node = find_kbnode (pub_keyblock, PKT_PUBLIC_KEY);</span>
<span class="lineNum">    5138 </span><span class="lineNoCov">          0 :   if (!node)</span>
<span class="lineNum">    5139 </span>            :     {
<span class="lineNum">    5140 </span><span class="lineNoCov">          0 :       log_error (&quot;Oops; public key lost!\n&quot;);</span>
<span class="lineNum">    5141 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_INTERNAL);</span>
<span class="lineNum">    5142 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    5143 </span>            :     }
<span class="lineNum">    5144 </span><span class="lineNoCov">          0 :   pri_pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    5145 </span>            : 
<span class="lineNum">    5146 </span><span class="lineNoCov">          0 :   cur_time = make_timestamp();</span>
<span class="lineNum">    5147 </span><span class="lineNoCov">          0 :   if (pri_pk-&gt;timestamp &gt; cur_time)</span>
<span class="lineNum">    5148 </span>            :     {
<span class="lineNum">    5149 </span><span class="lineNoCov">          0 :       ulong d = pri_pk-&gt;timestamp - cur_time;</span>
<span class="lineNum">    5150 </span><span class="lineNoCov">          0 :       log_info (d==1 ? _(&quot;key has been created %lu second &quot;</span>
<span class="lineNum">    5151 </span>            :                          &quot;in future (time warp or clock problem)\n&quot;)
<span class="lineNum">    5152 </span>            :                      : _(&quot;key has been created %lu seconds &quot;
<span class="lineNum">    5153 </span>            :                          &quot;in future (time warp or clock problem)\n&quot;), d );
<span class="lineNum">    5154 </span><span class="lineNoCov">          0 :         if (!opt.ignore_time_conflict)</span>
<span class="lineNum">    5155 </span>            :           {
<span class="lineNum">    5156 </span><span class="lineNoCov">          0 :             err = gpg_error (GPG_ERR_TIME_CONFLICT);</span>
<span class="lineNum">    5157 </span><span class="lineNoCov">          0 :             goto leave;</span>
<span class="lineNum">    5158 </span>            :           }
<span class="lineNum">    5159 </span>            :     }
<span class="lineNum">    5160 </span>            : 
<span class="lineNum">    5161 </span><span class="lineNoCov">          0 :   if (pri_pk-&gt;version &lt; 4)</span>
<span class="lineNum">    5162 </span>            :     {
<span class="lineNum">    5163 </span><span class="lineNoCov">          0 :       log_info (_(&quot;Note: creating subkeys for v3 keys &quot;</span>
<span class="lineNum">    5164 </span>            :                   &quot;is not OpenPGP compliant\n&quot;));
<span class="lineNum">    5165 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_NOT_SUPPORTED);</span>
<span class="lineNum">    5166 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    5167 </span>            :     }
<span class="lineNum">    5168 </span>            : 
<span class="lineNum">    5169 </span><span class="lineNoCov">          0 :   expire = ask_expire_interval (0, NULL);</span>
<span class="lineNum">    5170 </span><span class="lineNoCov">          0 :   if (keyno == 1)</span>
<span class="lineNum">    5171 </span><span class="lineNoCov">          0 :     use = PUBKEY_USAGE_SIG;</span>
<span class="lineNum">    5172 </span><span class="lineNoCov">          0 :   else if (keyno == 2)</span>
<span class="lineNum">    5173 </span><span class="lineNoCov">          0 :     use = PUBKEY_USAGE_ENC;</span>
<span class="lineNum">    5174 </span>            :   else
<span class="lineNum">    5175 </span><span class="lineNoCov">          0 :     use = PUBKEY_USAGE_AUTH;</span>
<span class="lineNum">    5176 </span><span class="lineNoCov">          0 :   if (!cpr_enabled() &amp;&amp; !cpr_get_answer_is_yes(&quot;keygen.cardsub.okay&quot;,</span>
<span class="lineNum">    5177 </span><span class="lineNoCov">          0 :                                                _(&quot;Really create? (y/N) &quot;)))</span>
<span class="lineNum">    5178 </span>            :     {
<span class="lineNum">    5179 </span><span class="lineNoCov">          0 :       err = gpg_error (GPG_ERR_CANCELED);</span>
<span class="lineNum">    5180 </span><span class="lineNoCov">          0 :       goto leave;</span>
<span class="lineNum">    5181 </span>            :     }
<span class="lineNum">    5182 </span>            : 
<span class="lineNum">    5183 </span>            :   /* Note, that depending on the backend, the card key generation may
<span class="lineNum">    5184 </span>            :      update CUR_TIME.  */
<span class="lineNum">    5185 </span><span class="lineNoCov">          0 :   err = gen_card_key (keyno, algo, 0, pub_keyblock, &amp;cur_time, expire);</span>
<span class="lineNum">    5186 </span>            :   /* Get the pointer to the generated public subkey packet.  */
<span class="lineNum">    5187 </span><span class="lineNoCov">          0 :   if (!err)</span>
<span class="lineNum">    5188 </span>            :     {
<span class="lineNum">    5189 </span><span class="lineNoCov">          0 :       for (node = pub_keyblock; node; node = node-&gt;next)</span>
<span class="lineNum">    5190 </span><span class="lineNoCov">          0 :         if (node-&gt;pkt-&gt;pkttype == PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">    5191 </span><span class="lineNoCov">          0 :           sub_pk = node-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    5192 </span><span class="lineNoCov">          0 :       log_assert (sub_pk);</span>
<span class="lineNum">    5193 </span><span class="lineNoCov">          0 :       err = write_keybinding (ctrl, pub_keyblock, pri_pk, sub_pk,</span>
<span class="lineNum">    5194 </span>            :                               use, cur_time, NULL);
<span class="lineNum">    5195 </span>            :     }
<span class="lineNum">    5196 </span>            : 
<span class="lineNum">    5197 </span>            :  leave:
<span class="lineNum">    5198 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5199 </span><span class="lineNoCov">          0 :     log_error (_(&quot;Key generation failed: %s\n&quot;), gpg_strerror (err) );</span>
<span class="lineNum">    5200 </span>            :   else
<span class="lineNum">    5201 </span><span class="lineNoCov">          0 :     print_status_key_created ('S', sub_pk, NULL);</span>
<span class="lineNum">    5202 </span><span class="lineNoCov">          0 :   release_parameter_list (para);</span>
<span class="lineNum">    5203 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    5204 </span>            : }
<span class="lineNum">    5205 </span>            : #endif /* !ENABLE_CARD_SUPPORT */
<span class="lineNum">    5206 </span>            : 
<span class="lineNum">    5207 </span>            : /*
<span class="lineNum">    5208 </span>            :  * Write a keyblock to an output stream
<a name="5209"><span class="lineNum">    5209 </span>            :  */</a>
<span class="lineNum">    5210 </span>            : static int
<span class="lineNum">    5211 </span><span class="lineNoCov">          0 : write_keyblock( IOBUF out, KBNODE node )</span>
<span class="lineNum">    5212 </span>            : {
<span class="lineNum">    5213 </span><span class="lineNoCov">          0 :   for( ; node ; node = node-&gt;next )</span>
<span class="lineNum">    5214 </span>            :     {
<span class="lineNum">    5215 </span><span class="lineNoCov">          0 :       if(!is_deleted_kbnode(node))</span>
<span class="lineNum">    5216 </span>            :         {
<span class="lineNum">    5217 </span><span class="lineNoCov">          0 :           int rc = build_packet( out, node-&gt;pkt );</span>
<span class="lineNum">    5218 </span><span class="lineNoCov">          0 :           if( rc )</span>
<span class="lineNum">    5219 </span>            :             {
<span class="lineNum">    5220 </span><span class="lineNoCov">          0 :               log_error(&quot;build_packet(%d) failed: %s\n&quot;,</span>
<span class="lineNum">    5221 </span><span class="lineNoCov">          0 :                         node-&gt;pkt-&gt;pkttype, gpg_strerror (rc) );</span>
<span class="lineNum">    5222 </span><span class="lineNoCov">          0 :               return rc;</span>
<span class="lineNum">    5223 </span>            :             }
<span class="lineNum">    5224 </span>            :         }
<span class="lineNum">    5225 </span>            :     }
<span class="lineNum">    5226 </span>            : 
<span class="lineNum">    5227 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    5228 </span>            : }
<span class="lineNum">    5229 </span>            : 
<span class="lineNum">    5230 </span>            : 
<a name="5231"><span class="lineNum">    5231 </span>            : /* Note that timestamp is an in/out arg. */</a>
<span class="lineNum">    5232 </span>            : static gpg_error_t
<span class="lineNum">    5233 </span><span class="lineNoCov">          0 : gen_card_key (int keyno, int algo, int is_primary, kbnode_t pub_root,</span>
<span class="lineNum">    5234 </span>            :               u32 *timestamp, u32 expireval)
<span class="lineNum">    5235 </span>            : {
<span class="lineNum">    5236 </span>            : #ifdef ENABLE_CARD_SUPPORT
<span class="lineNum">    5237 </span>            :   gpg_error_t err;
<span class="lineNum">    5238 </span>            :   PACKET *pkt;
<span class="lineNum">    5239 </span>            :   PKT_public_key *pk;
<span class="lineNum">    5240 </span>            :   char keyid[10];
<span class="lineNum">    5241 </span>            :   unsigned char *public;
<span class="lineNum">    5242 </span>            :   gcry_sexp_t s_key;
<span class="lineNum">    5243 </span>            : 
<span class="lineNum">    5244 </span><span class="lineNoCov">          0 :   snprintf (keyid, DIM(keyid), &quot;OPENPGP.%d&quot;, keyno);</span>
<span class="lineNum">    5245 </span>            : 
<span class="lineNum">    5246 </span><span class="lineNoCov">          0 :   pk = xtrycalloc (1, sizeof *pk );</span>
<span class="lineNum">    5247 </span><span class="lineNoCov">          0 :   if (!pk)</span>
<span class="lineNum">    5248 </span><span class="lineNoCov">          0 :     return gpg_error_from_syserror ();</span>
<span class="lineNum">    5249 </span><span class="lineNoCov">          0 :   pkt = xtrycalloc (1, sizeof *pkt);</span>
<span class="lineNum">    5250 </span><span class="lineNoCov">          0 :   if (!pkt)</span>
<span class="lineNum">    5251 </span>            :     {
<span class="lineNum">    5252 </span><span class="lineNoCov">          0 :       xfree (pk);</span>
<span class="lineNum">    5253 </span><span class="lineNoCov">          0 :       return gpg_error_from_syserror ();</span>
<span class="lineNum">    5254 </span>            :     }
<span class="lineNum">    5255 </span>            : 
<span class="lineNum">    5256 </span>            :   /* Note: SCD knows the serialnumber, thus there is no point in passing it.  */
<span class="lineNum">    5257 </span><span class="lineNoCov">          0 :   err = agent_scd_genkey (keyno, 1, timestamp);</span>
<span class="lineNum">    5258 </span>            :   /*  The code below is not used because we force creation of
<span class="lineNum">    5259 </span>            :    *  the a card key (3rd arg).
<span class="lineNum">    5260 </span>            :    * if (gpg_err_code (rc) == GPG_ERR_EEXIST)
<span class="lineNum">    5261 </span>            :    *   {
<span class="lineNum">    5262 </span>            :    *     tty_printf (&quot;\n&quot;);
<span class="lineNum">    5263 </span>            :    *     log_error (&quot;WARNING: key does already exists!\n&quot;);
<span class="lineNum">    5264 </span>            :    *     tty_printf (&quot;\n&quot;);
<span class="lineNum">    5265 </span>            :    *     if ( cpr_get_answer_is_yes( &quot;keygen.card.replace_key&quot;,
<span class="lineNum">    5266 </span>            :    *                                 _(&quot;Replace existing key? &quot;)))
<span class="lineNum">    5267 </span>            :    *       rc = agent_scd_genkey (keyno, 1, timestamp);
<span class="lineNum">    5268 </span>            :    *   }
<span class="lineNum">    5269 </span>            :   */
<span class="lineNum">    5270 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5271 </span>            :     {
<span class="lineNum">    5272 </span><span class="lineNoCov">          0 :       log_error (&quot;key generation failed: %s\n&quot;, gpg_strerror (err));</span>
<span class="lineNum">    5273 </span><span class="lineNoCov">          0 :       xfree (pkt);</span>
<span class="lineNum">    5274 </span><span class="lineNoCov">          0 :       xfree (pk);</span>
<span class="lineNum">    5275 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    5276 </span>            :     }
<span class="lineNum">    5277 </span>            : 
<span class="lineNum">    5278 </span>            :   /* Send the READKEY command so that the agent creates a shadow key for
<span class="lineNum">    5279 </span>            :      card key.  We need to do that now so that we are able to create
<span class="lineNum">    5280 </span>            :      the self-signatures. */
<span class="lineNum">    5281 </span><span class="lineNoCov">          0 :   err = agent_readkey (NULL, 1, keyid, &amp;public);</span>
<span class="lineNum">    5282 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5283 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    5284 </span><span class="lineNoCov">          0 :   err = gcry_sexp_sscan (&amp;s_key, NULL, public,</span>
<span class="lineNum">    5285 </span>            :                          gcry_sexp_canon_len (public, 0, NULL, NULL));
<span class="lineNum">    5286 </span><span class="lineNoCov">          0 :   xfree (public);</span>
<span class="lineNum">    5287 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5288 </span><span class="lineNoCov">          0 :     return err;</span>
<span class="lineNum">    5289 </span>            : 
<span class="lineNum">    5290 </span><span class="lineNoCov">          0 :   if (algo == PUBKEY_ALGO_RSA)</span>
<span class="lineNum">    5291 </span><span class="lineNoCov">          0 :     err = key_from_sexp (pk-&gt;pkey, s_key, &quot;public-key&quot;, &quot;ne&quot;);</span>
<span class="lineNum">    5292 </span><span class="lineNoCov">          0 :   else if (algo == PUBKEY_ALGO_ECDSA</span>
<span class="lineNum">    5293 </span><span class="lineNoCov">          0 :            || algo == PUBKEY_ALGO_EDDSA</span>
<span class="lineNum">    5294 </span><span class="lineNoCov">          0 :            || algo == PUBKEY_ALGO_ECDH )</span>
<span class="lineNum">    5295 </span><span class="lineNoCov">          0 :     err = ecckey_from_sexp (pk-&gt;pkey, s_key, algo);</span>
<span class="lineNum">    5296 </span>            :   else
<span class="lineNum">    5297 </span><span class="lineNoCov">          0 :     err = gpg_error (GPG_ERR_PUBKEY_ALGO);</span>
<span class="lineNum">    5298 </span><span class="lineNoCov">          0 :   gcry_sexp_release (s_key);</span>
<span class="lineNum">    5299 </span>            : 
<span class="lineNum">    5300 </span><span class="lineNoCov">          0 :   if (err)</span>
<span class="lineNum">    5301 </span>            :     {
<span class="lineNum">    5302 </span><span class="lineNoCov">          0 :       log_error (&quot;key_from_sexp failed: %s\n&quot;, gpg_strerror (err) );</span>
<span class="lineNum">    5303 </span><span class="lineNoCov">          0 :       free_public_key (pk);</span>
<span class="lineNum">    5304 </span><span class="lineNoCov">          0 :       return err;</span>
<span class="lineNum">    5305 </span>            :     }
<span class="lineNum">    5306 </span>            : 
<span class="lineNum">    5307 </span><span class="lineNoCov">          0 :   pk-&gt;timestamp = *timestamp;</span>
<span class="lineNum">    5308 </span><span class="lineNoCov">          0 :   pk-&gt;version = 4;</span>
<span class="lineNum">    5309 </span><span class="lineNoCov">          0 :   if (expireval)</span>
<span class="lineNum">    5310 </span><span class="lineNoCov">          0 :     pk-&gt;expiredate = pk-&gt;timestamp + expireval;</span>
<span class="lineNum">    5311 </span><span class="lineNoCov">          0 :   pk-&gt;pubkey_algo = algo;</span>
<span class="lineNum">    5312 </span>            : 
<span class="lineNum">    5313 </span><span class="lineNoCov">          0 :   pkt-&gt;pkttype = is_primary ? PKT_PUBLIC_KEY : PKT_PUBLIC_SUBKEY;</span>
<span class="lineNum">    5314 </span><span class="lineNoCov">          0 :   pkt-&gt;pkt.public_key = pk;</span>
<span class="lineNum">    5315 </span><span class="lineNoCov">          0 :   add_kbnode (pub_root, new_kbnode (pkt));</span>
<span class="lineNum">    5316 </span>            : 
<span class="lineNum">    5317 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    5318 </span>            : #else
<span class="lineNum">    5319 </span>            :   (void)keyno;
<span class="lineNum">    5320 </span>            :   (void)is_primary;
<span class="lineNum">    5321 </span>            :   (void)pub_root;
<span class="lineNum">    5322 </span>            :   (void)timestamp;
<span class="lineNum">    5323 </span>            :   (void)expireval;
<span class="lineNum">    5324 </span>            :   return gpg_error (GPG_ERR_NOT_SUPPORTED);
<span class="lineNum">    5325 </span>            : #endif /*!ENABLE_CARD_SUPPORT*/
<span class="lineNum">    5326 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
