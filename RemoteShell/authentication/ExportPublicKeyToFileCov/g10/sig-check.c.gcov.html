<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - g10/sig-check.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">g10</a> - sig-check.c<span style="font-size: 80%;"> (source / <a href="sig-check.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">420</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-07-14 14:32:15</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* sig-check.c -  Check a signature</a>
<span class="lineNum">       2 </span>            :  * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003,
<span class="lineNum">       3 </span>            :  *               2004, 2006 Free Software Foundation, Inc.
<span class="lineNum">       4 </span>            :  * Copyright (C) 2015, 2016 g10 Code GmbH
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * This file is part of GnuPG.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * GnuPG is free software; you can redistribute it and/or modify
<span class="lineNum">       9 </span>            :  * it under the terms of the GNU General Public License as published by
<span class="lineNum">      10 </span>            :  * the Free Software Foundation; either version 3 of the License, or
<span class="lineNum">      11 </span>            :  * (at your option) any later version.
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  * GnuPG is distributed in the hope that it will be useful,
<span class="lineNum">      14 </span>            :  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      15 </span>            :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      16 </span>            :  * GNU General Public License for more details.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            :  * along with this program; if not, see &lt;https://www.gnu.org/licenses/&gt;.
<span class="lineNum">      20 </span>            :  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;gpg.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;../common/util.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;packet.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;keydb.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;main.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;../common/status.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;../common/i18n.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;options.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;pkglue.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : static int check_signature_end (PKT_public_key *pk, PKT_signature *sig,
<span class="lineNum">      38 </span>            :                                 gcry_md_hd_t digest,
<span class="lineNum">      39 </span>            :                                 int *r_expired, int *r_revoked,
<span class="lineNum">      40 </span>            :                                 PKT_public_key *ret_pk);
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : static int check_signature_end_simple (PKT_public_key *pk, PKT_signature *sig,
<span class="lineNum">      43 </span>            :                                        gcry_md_hd_t digest);
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : /* Statistics for signature verification.  */
<span class="lineNum">      47 </span>            : struct
<span class="lineNum">      48 </span>            : {
<span class="lineNum">      49 </span>            :   unsigned int total;  /* Total number of verifications.  */
<span class="lineNum">      50 </span>            :   unsigned int cached; /* Number of seen cache entries.  */
<span class="lineNum">      51 </span>            :   unsigned int goodsig;/* Number of good verifications from the cache.  */
<span class="lineNum">      52 </span>            :   unsigned int badsig; /* Number of bad verifications from the cache.  */
<span class="lineNum">      53 </span>            : } cache_stats;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : 
<a name="56"><span class="lineNum">      56 </span>            : /* Dump verification stats.  */</a>
<span class="lineNum">      57 </span>            : void
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : sig_check_dump_stats (void)</span>
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   log_info (&quot;sig_cache: total=%u cached=%u good=%u bad=%u\n&quot;,</span>
<span class="lineNum">      61 </span>            :             cache_stats.total, cache_stats.cached,
<span class="lineNum">      62 </span>            :             cache_stats.goodsig, cache_stats.badsig);
<span class="lineNum">      63 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : /* Check a signature.  This is shorthand for check_signature2 with
<a name="67"><span class="lineNum">      67 </span>            :    the unnamed arguments passed as NULL.  */</a>
<span class="lineNum">      68 </span>            : int
<span class="lineNum">      69 </span><span class="lineNoCov">          0 : check_signature (ctrl_t ctrl, PKT_signature *sig, gcry_md_hd_t digest)</span>
<span class="lineNum">      70 </span>            : {
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :   return check_signature2 (ctrl, sig, digest, NULL, NULL, NULL, NULL);</span>
<span class="lineNum">      72 </span>            : }
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /* Check a signature.
<span class="lineNum">      76 </span>            :  *
<span class="lineNum">      77 </span>            :  * Looks up the public key that created the signature (SIG-&gt;KEYID)
<span class="lineNum">      78 </span>            :  * from the key db.  Makes sure that the signature is valid (it was
<span class="lineNum">      79 </span>            :  * not created prior to the key, the public key was created in the
<span class="lineNum">      80 </span>            :  * past, and the signature does not include any unsupported critical
<span class="lineNum">      81 </span>            :  * features), finishes computing the hash of the signature data, and
<span class="lineNum">      82 </span>            :  * checks that the signature verifies the digest.  If the key that
<span class="lineNum">      83 </span>            :  * generated the signature is a subkey, this function also verifies
<span class="lineNum">      84 </span>            :  * that there is a valid backsig from the subkey to the primary key.
<span class="lineNum">      85 </span>            :  * Finally, if status fd is enabled and the signature class is 0x00 or
<span class="lineNum">      86 </span>            :  * 0x01, then a STATUS_SIG_ID is emitted on the status fd.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * SIG is the signature to check.
<span class="lineNum">      89 </span>            :  *
<span class="lineNum">      90 </span>            :  * DIGEST contains a valid hash context that already includes the
<span class="lineNum">      91 </span>            :  * signed data.  This function adds the relevant meta-data from the
<span class="lineNum">      92 </span>            :  * signature packet to compute the final hash.  (See Section 5.2 of
<span class="lineNum">      93 </span>            :  * RFC 4880: &quot;The concatenation of the data being signed and the
<span class="lineNum">      94 </span>            :  * signature data from the version number through the hashed subpacket
<span class="lineNum">      95 </span>            :  * data (inclusive) is hashed.&quot;)
<span class="lineNum">      96 </span>            :  *
<span class="lineNum">      97 </span>            :  * If R_EXPIREDATE is not NULL, R_EXPIREDATE is set to the key's
<span class="lineNum">      98 </span>            :  * expiry.
<span class="lineNum">      99 </span>            :  *
<span class="lineNum">     100 </span>            :  * If R_EXPIRED is not NULL, *R_EXPIRED is set to 1 if PK has expired
<span class="lineNum">     101 </span>            :  * (0 otherwise).  Note: PK being expired does not cause this function
<span class="lineNum">     102 </span>            :  * to fail.
<span class="lineNum">     103 </span>            :  *
<span class="lineNum">     104 </span>            :  * If R_REVOKED is not NULL, *R_REVOKED is set to 1 if PK has been
<span class="lineNum">     105 </span>            :  * revoked (0 otherwise).  Note: PK being revoked does not cause this
<span class="lineNum">     106 </span>            :  * function to fail.
<span class="lineNum">     107 </span>            :  *
<span class="lineNum">     108 </span>            :  * If R_PK is not NULL, the public key is stored at that address if it
<span class="lineNum">     109 </span>            :  * was found; other wise NULL is stored.
<span class="lineNum">     110 </span>            :  *
<a name="111"><span class="lineNum">     111 </span>            :  * Returns 0 on success.  An error code otherwise.  */</a>
<span class="lineNum">     112 </span>            : gpg_error_t
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : check_signature2 (ctrl_t ctrl,</span>
<span class="lineNum">     114 </span>            :                   PKT_signature *sig, gcry_md_hd_t digest, u32 *r_expiredate,
<span class="lineNum">     115 </span>            :                   int *r_expired, int *r_revoked, PKT_public_key **r_pk)
<span class="lineNum">     116 </span>            : {
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     int rc=0;</span>
<span class="lineNum">     118 </span>            :     PKT_public_key *pk;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :     if (r_expiredate)</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :       *r_expiredate = 0;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :     if (r_expired)</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :       *r_expired = 0;</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :     if (r_revoked)</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :       *r_revoked = 0;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     if (r_pk)</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :       *r_pk = NULL;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     pk = xtrycalloc (1, sizeof *pk);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     if (!pk)</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :       return gpg_error_from_syserror ();</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     if ( (rc=openpgp_md_test_algo(sig-&gt;digest_algo)) )</span>
<span class="lineNum">     134 </span>            :       ; /* We don't have this digest. */
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :     else if ((rc=openpgp_pk_test_algo(sig-&gt;pubkey_algo)))</span>
<span class="lineNum">     136 </span>            :       ; /* We don't have this pubkey algo. */
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :     else if (!gcry_md_is_enabled (digest,sig-&gt;digest_algo))</span>
<span class="lineNum">     138 </span>            :       {
<span class="lineNum">     139 </span>            :         /* Sanity check that the md has a context for the hash that the
<span class="lineNum">     140 </span>            :            sig is expecting.  This can happen if a onepass sig header does
<span class="lineNum">     141 </span>            :            not match the actual sig, and also if the clearsign &quot;Hash:&quot;
<span class="lineNum">     142 </span>            :            header is missing or does not match the actual sig. */
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :         log_info(_(&quot;WARNING: signature digest conflict in message\n&quot;));</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :         rc = gpg_error (GPG_ERR_GENERAL);</span>
<span class="lineNum">     146 </span>            :       }
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :     else if( get_pubkey (ctrl, pk, sig-&gt;keyid ) )</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       rc = gpg_error (GPG_ERR_NO_PUBKEY);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     else if(!pk-&gt;flags.valid)</span>
<span class="lineNum">     150 </span>            :       {
<span class="lineNum">     151 </span>            :         /* You cannot have a good sig from an invalid key.  */
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :         rc = gpg_error (GPG_ERR_BAD_PUBKEY);</span>
<span class="lineNum">     153 </span>            :       }
<span class="lineNum">     154 </span>            :     else
<span class="lineNum">     155 </span>            :       {
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :         if(r_expiredate)</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :           *r_expiredate = pk-&gt;expiredate;</span>
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :         rc = check_signature_end (pk, sig, digest, r_expired, r_revoked, NULL);</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         /* Check the backsig.  This is a 0x19 signature from the
<span class="lineNum">     162 </span>            :            subkey on the primary key.  The idea here is that it should
<span class="lineNum">     163 </span>            :            not be possible for someone to &quot;steal&quot; subkeys and claim
<span class="lineNum">     164 </span>            :            them as their own.  The attacker couldn't actually use the
<span class="lineNum">     165 </span>            :            subkey, but they could try and claim ownership of any
<span class="lineNum">     166 </span>            :            signatures issued by it. */
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :         if (!rc &amp;&amp; !pk-&gt;flags.primary &amp;&amp; pk-&gt;flags.backsig &lt; 2)</span>
<span class="lineNum">     168 </span>            :           {
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :             if (!pk-&gt;flags.backsig)</span>
<span class="lineNum">     170 </span>            :               {
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :                 log_info(_(&quot;WARNING: signing subkey %s is not&quot;</span>
<span class="lineNum">     172 </span>            :                            &quot; cross-certified\n&quot;),keystr_from_pk(pk));
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :                 log_info(_(&quot;please see %s for more information\n&quot;),</span>
<span class="lineNum">     174 </span>            :                          &quot;https://gnupg.org/faq/subkey-cross-certify.html&quot;);
<span class="lineNum">     175 </span>            :                 /* --require-cross-certification makes this warning an
<span class="lineNum">     176 </span>            :                      error.  TODO: change the default to require this
<span class="lineNum">     177 </span>            :                      after more keys have backsigs. */
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :                 if(opt.flags.require_cross_cert)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :                   rc = gpg_error (GPG_ERR_GENERAL);</span>
<span class="lineNum">     180 </span>            :               }
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :             else if(pk-&gt;flags.backsig == 1)</span>
<span class="lineNum">     182 </span>            :               {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :                 log_info(_(&quot;WARNING: signing subkey %s has an invalid&quot;</span>
<span class="lineNum">     184 </span>            :                            &quot; cross-certification\n&quot;),keystr_from_pk(pk));
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :                 rc = gpg_error (GPG_ERR_GENERAL);</span>
<span class="lineNum">     186 </span>            :               }
<span class="lineNum">     187 </span>            :           }
<span class="lineNum">     188 </span>            :       }
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     if( !rc &amp;&amp; sig-&gt;sig_class &lt; 2 &amp;&amp; is_status_enabled() ) {</span>
<span class="lineNum">     191 </span>            :         /* This signature id works best with DLP algorithms because
<span class="lineNum">     192 </span>            :          * they use a random parameter for every signature.  Instead of
<span class="lineNum">     193 </span>            :          * this sig-id we could have also used the hash of the document
<span class="lineNum">     194 </span>            :          * and the timestamp, but the drawback of this is, that it is
<span class="lineNum">     195 </span>            :          * not possible to sign more than one identical document within
<span class="lineNum">     196 </span>            :          * one second.  Some remote batch processing applications might
<span class="lineNum">     197 </span>            :          * like this feature here.
<span class="lineNum">     198 </span>            :          *
<span class="lineNum">     199 </span>            :          * Note that before 2.0.10, we used RIPE-MD160 for the hash
<span class="lineNum">     200 </span>            :          * and accidentally didn't include the timestamp and algorithm
<span class="lineNum">     201 </span>            :          * information in the hash.  Given that this feature is not
<span class="lineNum">     202 </span>            :          * commonly used and that a replay attacks detection should
<span class="lineNum">     203 </span>            :          * not solely be based on this feature (because it does not
<span class="lineNum">     204 </span>            :          * work with RSA), we take the freedom and switch to SHA-1
<span class="lineNum">     205 </span>            :          * with 2.0.10 to take advantage of hardware supported SHA-1
<span class="lineNum">     206 </span>            :          * implementations.  We also include the missing information
<span class="lineNum">     207 </span>            :          * in the hash.  Note also the SIG_ID as computed by gpg 1.x
<span class="lineNum">     208 </span>            :          * and gpg 2.x didn't matched either because 2.x used to print
<span class="lineNum">     209 </span>            :          * MPIs not in PGP format.  */
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         u32 a = sig-&gt;timestamp;</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         int nsig = pubkey_get_nsig( sig-&gt;pubkey_algo );</span>
<span class="lineNum">     212 </span>            :         unsigned char *p, *buffer;
<span class="lineNum">     213 </span>            :         size_t n, nbytes;
<span class="lineNum">     214 </span>            :         int i;
<span class="lineNum">     215 </span>            :         char hashbuf[20];
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :         nbytes = 6;</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :         for (i=0; i &lt; nsig; i++ )</span>
<span class="lineNum">     219 </span>            :           {
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :             if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &amp;n, sig-&gt;data[i]))</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :               BUG();</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :             nbytes += n;</span>
<span class="lineNum">     223 </span>            :           }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :         /* Make buffer large enough to be later used as output buffer.  */
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :         if (nbytes &lt; 100)</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :           nbytes = 100;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :         nbytes += 10;  /* Safety margin.  */</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :         /* Fill and hash buffer.  */
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         buffer = p = xmalloc (nbytes);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         *p++ = sig-&gt;pubkey_algo;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         *p++ = sig-&gt;digest_algo;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         *p++ = (a &gt;&gt; 24) &amp; 0xff;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         *p++ = (a &gt;&gt; 16) &amp; 0xff;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         *p++ = (a &gt;&gt;  8) &amp; 0xff;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         *p++ =  a &amp; 0xff;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         nbytes -= 6;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         for (i=0; i &lt; nsig; i++ )</span>
<span class="lineNum">     240 </span>            :           {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :             if (gcry_mpi_print (GCRYMPI_FMT_PGP, p, nbytes, &amp;n, sig-&gt;data[i]))</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :               BUG();</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             p += n;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             nbytes -= n;</span>
<span class="lineNum">     245 </span>            :           }
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :         gcry_md_hash_buffer (GCRY_MD_SHA1, hashbuf, buffer, p-buffer);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         p = make_radix64_string (hashbuf, 20);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         sprintf (buffer, &quot;%s %s %lu&quot;,</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                  p, strtimestamp (sig-&gt;timestamp), (ulong)sig-&gt;timestamp);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :         xfree (p);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         write_status_text (STATUS_SIG_ID, buffer);</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :         xfree (buffer);</span>
<span class="lineNum">     254 </span>            :     }
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     if (r_pk)</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       *r_pk = pk;</span>
<span class="lineNum">     258 </span>            :     else
<span class="lineNum">     259 </span>            :       {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         release_public_key_parts (pk);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         xfree (pk);</span>
<span class="lineNum">     262 </span>            :       }
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     265 </span>            : }
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : /* The signature SIG was generated with the public key PK.  Check
<span class="lineNum">     269 </span>            :  * whether the signature is valid in the following sense:
<span class="lineNum">     270 </span>            :  *
<span class="lineNum">     271 </span>            :  *   - Make sure the public key was created before the signature was
<span class="lineNum">     272 </span>            :  *     generated.
<span class="lineNum">     273 </span>            :  *
<span class="lineNum">     274 </span>            :  *   - Make sure the public key was created in the past
<span class="lineNum">     275 </span>            :  *
<span class="lineNum">     276 </span>            :  *   - Check whether PK has expired (set *R_EXPIRED to 1 if so and 0
<span class="lineNum">     277 </span>            :  *     otherwise)
<span class="lineNum">     278 </span>            :  *
<span class="lineNum">     279 </span>            :  *   - Check whether PK has been revoked (set *R_REVOKED to 1 if so
<span class="lineNum">     280 </span>            :  *     and 0 otherwise).
<span class="lineNum">     281 </span>            :  *
<span class="lineNum">     282 </span>            :  * If either of the first two tests fail, returns an error code.
<span class="lineNum">     283 </span>            :  * Otherwise returns 0.  (Thus, this function doesn't fail if the
<a name="284"><span class="lineNum">     284 </span>            :  * public key is expired or revoked.)  */</a>
<span class="lineNum">     285 </span>            : static int
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : check_signature_metadata_validity (PKT_public_key *pk, PKT_signature *sig,</span>
<span class="lineNum">     287 </span>            :                                    int *r_expired, int *r_revoked)
<span class="lineNum">     288 </span>            : {
<span class="lineNum">     289 </span>            :     u32 cur_time;
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     if(r_expired)</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       *r_expired = 0;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     if(r_revoked)</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       *r_revoked = 0;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     if( pk-&gt;timestamp &gt; sig-&gt;timestamp )</span>
<span class="lineNum">     297 </span>            :       {
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :         ulong d = pk-&gt;timestamp - sig-&gt;timestamp;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :         if ( d &lt; 86400 )</span>
<span class="lineNum">     300 </span>            :           {
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :             log_info</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :               (ngettext</span>
<span class="lineNum">     303 </span>            :                (&quot;public key %s is %lu second newer than the signature\n&quot;,
<span class="lineNum">     304 </span>            :                 &quot;public key %s is %lu seconds newer than the signature\n&quot;,
<span class="lineNum">     305 </span>            :                 d), keystr_from_pk (pk), d);
<span class="lineNum">     306 </span>            :           }
<span class="lineNum">     307 </span>            :         else
<span class="lineNum">     308 </span>            :           {
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :             d /= 86400;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             log_info</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :               (ngettext</span>
<span class="lineNum">     312 </span>            :                (&quot;public key %s is %lu day newer than the signature\n&quot;,
<span class="lineNum">     313 </span>            :                 &quot;public key %s is %lu days newer than the signature\n&quot;,
<span class="lineNum">     314 </span>            :                 d), keystr_from_pk (pk), d);
<span class="lineNum">     315 </span>            :           }
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         if (!opt.ignore_time_conflict)</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :           return GPG_ERR_TIME_CONFLICT; /* pubkey newer than signature.  */</span>
<span class="lineNum">     318 </span>            :       }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     cur_time = make_timestamp();</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :     if( pk-&gt;timestamp &gt; cur_time )</span>
<span class="lineNum">     322 </span>            :       {
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         ulong d = pk-&gt;timestamp - cur_time;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         if (d &lt; 86400)</span>
<span class="lineNum">     325 </span>            :           {
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :             log_info (ngettext(&quot;key %s was created %lu second&quot;</span>
<span class="lineNum">     327 </span>            :                                &quot; in the future (time warp or clock problem)\n&quot;,
<span class="lineNum">     328 </span>            :                                &quot;key %s was created %lu seconds&quot;
<span class="lineNum">     329 </span>            :                                &quot; in the future (time warp or clock problem)\n&quot;,
<span class="lineNum">     330 </span>            :                                d), keystr_from_pk (pk), d);
<span class="lineNum">     331 </span>            :           }
<span class="lineNum">     332 </span>            :         else
<span class="lineNum">     333 </span>            :           {
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :             d /= 86400;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :             log_info (ngettext(&quot;key %s was created %lu day&quot;</span>
<span class="lineNum">     336 </span>            :                                &quot; in the future (time warp or clock problem)\n&quot;,
<span class="lineNum">     337 </span>            :                                &quot;key %s was created %lu days&quot;
<span class="lineNum">     338 </span>            :                                &quot; in the future (time warp or clock problem)\n&quot;,
<span class="lineNum">     339 </span>            :                                d), keystr_from_pk (pk), d);
<span class="lineNum">     340 </span>            :           }
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :         if (!opt.ignore_time_conflict)</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :           return GPG_ERR_TIME_CONFLICT;</span>
<span class="lineNum">     343 </span>            :       }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :     /* Check whether the key has expired.  We check the has_expired
<span class="lineNum">     346 </span>            :        flag which is set after a full evaluation of the key (getkey.c)
<span class="lineNum">     347 </span>            :        as well as a simple compare to the current time in case the
<span class="lineNum">     348 </span>            :        merge has for whatever reasons not been done.  */
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     if( pk-&gt;has_expired || (pk-&gt;expiredate &amp;&amp; pk-&gt;expiredate &lt; cur_time)) {</span>
<span class="lineNum">     350 </span>            :         char buf[11];
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         if (opt.verbose)</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :           log_info(_(&quot;Note: signature key %s expired %s\n&quot;),</span>
<span class="lineNum">     353 </span>            :                    keystr_from_pk(pk), asctimestamp( pk-&gt;expiredate ) );
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         sprintf(buf,&quot;%lu&quot;,(ulong)pk-&gt;expiredate);</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         write_status_text(STATUS_KEYEXPIRED,buf);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         if(r_expired)</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :           *r_expired = 1;</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :     if (pk-&gt;flags.revoked)</span>
<span class="lineNum">     361 </span>            :       {
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         if (opt.verbose)</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :           log_info (_(&quot;Note: signature key %s has been revoked\n&quot;),</span>
<span class="lineNum">     364 </span>            :                     keystr_from_pk(pk));
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         if (r_revoked)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :           *r_revoked=1;</span>
<span class="lineNum">     367 </span>            :       }
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     370 </span>            : }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* Finish generating a signature and check it.  Concretely: make sure
<span class="lineNum">     374 </span>            :  * that the signature is valid (it was not created prior to the key,
<span class="lineNum">     375 </span>            :  * the public key was created in the past, and the signature does not
<span class="lineNum">     376 </span>            :  * include any unsupported critical features), finish computing the
<span class="lineNum">     377 </span>            :  * digest by adding the relevant data from the signature packet, and
<span class="lineNum">     378 </span>            :  * check that the signature verifies the digest.
<span class="lineNum">     379 </span>            :  *
<span class="lineNum">     380 </span>            :  * DIGEST contains a hash context, which has already hashed the signed
<span class="lineNum">     381 </span>            :  * data.  This function adds the relevant meta-data from the signature
<span class="lineNum">     382 </span>            :  * packet to compute the final hash.  (See Section 5.2 of RFC 4880:
<span class="lineNum">     383 </span>            :  * &quot;The concatenation of the data being signed and the signature data
<span class="lineNum">     384 </span>            :  * from the version number through the hashed subpacket data
<span class="lineNum">     385 </span>            :  * (inclusive) is hashed.&quot;)
<span class="lineNum">     386 </span>            :  *
<span class="lineNum">     387 </span>            :  * SIG is the signature to check.
<span class="lineNum">     388 </span>            :  *
<span class="lineNum">     389 </span>            :  * PK is the public key used to generate the signature.
<span class="lineNum">     390 </span>            :  *
<span class="lineNum">     391 </span>            :  * If R_EXPIRED is not NULL, *R_EXPIRED is set to 1 if PK has expired
<span class="lineNum">     392 </span>            :  * (0 otherwise).  Note: PK being expired does not cause this function
<span class="lineNum">     393 </span>            :  * to fail.
<span class="lineNum">     394 </span>            :  *
<span class="lineNum">     395 </span>            :  * If R_REVOKED is not NULL, *R_REVOKED is set to 1 if PK has been
<span class="lineNum">     396 </span>            :  * revoked (0 otherwise).  Note: PK being revoked does not cause this
<span class="lineNum">     397 </span>            :  * function to fail.
<span class="lineNum">     398 </span>            :  *
<span class="lineNum">     399 </span>            :  * If RET_PK is not NULL, PK is copied into RET_PK on success.
<span class="lineNum">     400 </span>            :  *
<a name="401"><span class="lineNum">     401 </span>            :  * Returns 0 on success.  An error code other.  */</a>
<span class="lineNum">     402 </span>            : static int
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : check_signature_end (PKT_public_key *pk, PKT_signature *sig,</span>
<span class="lineNum">     404 </span>            :                      gcry_md_hd_t digest,
<span class="lineNum">     405 </span>            :                      int *r_expired, int *r_revoked, PKT_public_key *ret_pk)
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     int rc = 0;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     if ((rc = check_signature_metadata_validity (pk, sig,</span>
<span class="lineNum">     410 </span>            :                                                  r_expired, r_revoked)))
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         return rc;</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :     if ((rc = check_signature_end_simple (pk, sig, digest)))</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :       return rc;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     if(!rc &amp;&amp; ret_pk)</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :       copy_public_key(ret_pk,pk);</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     420 </span>            : }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : /* This function is similar to check_signature_end, but it only checks
<span class="lineNum">     423 </span>            :    whether the signature was generated by PK.  It does not check
<a name="424"><span class="lineNum">     424 </span>            :    expiration, revocation, etc.  */</a>
<span class="lineNum">     425 </span>            : static int
<span class="lineNum">     426 </span><span class="lineNoCov">          0 : check_signature_end_simple (PKT_public_key *pk, PKT_signature *sig,</span>
<span class="lineNum">     427 </span>            :                             gcry_md_hd_t digest)
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :     gcry_mpi_t result = NULL;</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     int rc = 0;</span>
<span class="lineNum">     431 </span>            :     const struct weakhash *weak;
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     if (!opt.flags.allow_weak_digest_algos)</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       for (weak = opt.weak_digests; weak; weak = weak-&gt;next)</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :         if (sig-&gt;digest_algo == weak-&gt;algo)</span>
<span class="lineNum">     436 </span>            :           {
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :             print_digest_rejected_note(sig-&gt;digest_algo);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :             return GPG_ERR_DIGEST_ALGO;</span>
<span class="lineNum">     439 </span>            :           }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :     /* Make sure the digest algo is enabled (in case of a detached
<span class="lineNum">     442 </span>            :        signature).  */
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :     gcry_md_enable (digest, sig-&gt;digest_algo);</span>
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            :     /* Complete the digest. */
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     if( sig-&gt;version &gt;= 4 )</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, sig-&gt;version );</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     gcry_md_putc( digest, sig-&gt;sig_class );</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :     if( sig-&gt;version &lt; 4 ) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :         u32 a = sig-&gt;timestamp;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, (a &gt;&gt; 24) &amp; 0xff );</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, (a &gt;&gt; 16) &amp; 0xff );</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, (a &gt;&gt;       8) &amp; 0xff );</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest,  a           &amp; 0xff );</span>
<span class="lineNum">     455 </span>            :     }
<span class="lineNum">     456 </span>            :     else {
<span class="lineNum">     457 </span>            :         byte buf[6];
<span class="lineNum">     458 </span>            :         size_t n;
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, sig-&gt;pubkey_algo );</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         gcry_md_putc( digest, sig-&gt;digest_algo );</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :         if( sig-&gt;hashed ) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :             n = sig-&gt;hashed-&gt;len;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :             gcry_md_putc (digest, (n &gt;&gt; 8) );</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :             gcry_md_putc (digest,  n       );</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             gcry_md_write (digest, sig-&gt;hashed-&gt;data, n);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             n += 6;</span>
<span class="lineNum">     467 </span>            :         }
<span class="lineNum">     468 </span>            :         else {
<span class="lineNum">     469 </span>            :           /* Two octets for the (empty) length of the hashed
<span class="lineNum">     470 </span>            :              section. */
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :           gcry_md_putc (digest, 0);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :           gcry_md_putc (digest, 0);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :           n = 6;</span>
<span class="lineNum">     474 </span>            :         }
<span class="lineNum">     475 </span>            :         /* add some magic per Section 5.2.4 of RFC 4880.  */
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         buf[0] = sig-&gt;version;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         buf[1] = 0xff;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :         buf[2] = n &gt;&gt; 24;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :         buf[3] = n &gt;&gt; 16;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         buf[4] = n &gt;&gt;  8;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         buf[5] = n;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         gcry_md_write( digest, buf, 6 );</span>
<span class="lineNum">     483 </span>            :     }
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     gcry_md_final( digest );</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :     /* Convert the digest to an MPI.  */
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :     result = encode_md_value (pk, digest, sig-&gt;digest_algo );</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     if (!result)</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :         return GPG_ERR_GENERAL;</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :     /* Verify the signature.  */
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :     rc = pk_verify( pk-&gt;pubkey_algo, result, sig-&gt;data, pk-&gt;pkey );</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :     gcry_mpi_release (result);</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     if( !rc &amp;&amp; sig-&gt;flags.unknown_critical )</span>
<span class="lineNum">     496 </span>            :       {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :         log_info(_(&quot;assuming bad signature from key %s&quot;</span>
<span class="lineNum">     498 </span>            :                    &quot; due to an unknown critical bit\n&quot;),keystr_from_pk(pk));
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         rc = GPG_ERR_BAD_SIGNATURE;</span>
<span class="lineNum">     500 </span>            :       }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     503 </span>            : }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /* Add a uid node to a hash context.  See section 5.2.4, paragraph 4
<a name="507"><span class="lineNum">     507 </span>            :    of RFC 4880.  */</a>
<span class="lineNum">     508 </span>            : static void
<span class="lineNum">     509 </span><span class="lineNoCov">          0 : hash_uid_packet (PKT_user_id *uid, gcry_md_hd_t md, PKT_signature *sig )</span>
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     if( uid-&gt;attrib_data ) {</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         if( sig-&gt;version &gt;=4 ) {</span>
<span class="lineNum">     513 </span>            :             byte buf[5];
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :             buf[0] = 0xd1;                   /* packet of type 17 */</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :             buf[1] = uid-&gt;attrib_len &gt;&gt; 24;  /* always use 4 length bytes */</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :             buf[2] = uid-&gt;attrib_len &gt;&gt; 16;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :             buf[3] = uid-&gt;attrib_len &gt;&gt;  8;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :             buf[4] = uid-&gt;attrib_len;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :             gcry_md_write( md, buf, 5 );</span>
<span class="lineNum">     520 </span>            :         }
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         gcry_md_write( md, uid-&gt;attrib_data, uid-&gt;attrib_len );</span>
<span class="lineNum">     522 </span>            :     }
<span class="lineNum">     523 </span>            :     else {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :         if( sig-&gt;version &gt;=4 ) {</span>
<span class="lineNum">     525 </span>            :             byte buf[5];
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :             buf[0] = 0xb4;            /* indicates a userid packet */</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :             buf[1] = uid-&gt;len &gt;&gt; 24;  /* always use 4 length bytes */</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :             buf[2] = uid-&gt;len &gt;&gt; 16;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :             buf[3] = uid-&gt;len &gt;&gt;  8;</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :             buf[4] = uid-&gt;len;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :             gcry_md_write( md, buf, 5 );</span>
<span class="lineNum">     532 </span>            :         }
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         gcry_md_write( md, uid-&gt;name, uid-&gt;len );</span>
<span class="lineNum">     534 </span>            :     }
<span class="lineNum">     535 </span><span class="lineNoCov">          0 : }</span>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : static void
<span class="lineNum">     538 </span><span class="lineNoCov">          0 : cache_sig_result ( PKT_signature *sig, int result )</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     if ( !result ) {</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         sig-&gt;flags.checked = 1;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :         sig-&gt;flags.valid = 1;</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :     else if ( gpg_err_code (result) == GPG_ERR_BAD_SIGNATURE ) {</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         sig-&gt;flags.checked = 1;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         sig-&gt;flags.valid = 0;</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            :     else {
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         sig-&gt;flags.checked = 0;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         sig-&gt;flags.valid = 0;</span>
<span class="lineNum">     551 </span>            :     }
<span class="lineNum">     552 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            : /* SIG is a key revocation signature.  Check if this signature was
<span class="lineNum">     556 </span>            :  * generated by any of the public key PK's designated revokers.
<span class="lineNum">     557 </span>            :  *
<span class="lineNum">     558 </span>            :  *   PK is the public key that SIG allegedly revokes.
<span class="lineNum">     559 </span>            :  *
<span class="lineNum">     560 </span>            :  *   SIG is the revocation signature to check.
<span class="lineNum">     561 </span>            :  *
<span class="lineNum">     562 </span>            :  * This function avoids infinite recursion, which can happen if two
<span class="lineNum">     563 </span>            :  * keys are designed revokers for each other and they revoke each
<span class="lineNum">     564 </span>            :  * other.  This is done by observing that if a key A is revoked by key
<span class="lineNum">     565 </span>            :  * B we still consider the revocation to be valid even if B is
<span class="lineNum">     566 </span>            :  * revoked.  Thus, we don't need to determine whether B is revoked to
<span class="lineNum">     567 </span>            :  * determine whether A has been revoked by B, we just need to check
<span class="lineNum">     568 </span>            :  * the signature.
<span class="lineNum">     569 </span>            :  *
<span class="lineNum">     570 </span>            :  * Returns 0 if sig is valid (i.e. pk is revoked), non-0 if not
<span class="lineNum">     571 </span>            :  * revoked.  We are careful to make sure that GPG_ERR_NO_PUBKEY is
<span class="lineNum">     572 </span>            :  * only returned when a revocation signature is from a valid
<span class="lineNum">     573 </span>            :  * revocation key designated in a revkey subpacket, but the revocation
<span class="lineNum">     574 </span>            :  * key itself isn't present.
<span class="lineNum">     575 </span>            :  *
<span class="lineNum">     576 </span>            :  * XXX: This code will need to be modified if gpg ever becomes
<span class="lineNum">     577 </span>            :  * multi-threaded.  Note that this guarantees that a designated
<span class="lineNum">     578 </span>            :  * revocation sig will never be considered valid unless it is actually
<span class="lineNum">     579 </span>            :  * valid, as well as being issued by a revocation key in a valid
<span class="lineNum">     580 </span>            :  * direct signature.  Note also that this is written so that a revoked
<span class="lineNum">     581 </span>            :  * revoker can still issue revocations: i.e. If A revokes B, but A is
<span class="lineNum">     582 </span>            :  * revoked, B is still revoked.  I'm not completely convinced this is
<a name="583"><span class="lineNum">     583 </span>            :  * the proper behavior, but it matches how PGP does it. -dms */</a>
<span class="lineNum">     584 </span>            : int
<span class="lineNum">     585 </span><span class="lineNoCov">          0 : check_revocation_keys (ctrl_t ctrl, PKT_public_key *pk, PKT_signature *sig)</span>
<span class="lineNum">     586 </span>            : {
<span class="lineNum">     587 </span>            :   static int busy=0;
<span class="lineNum">     588 </span>            :   int i;
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :   int rc = GPG_ERR_GENERAL;</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   log_assert (IS_KEY_REV(sig));</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   log_assert ((sig-&gt;keyid[0]!=pk-&gt;keyid[0]) || (sig-&gt;keyid[0]!=pk-&gt;keyid[1]));</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span>            :   /* Avoid infinite recursion.  Consider the following:
<span class="lineNum">     595 </span>            :    *
<span class="lineNum">     596 </span>            :    *   - We want to check if A is revoked.
<span class="lineNum">     597 </span>            :    *
<span class="lineNum">     598 </span>            :    *   - C is a designated revoker for B and has revoked B.
<span class="lineNum">     599 </span>            :    *
<span class="lineNum">     600 </span>            :    *   - B is a designated revoker for A and has revoked A.
<span class="lineNum">     601 </span>            :    *
<span class="lineNum">     602 </span>            :    * When checking if A is revoked (in merge_selfsigs_main), we
<span class="lineNum">     603 </span>            :    * observe that A has a designed revoker.  As such, we call this
<span class="lineNum">     604 </span>            :    * function.  This function sees that there is a valid revocation
<span class="lineNum">     605 </span>            :    * signature, which is signed by B.  It then calls check_signature()
<span class="lineNum">     606 </span>            :    * to verify that the signature is good.  To check the sig, we need
<span class="lineNum">     607 </span>            :    * to lookup B.  Looking up B means calling merge_selfsigs_main,
<span class="lineNum">     608 </span>            :    * which checks whether B is revoked, which calls this function to
<span class="lineNum">     609 </span>            :    * see if B was revoked by some key.
<span class="lineNum">     610 </span>            :    *
<span class="lineNum">     611 </span>            :    * In this case, the added level of indirection doesn't hurt.  It
<span class="lineNum">     612 </span>            :    * just means a bit more work.  However, if C == A, then we'd end up
<span class="lineNum">     613 </span>            :    * in a loop.  But, it doesn't make sense to look up C anyways: even
<span class="lineNum">     614 </span>            :    * if B is revoked, we conservatively consider a valid revocation
<span class="lineNum">     615 </span>            :    * signed by B to revoke A.  Since this is the only place where this
<span class="lineNum">     616 </span>            :    * type of recursion can occur, we simply cause this function to
<span class="lineNum">     617 </span>            :    * fail if it is entered recursively.  */
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :   if (busy)</span>
<span class="lineNum">     619 </span>            :     {
<span class="lineNum">     620 </span>            :       /* Return an error (i.e. not revoked), but mark the pk as
<span class="lineNum">     621 </span>            :          uncacheable as we don't really know its revocation status
<span class="lineNum">     622 </span>            :          until it is checked directly.  */
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :       pk-&gt;flags.dont_cache = 1;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       return rc;</span>
<span class="lineNum">     625 </span>            :     }
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   busy=1;</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   /*  es_printf(&quot;looking at %08lX with a sig from %08lX\n&quot;,(ulong)pk-&gt;keyid[1],
<span class="lineNum">     630 </span>            :       (ulong)sig-&gt;keyid[1]); */
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :   /* is the issuer of the sig one of our revokers? */
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :   if( !pk-&gt;revkey &amp;&amp; pk-&gt;numrevkeys )</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :      BUG();</span>
<span class="lineNum">     635 </span>            :   else
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       for(i=0;i&lt;pk-&gt;numrevkeys;i++)</span>
<span class="lineNum">     637 </span>            :         {
<span class="lineNum">     638 </span>            :           /* The revoker's keyid.  */
<span class="lineNum">     639 </span>            :           u32 keyid[2];
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :           keyid_from_fingerprint (ctrl, pk-&gt;revkey[i].fpr,</span>
<span class="lineNum">     642 </span>            :                                   MAX_FINGERPRINT_LEN, keyid);
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :           if(keyid[0]==sig-&gt;keyid[0] &amp;&amp; keyid[1]==sig-&gt;keyid[1])</span>
<span class="lineNum">     645 </span>            :             /* The signature was generated by a designated revoker.
<span class="lineNum">     646 </span>            :                Verify the signature.  */
<span class="lineNum">     647 </span>            :             {
<span class="lineNum">     648 </span>            :               gcry_md_hd_t md;
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :               if (gcry_md_open (&amp;md, sig-&gt;digest_algo, 0))</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                 BUG ();</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :               hash_public_key(md,pk);</span>
<span class="lineNum">     653 </span>            :               /* Note: check_signature only checks that the signature
<span class="lineNum">     654 </span>            :                  is good.  It does not fail if the key is revoked.  */
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :               rc = check_signature (ctrl, sig, md);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :               cache_sig_result(sig,rc);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :               gcry_md_close (md);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     659 </span>            :             }
<span class="lineNum">     660 </span>            :         }
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   busy=0;</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">     665 </span>            : }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            : /* Check that the backsig BACKSIG from the subkey SUB_PK to its
<span class="lineNum">     668 </span>            :    primary key MAIN_PK is valid.
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :    Backsigs (0x19) have the same format as binding sigs (0x18), but
<span class="lineNum">     671 </span>            :    this function is simpler than check_key_signature in a few ways.
<span class="lineNum">     672 </span>            :    For example, there is no support for expiring backsigs since it is
<span class="lineNum">     673 </span>            :    questionable what such a thing actually means.  Note also that the
<span class="lineNum">     674 </span>            :    sig cache check here, unlike other sig caches in GnuPG, is not
<a name="675"><span class="lineNum">     675 </span>            :    persistent. */</a>
<span class="lineNum">     676 </span>            : int
<span class="lineNum">     677 </span><span class="lineNoCov">          0 : check_backsig (PKT_public_key *main_pk,PKT_public_key *sub_pk,</span>
<span class="lineNum">     678 </span>            :                PKT_signature *backsig)
<span class="lineNum">     679 </span>            : {
<span class="lineNum">     680 </span>            :   gcry_md_hd_t md;
<span class="lineNum">     681 </span>            :   int rc;
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :   /* Always check whether the algorithm is available.  Although
<span class="lineNum">     684 </span>            :      gcry_md_open would throw an error, some libgcrypt versions will
<span class="lineNum">     685 </span>            :      print a debug message in that case too. */
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   if ((rc=openpgp_md_test_algo (backsig-&gt;digest_algo)))</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   if(!opt.no_sig_cache &amp;&amp; backsig-&gt;flags.checked)</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     return backsig-&gt;flags.valid? 0 : gpg_error (GPG_ERR_BAD_SIGNATURE);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   rc = gcry_md_open (&amp;md, backsig-&gt;digest_algo,0);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   if (!rc)</span>
<span class="lineNum">     694 </span>            :     {
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       hash_public_key(md,main_pk);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       hash_public_key(md,sub_pk);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       rc = check_signature_end (sub_pk, backsig, md, NULL, NULL, NULL);</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :       cache_sig_result(backsig,rc);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       gcry_md_close(md);</span>
<span class="lineNum">     700 </span>            :     }
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">     703 </span>            : }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            : /* Check that a signature over a key is valid.  This is a
<span class="lineNum">     707 </span>            :  * specialization of check_key_signature2 with the unnamed parameters
<span class="lineNum">     708 </span>            :  * passed as NULL.  See the documentation for that function for more
<a name="709"><span class="lineNum">     709 </span>            :  * details.  */</a>
<span class="lineNum">     710 </span>            : int
<span class="lineNum">     711 </span><span class="lineNoCov">          0 : check_key_signature (ctrl_t ctrl, kbnode_t root, kbnode_t node,</span>
<span class="lineNum">     712 </span>            :                      int *is_selfsig)
<span class="lineNum">     713 </span>            : {
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   return check_key_signature2 (ctrl, root, node, NULL, NULL,</span>
<span class="lineNum">     715 </span>            :                                is_selfsig, NULL, NULL);
<span class="lineNum">     716 </span>            : }
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : /* Returns whether SIGNER generated the signature SIG over the packet
<span class="lineNum">     720 </span>            :    PACKET, which is a key, subkey or uid, and comes from the key block
<span class="lineNum">     721 </span>            :    KB.  (KB is PACKET's corresponding keyblock; we don't assume that
<span class="lineNum">     722 </span>            :    SIG has been added to the keyblock.)
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :    If SIGNER is set, then checks whether SIGNER generated the
<span class="lineNum">     725 </span>            :    signature.  Otherwise, uses SIG-&gt;KEYID to find the alleged signer.
<span class="lineNum">     726 </span>            :    This parameter can be used to effectively override the alleged
<span class="lineNum">     727 </span>            :    signer that is stored in SIG.
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :    KB may be NULL if SIGNER is set.
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :    Unlike check_key_signature, this function ignores any cached
<span class="lineNum">     732 </span>            :    results!  That is, it does not consider SIG-&gt;FLAGS.CHECKED and
<span class="lineNum">     733 </span>            :    SIG-&gt;FLAGS.VALID nor does it set them.
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :    This doesn't check the signature's semantic mean.  Concretely, it
<span class="lineNum">     736 </span>            :    doesn't check whether a non-self signed revocation signature was
<span class="lineNum">     737 </span>            :    created by a designated revoker.  In fact, it doesn't return an
<span class="lineNum">     738 </span>            :    error for a binding generated by a completely different key!
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :    Returns 0 if the signature is valid.  Returns GPG_ERR_SIG_CLASS if
<span class="lineNum">     741 </span>            :    this signature can't be over PACKET.  Returns GPG_ERR_NOT_FOUND if
<span class="lineNum">     742 </span>            :    the key that generated the signature (according to SIG) could not
<span class="lineNum">     743 </span>            :    be found.  Returns GPG_ERR_BAD_SIGNATURE if the signature is bad.
<span class="lineNum">     744 </span>            :    Other errors codes may be returned if something else goes wrong.
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :    IF IS_SELFSIG is not NULL, sets *IS_SELFSIG to 1 if this is a
<span class="lineNum">     747 </span>            :    self-signature (by the key's primary key) or 0 if not.
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span>            :    If RET_PK is not NULL, returns a copy of the public key that
<span class="lineNum">     750 </span>            :    generated the signature (i.e., the signer) on success.  This must
<a name="751"><span class="lineNum">     751 </span>            :    be released by the caller using release_public_key_parts ().  */</a>
<span class="lineNum">     752 </span>            : gpg_error_t
<span class="lineNum">     753 </span><span class="lineNoCov">          0 : check_signature_over_key_or_uid (ctrl_t ctrl, PKT_public_key *signer,</span>
<span class="lineNum">     754 </span>            :                                  PKT_signature *sig, KBNODE kb, PACKET *packet,
<span class="lineNum">     755 </span>            :                                  int *is_selfsig, PKT_public_key *ret_pk)
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span>            :   int rc;
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   PKT_public_key *pripk = kb-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">     759 </span>            :   gcry_md_hd_t md;
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :   int signer_alloced = 0;</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :   rc = openpgp_pk_test_algo (sig-&gt;pubkey_algo);</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   rc = openpgp_md_test_algo (sig-&gt;digest_algo);</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :   /* A signature's class indicates the type of packet that it
<span class="lineNum">     770 </span>            :      signs.  */
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   if (/* Primary key binding (made by a subkey).  */</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :       sig-&gt;sig_class == 0x19</span>
<span class="lineNum">     773 </span>            :       /* Direct key signature.  */
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :       || sig-&gt;sig_class == 0x1f</span>
<span class="lineNum">     775 </span>            :       /* Primary key revocation.  */
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :       || sig-&gt;sig_class == 0x20)</span>
<span class="lineNum">     777 </span>            :     {
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :       if (packet-&gt;pkttype != PKT_PUBLIC_KEY)</span>
<span class="lineNum">     779 </span>            :         /* Key revocations can only be over primary keys.  */
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :         return gpg_error (GPG_ERR_SIG_CLASS);</span>
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :   else if (/* Subkey binding.  */</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :            sig-&gt;sig_class == 0x18</span>
<span class="lineNum">     784 </span>            :            /* Subkey revocation.  */
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x28)</span>
<span class="lineNum">     786 </span>            :     {
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :       if (packet-&gt;pkttype != PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         return gpg_error (GPG_ERR_SIG_CLASS);</span>
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   else if (/* Certification.  */</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :            sig-&gt;sig_class == 0x10</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x11</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x12</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x13</span>
<span class="lineNum">     795 </span>            :            /* Certification revocation.  */
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x30)</span>
<span class="lineNum">     797 </span>            :     {
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :       if (packet-&gt;pkttype != PKT_USER_ID)</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         return gpg_error (GPG_ERR_SIG_CLASS);</span>
<span class="lineNum">     800 </span>            :     }
<span class="lineNum">     801 </span>            :   else
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     return gpg_error (GPG_ERR_SIG_CLASS);</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :   /* PACKET is the right type for SIG.  */
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   if (signer)</span>
<span class="lineNum">     807 </span>            :     {
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :       if (is_selfsig)</span>
<span class="lineNum">     809 </span>            :         {
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :           if (signer-&gt;keyid[0] == pripk-&gt;keyid[0]</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :               &amp;&amp; signer-&gt;keyid[1] == pripk-&gt;keyid[1])</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :             *is_selfsig = 1;</span>
<span class="lineNum">     813 </span>            :           else
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :             *is_selfsig = 0;</span>
<span class="lineNum">     815 </span>            :         }
<span class="lineNum">     816 </span>            :     }
<span class="lineNum">     817 </span>            :   else
<span class="lineNum">     818 </span>            :     {
<span class="lineNum">     819 </span>            :       /* Get the signer.  If possible, avoid a look up.  */
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       if (sig-&gt;keyid[0] == pripk-&gt;keyid[0]</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :           &amp;&amp; sig-&gt;keyid[1] == pripk-&gt;keyid[1])</span>
<span class="lineNum">     822 </span>            :         /* Issued by the primary key.  */
<span class="lineNum">     823 </span>            :         {
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :           signer = pripk;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :           if (is_selfsig)</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :             *is_selfsig = 1;</span>
<span class="lineNum">     827 </span>            :         }
<span class="lineNum">     828 </span>            :       else
<span class="lineNum">     829 </span>            :         {
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :           kbnode_t ctx = NULL;</span>
<span class="lineNum">     831 </span>            :           kbnode_t n;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :           /* See if one of the subkeys was the signer (although this
<span class="lineNum">     834 </span>            :              is extremely unlikely).  */
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :           while ((n = walk_kbnode (kb, &amp;ctx, 0)))</span>
<span class="lineNum">     836 </span>            :             {
<span class="lineNum">     837 </span>            :               PKT_public_key *subk;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :               if (n-&gt;pkt-&gt;pkttype != PKT_PUBLIC_SUBKEY)</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :               subk = n-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :               if (sig-&gt;keyid[0] == subk-&gt;keyid[0]</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :                   &amp;&amp; sig-&gt;keyid[1] == subk-&gt;keyid[1])</span>
<span class="lineNum">     845 </span>            :                 /* Issued by a subkey.  */
<span class="lineNum">     846 </span>            :                 {
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                   signer = subk;</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">     849 </span>            :                 }
<span class="lineNum">     850 </span>            :             }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :           if (! signer)</span>
<span class="lineNum">     853 </span>            :             /* Signer by some other key.  */
<span class="lineNum">     854 </span>            :             {
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :               if (is_selfsig)</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                 *is_selfsig = 0;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :               if (ret_pk)</span>
<span class="lineNum">     858 </span>            :                 {
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                   signer = ret_pk;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :                   memset (signer, 0, sizeof (*signer));</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                   signer_alloced = 1;</span>
<span class="lineNum">     862 </span>            :                 }
<span class="lineNum">     863 </span>            :               else
<span class="lineNum">     864 </span>            :                 {
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :                   signer = xmalloc_clear (sizeof (*signer));</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :                   signer_alloced = 2;</span>
<span class="lineNum">     867 </span>            :                 }
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :               rc = get_pubkey (ctrl, signer, sig-&gt;keyid);</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :               if (rc)</span>
<span class="lineNum">     871 </span>            :                 {
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :                   xfree (signer);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :                   signer = NULL;</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :                   signer_alloced = 0;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :                   goto out;</span>
<span class="lineNum">     876 </span>            :                 }
<span class="lineNum">     877 </span>            :             }
<span class="lineNum">     878 </span>            :         }
<span class="lineNum">     879 </span>            :     }
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   /* We checked above that we supported this algo, so an error here is
<span class="lineNum">     882 </span>            :      a bug.  */
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   if (gcry_md_open (&amp;md, sig-&gt;digest_algo, 0))</span>
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     BUG ();</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :   /* Hash the relevant data.  */
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   if (/* Direct key signature.  */</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :       sig-&gt;sig_class == 0x1f</span>
<span class="lineNum">     890 </span>            :       /* Primary key revocation.  */
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :       || sig-&gt;sig_class == 0x20)</span>
<span class="lineNum">     892 </span>            :     {
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       log_assert (packet-&gt;pkttype == PKT_PUBLIC_KEY);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :       hash_public_key (md, packet-&gt;pkt.public_key);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       rc = check_signature_end_simple (signer, sig, md);</span>
<span class="lineNum">     896 </span>            :     }
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   else if (/* Primary key binding (made by a subkey).  */</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :       sig-&gt;sig_class == 0x19)</span>
<span class="lineNum">     899 </span>            :     {
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       log_assert (packet-&gt;pkttype == PKT_PUBLIC_KEY);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :       hash_public_key (md, packet-&gt;pkt.public_key);</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       hash_public_key (md, signer);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       rc = check_signature_end_simple (signer, sig, md);</span>
<span class="lineNum">     904 </span>            :     }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   else if (/* Subkey binding.  */</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :            sig-&gt;sig_class == 0x18</span>
<span class="lineNum">     907 </span>            :            /* Subkey revocation.  */
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x28)</span>
<span class="lineNum">     909 </span>            :     {
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :       log_assert (packet-&gt;pkttype == PKT_PUBLIC_SUBKEY);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       hash_public_key (md, pripk);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :       hash_public_key (md, packet-&gt;pkt.public_key);</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       rc = check_signature_end_simple (signer, sig, md);</span>
<span class="lineNum">     914 </span>            :     }
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :   else if (/* Certification.  */</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :            sig-&gt;sig_class == 0x10</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x11</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x12</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x13</span>
<span class="lineNum">     920 </span>            :            /* Certification revocation.  */
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x30)</span>
<span class="lineNum">     922 </span>            :     {
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :       log_assert (packet-&gt;pkttype == PKT_USER_ID);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :       hash_public_key (md, pripk);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :       hash_uid_packet (packet-&gt;pkt.user_id, md, sig);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :       rc = check_signature_end_simple (signer, sig, md);</span>
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            :   else
<span class="lineNum">     929 </span>            :     /* We should never get here.  (The first if above should have
<span class="lineNum">     930 </span>            :        already caught this error.)  */
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     BUG ();</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   gcry_md_close (md);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :  out:
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :   if (! rc &amp;&amp; ret_pk &amp;&amp; (signer_alloced == -1 || ret_pk != signer))</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     copy_public_key (ret_pk, signer);</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   if (signer_alloced == 1)</span>
<span class="lineNum">     939 </span>            :     /* We looked up SIGNER; it is not a pointer into KB.  */
<span class="lineNum">     940 </span>            :     {
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       release_public_key_parts (signer);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       if (signer_alloced == 2)</span>
<span class="lineNum">     943 </span>            :         /* We also allocated the memory.  */
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         xfree (signer);</span>
<span class="lineNum">     945 </span>            :     }
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">     948 </span>            : }
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            : /* Check that a signature over a key (e.g., a key revocation, key
<span class="lineNum">     951 </span>            :  * binding, user id certification, etc.) is valid.  If the function
<span class="lineNum">     952 </span>            :  * detects a self-signature, it uses the public key from the specified
<span class="lineNum">     953 </span>            :  * key block and does not bother looking up the key specified in the
<span class="lineNum">     954 </span>            :  * signature packet.
<span class="lineNum">     955 </span>            :  *
<span class="lineNum">     956 </span>            :  * ROOT is a keyblock.
<span class="lineNum">     957 </span>            :  *
<span class="lineNum">     958 </span>            :  * NODE references a signature packet that appears in the keyblock
<span class="lineNum">     959 </span>            :  * that should be verified.
<span class="lineNum">     960 </span>            :  *
<span class="lineNum">     961 </span>            :  * If CHECK_PK is set, the specified key is sometimes preferred for
<span class="lineNum">     962 </span>            :  * verifying signatures.  See the implementation for details.
<span class="lineNum">     963 </span>            :  *
<span class="lineNum">     964 </span>            :  * If RET_PK is not NULL, the public key that successfully verified
<span class="lineNum">     965 </span>            :  * the signature is copied into *RET_PK.
<span class="lineNum">     966 </span>            :  *
<span class="lineNum">     967 </span>            :  * If IS_SELFSIG is not NULL, *IS_SELFSIG is set to 1 if NODE is a
<span class="lineNum">     968 </span>            :  * self-signature.
<span class="lineNum">     969 </span>            :  *
<span class="lineNum">     970 </span>            :  * If R_EXPIREDATE is not NULL, *R_EXPIREDATE is set to the expiry
<span class="lineNum">     971 </span>            :  * date.
<span class="lineNum">     972 </span>            :  *
<span class="lineNum">     973 </span>            :  * If R_EXPIRED is not NULL, *R_EXPIRED is set to 1 if PK has been
<span class="lineNum">     974 </span>            :  * expired (0 otherwise).  Note: PK being revoked does not cause this
<span class="lineNum">     975 </span>            :  * function to fail.
<span class="lineNum">     976 </span>            :  *
<span class="lineNum">     977 </span>            :  *
<span class="lineNum">     978 </span>            :  * If OPT.NO_SIG_CACHE is not set, this function will first check if
<span class="lineNum">     979 </span>            :  * the result of a previous verification is already cached in the
<span class="lineNum">     980 </span>            :  * signature packet's data structure.
<span class="lineNum">     981 </span>            :  *
<span class="lineNum">     982 </span>            :  * TODO: add r_revoked here as well.  It has the same problems as
<a name="983"><span class="lineNum">     983 </span>            :  * r_expiredate and r_expired and the cache.  */</a>
<span class="lineNum">     984 </span>            : int
<span class="lineNum">     985 </span><span class="lineNoCov">          0 : check_key_signature2 (ctrl_t ctrl,</span>
<span class="lineNum">     986 </span>            :                       kbnode_t root, kbnode_t node, PKT_public_key *check_pk,
<span class="lineNum">     987 </span>            :                       PKT_public_key *ret_pk, int *is_selfsig,
<span class="lineNum">     988 </span>            :                       u32 *r_expiredate, int *r_expired )
<span class="lineNum">     989 </span>            : {
<span class="lineNum">     990 </span>            :   PKT_public_key *pk;
<span class="lineNum">     991 </span>            :   PKT_signature *sig;
<span class="lineNum">     992 </span>            :   int algo;
<span class="lineNum">     993 </span>            :   int rc;
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   if (is_selfsig)</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :     *is_selfsig = 0;</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :   if (r_expiredate)</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :     *r_expiredate = 0;</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :   if (r_expired)</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :     *r_expired = 0;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   log_assert (node-&gt;pkt-&gt;pkttype == PKT_SIGNATURE);</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   log_assert (root-&gt;pkt-&gt;pkttype == PKT_PUBLIC_KEY);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   pk = root-&gt;pkt-&gt;pkt.public_key;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :   sig = node-&gt;pkt-&gt;pkt.signature;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   algo = sig-&gt;digest_algo;</span>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :   /* Check whether we have cached the result of a previous signature
<span class="lineNum">    1009 </span>            :      check.  Note that we may no longer have the pubkey or hash
<span class="lineNum">    1010 </span>            :      needed to verify a sig, but can still use the cached value.  A
<span class="lineNum">    1011 </span>            :      cache refresh detects and clears these cases. */
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   if ( !opt.no_sig_cache )</span>
<span class="lineNum">    1013 </span>            :     {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :       cache_stats.total++;</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       if (sig-&gt;flags.checked) /* Cached status available.  */</span>
<span class="lineNum">    1016 </span>            :         {
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :           cache_stats.cached++;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :           if (is_selfsig)</span>
<span class="lineNum">    1019 </span>            :             {
<span class="lineNum">    1020 </span>            :               u32 keyid[2];
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :               keyid_from_pk (pk, keyid);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :               if (keyid[0] == sig-&gt;keyid[0] &amp;&amp; keyid[1] == sig-&gt;keyid[1])</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                 *is_selfsig = 1;</span>
<span class="lineNum">    1025 </span>            :             }
<span class="lineNum">    1026 </span>            :           /* BUG: This is wrong for non-self-sigs... needs to be the
<span class="lineNum">    1027 </span>            :              actual pk.  */
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :           rc = check_signature_metadata_validity (pk, sig, r_expired, NULL);</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :           if (rc)</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :             return rc;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :           if (sig-&gt;flags.valid)</span>
<span class="lineNum">    1032 </span>            :             {
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :               cache_stats.goodsig++;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :               return 0;</span>
<span class="lineNum">    1035 </span>            :             }
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :           cache_stats.badsig++;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :           return gpg_error (GPG_ERR_BAD_SIGNATURE);</span>
<span class="lineNum">    1038 </span>            :         }
<span class="lineNum">    1039 </span>            :     }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   rc = openpgp_pk_test_algo(sig-&gt;pubkey_algo);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   rc = openpgp_md_test_algo(algo);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   if (rc)</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :     return rc;</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :   if (sig-&gt;sig_class == 0x20) /* key revocation */</span>
<span class="lineNum">    1049 </span>            :     {
<span class="lineNum">    1050 </span>            :       u32 keyid[2];
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :       keyid_from_pk( pk, keyid );</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :       /* Is it a designated revoker? */
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :       if (keyid[0] != sig-&gt;keyid[0] || keyid[1] != sig-&gt;keyid[1])</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         rc = check_revocation_keys (ctrl, pk, sig);</span>
<span class="lineNum">    1056 </span>            :       else
<span class="lineNum">    1057 </span>            :         {
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :           rc = check_signature_metadata_validity (pk, sig,</span>
<span class="lineNum">    1059 </span>            :                                                   r_expired, NULL);
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :           if (! rc)</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :             rc = check_signature_over_key_or_uid (ctrl, pk, sig,</span>
<span class="lineNum">    1062 </span>            :                                                   root, root-&gt;pkt,
<span class="lineNum">    1063 </span>            :                                                   is_selfsig, ret_pk);
<span class="lineNum">    1064 </span>            :         }
<span class="lineNum">    1065 </span>            :     }
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :   else if (sig-&gt;sig_class == 0x28  /* subkey revocation */</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :            || sig-&gt;sig_class == 0x18) /* key binding */</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :       kbnode_t snode = find_prev_kbnode (root, node, PKT_PUBLIC_SUBKEY);</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :       if (snode)</span>
<span class="lineNum">    1072 </span>            :         {
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :           rc = check_signature_metadata_validity (pk, sig,</span>
<span class="lineNum">    1074 </span>            :                                                   r_expired, NULL);
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :           if (! rc)</span>
<span class="lineNum">    1076 </span>            :             /* 0x28 must be a self-sig, but 0x18 needn't be.  */
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :             rc = check_signature_over_key_or_uid (ctrl,</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :                                                   sig-&gt;sig_class == 0x18</span>
<span class="lineNum">    1079 </span>            :                                                   ? NULL : pk,
<span class="lineNum">    1080 </span>            :                                                   sig, root, snode-&gt;pkt,
<span class="lineNum">    1081 </span>            :                                                   is_selfsig, ret_pk);
<span class="lineNum">    1082 </span>            :         }
<span class="lineNum">    1083 </span>            :       else
<span class="lineNum">    1084 </span>            :         {
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :           if (opt.verbose)</span>
<span class="lineNum">    1086 </span>            :             {
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :               if (sig-&gt;sig_class == 0x28)</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                 log_info (_(&quot;key %s: no subkey for subkey&quot;</span>
<span class="lineNum">    1089 </span>            :                             &quot; revocation signature\n&quot;), keystr_from_pk(pk));
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :               else if (sig-&gt;sig_class == 0x18)</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                 log_info(_(&quot;key %s: no subkey for subkey&quot;</span>
<span class="lineNum">    1092 </span>            :                            &quot; binding signature\n&quot;), keystr_from_pk(pk));
<span class="lineNum">    1093 </span>            :             }
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :           rc = GPG_ERR_SIG_CLASS;</span>
<span class="lineNum">    1095 </span>            :         }
<span class="lineNum">    1096 </span>            :     }
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     else if (sig-&gt;sig_class == 0x1f) /* direct key signature */</span>
<span class="lineNum">    1098 </span>            :       {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         rc = check_signature_metadata_validity (pk, sig,</span>
<span class="lineNum">    1100 </span>            :                                                 r_expired, NULL);
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :         if (! rc)</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :           rc = check_signature_over_key_or_uid (ctrl, pk, sig, root, root-&gt;pkt,</span>
<span class="lineNum">    1103 </span>            :                                                 is_selfsig, ret_pk);
<span class="lineNum">    1104 </span>            :       }
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     else if (/* Certification.  */</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :              sig-&gt;sig_class == 0x10</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :              || sig-&gt;sig_class == 0x11</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :              || sig-&gt;sig_class == 0x12</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :              || sig-&gt;sig_class == 0x13</span>
<span class="lineNum">    1110 </span>            :              /* Certification revocation.  */
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :              || sig-&gt;sig_class == 0x30)</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         kbnode_t unode = find_prev_kbnode (root, node, PKT_USER_ID);</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         if (unode)</span>
<span class="lineNum">    1116 </span>            :           {
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :             rc = check_signature_metadata_validity (pk, sig, r_expired, NULL);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :             if (! rc)</span>
<span class="lineNum">    1119 </span>            :               /* If this is a self-sig, ignore check_pk.  */
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :               rc = check_signature_over_key_or_uid</span>
<span class="lineNum">    1121 </span>            :                 (ctrl,
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                  keyid_cmp (pk_keyid (pk), sig-&gt;keyid) == 0 ? pk : check_pk,</span>
<span class="lineNum">    1123 </span>            :                  sig, root, unode-&gt;pkt, NULL, ret_pk);
<span class="lineNum">    1124 </span>            :           }
<span class="lineNum">    1125 </span>            :         else
<span class="lineNum">    1126 </span>            :           {
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :             if (!opt.quiet)</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :               log_info (&quot;key %s: no user ID for key signature packet&quot;</span>
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :                         &quot; of class %02x\n&quot;,keystr_from_pk(pk),sig-&gt;sig_class);</span>
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :             rc = GPG_ERR_SIG_CLASS;</span>
<span class="lineNum">    1131 </span>            :           }
<span class="lineNum">    1132 </span>            :       }
<span class="lineNum">    1133 </span>            :   else
<span class="lineNum">    1134 </span>            :     {
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       log_info (&quot;sig issued by %s with class %d (digest: %02x %02x)&quot;</span>
<span class="lineNum">    1136 </span>            :                 &quot; is not valid over a user id or a key id, ignoring.\n&quot;,
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 keystr (sig-&gt;keyid), sig-&gt;sig_class,</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                 sig-&gt;digest_start[0], sig-&gt;digest_start[1]);</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :       rc = gpg_error (GPG_ERR_BAD_SIGNATURE);</span>
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :   cache_sig_result  (sig, rc);</span>
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   return rc;</span>
<span class="lineNum">    1145 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
